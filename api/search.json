[{"id":"5c608ba3383f27b31f8830b3a9b5f6d6","title":"应用性能分析方法","content":"应用性能分析方法1. 采样顾名思义，采样(或基于探测点的性能分析)是指以一定的周期间隔采集状态，这通常需要借助工具。由于不会干扰应用的执行，因此采样可以很好地提供应用的全景图。采样的不足之处在于它不能返回 100% 精确的细节。如果采样的频率是 10 毫秒，那么你就无法得知在探测点之间的 9.999 毫秒内发生了什么。\n\n采样可以作为初始的性能调研手段，并可用于跟踪 CPU 和内存的使用情况\n\n2. 埋点通过修改代码，记录细节信息的埋点能够提供比采样更加精确的结果。你既可以在关键部分主动埋点，也可以在性能分析或处理用户反馈时有针对性地埋点因为埋点需要注入额外代码，所以它一定会影响应用的性能，对内存或速度(或同时对二者)造成损害。\n1.4 测量现在，我们已经确定了需要测量的参数，并且研究了测量所需要的不同类型的分析。我们先简单了解一下如何实现测量。\n通过测量性能并找出真正存在问题的地方，你可以避免掉入过早优化的陷阱.\n\n真正的问题在于,程序开发人员为提升程序效率在错误的方向和时间点浪费了太多时间;过早优化是编程领域的万恶(至少是绝大多数的恶)之源。\n\n1.4.1 设置工程与代码接下来，我们将建立一个工程，以便在开发和生产阶段测量已经定义好的参数。针对工程配置、安装和代码实现共有三类任务。\n\n构建与发布 : 确保能够轻松地构建和发布应用。\n\n可测试性 确保你的代码能够同时在模拟数据和真实数据之上工作，其中包括能够模拟真实场景的隔离环境\n\n可跟踪性 确保你能够通过明确问题发生的位置和代码行为来处理错误。\n\n\n1. 构建与发布由于对灵活和敏捷的强烈需求，系统和工具得到了改进。改进后的系统和工具现在可以加速拉取依赖信息，加速构建和发布用于测试或企业分发的产品，也可以为公众发布而提高提交文件到 iTunes Connect 的速度。\n基于 Ruby 语言实现的 CocoaPods(https://cocoapods.org)实际上是 Objective-C 和 Swift 工程的依赖管理器。CocoaPods 与 Xcode 命令行工具相集成，可用于构建与发布。\n2. 可测试性每个应用都包含多个协同工作的组件。一个设计良好的系统应该遵循低耦合和高内聚，并允许替换任意或全部组件的依赖。\n可以通过模拟依赖项目对每个组件进行隔离测试。一般来说，测试有两种类型。\n• 单元测试 验证每个代码单元在隔离环境下的操作。常见的做法是，在特定的环境中用不同的输入数据反复地调用一些方法，以评估代码的表现。\n• 功能测试 验证组件在最终集成的安装包中的操作。可以在软件的最终发布版本中验证，也可以在某个为测试而构建的参考应用中验证。\n3. 可跟踪性在开发阶段，埋点可以帮助我们确定性能优化的优先级、提高对问题现场的还原能力，并提供更多的调试信息。崩溃报告专注于从软件的产品版本中收集调试信息。\n4. 设置崩溃报告崩溃报告系统收集用于分析应用的调试日志。市面上有数十种崩溃报告系统.\n5. 对应用埋点对应用进行埋点是了解用户行为的一个重要步骤，但更重要的目的是识别应用的关键路径。注入特定的代码以记录关键指标是提升应用性能的重要步骤。\n日志日志是无价之宝，可以用于了解应用发生了什么事。日志和埋点之间存在着细微的差别。埋点可以看作日志的子集。被埋点的任何数据都应该 记录在日志中。埋点承担了为聚合分析发布关键性能数据的职责，日志则提供了用于在不同级别跟踪应用的细节信息，比如 debug、``Verbose、``info、``warning 和 Error。日志的记录会贯穿应用的整个生命周期，而埋点只应该用在开发的特定阶段。\n埋点数据会发送到服务器，日志是记录在设备本地。 就日志而言，我们可以通过 CocoaPods 引入 CocoaLumberjack 来使用。\nCocoaLumberjack 是一个扩展性很强的框架，捆绑了一系列内置的日志记录器，这些记录器 可以向不同的目标发送信息。例如，使用 DDASLLogger 可以向 Apple System Log(ASL， NSLog 方法的默认位置)记录日志。类似地，使用 DDFileLogger 可以向文件记录日志。可 以在应用运行期间配置记录器。\nDDLog 宏指令可以用于记录某个特定层级的日志。层级越高，信息越重要。最高级 别是 Error，最低级别是 Verbose。实际记录消息的最低层级可以配置在每个文件层级、每 个 Xcode 配置层级、每个日志器层级或全局。以下的宏指令可供使用。\n\nDDLogError 表示不可恢复的错误。\nDDLogWarn 表示可恢复的错误。\nDDLogInfo 表示非错误的信息。\nDDLogDebug 表示数据主要用于调试。\nDDLogVerbose 几乎提供了所有的细节，主要用于跟踪执行过程中的控制流。这些宏指令有着与 NSLog 相同的签名。这意味着你可以直接用适合的 DDLog 调用来 取代 NSLog。\n\n","slug":"应用性能分析方法","date":"2021-05-22T07:06:49.000Z","categories_index":"","tags_index":"iOS性能优化","author_index":"LittleLight"},{"id":"d6599ba5117b38d8d4d285c032bd712d","title":"iOS性能优化指标","content":"性能指标\n性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。\n\n1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保没有泄漏内存。随时间流逝而持续增长的内存消耗意味着，应用很可能会因 为内存不足的异常而崩溃。\n1.2.2 电量消耗在编写高性能代码时，电量消耗是一个需要重点处理的重要因素。就执行时间和 CPU 资源的利用而言，我们不仅要实现高效的数据结构和算法，还需要考虑其他的因素。如果某个应用是个电池黑洞，那么一定不会有人喜欢它。\n电量消耗不仅仅与计算 CPU 周期有关，还包括高效地使用硬件。除了要实现电量消耗最 小化，还要确保不会影响用户体验。\n1.2.3 初始化时间应用在启动时应执行刚好够用的任务以完成初始化，从而满足用户的使用需求。执行这些 任务消耗的时间就是应用的初始化时间。刚好够用是一个开放式用语——正确的平衡点取 决于应用的需要。\n在首次使用应用时创建对象并进行初始化是一个合理的选择，例如，直到需要使用对象时 才创建对象。这种方式被称为惰性初始化。这是一种很好的策略，但也要考虑不能让用户 总是在执行后续任务时等待。\n下面列举了你可能想在应用初始化阶段执行的一些动作，排名不分先后。\n\n检查应用是否为首次启动。\n检查用户是否已经登录。\n如果用户已经登录，尽可能地载入之前的状态。\n连接服务器以拉取最新的变更。\n检查应用是否由某个深层链接唤起。如果是，还需要载入深层链接相应的 UI 和状态。\n检查是否存在应用上次启动时挂起的任务，需要时恢复它们。\n初始化后续需要使用的对象和线程池。\n初始化依赖项(如对象关系映射、崩溃报告系统和缓存)。\n\n这个列表可能会迅速变长，并且很难决定哪些条目一定要在启动时执行，哪些可以延后几 毫秒再执行。\n1.2.4 执行速度一旦启动应用，用户总是希望它可以尽可能快地工作。一切必要的处理都应该在尽可能短 的时间内完成。\n例如，在照片应用中，用户通常希望看到调整亮度或对比度等简单效果的实时预览效果。 因此，相应的处理需要在几毫秒内完成。\n这可能需要本地计算的并行处理技术或能够将复杂任务分发到服务器。\n1.2.5 响应速度每个应用都应该快速地响应用户交互。在应用中所做的一切优化和权衡最终都应该体现在 响应速度上。\nApp Store 中有许多应用可以完成相似或相关的任务。这为用户提供了很大的选择空间，而用户基本都会选择响应最快的应用。\n1.2.6 本地存储针对任何在服务器上存储数据或通过外部来源刷新数据的应用，开发人员应该对本地存储 的使用有所规划，以便应用具备离线浏览的能力。\n例如，用户都希望邮件应用能够在无网络或设备离线的情况下浏览历史邮件。 同样，新闻应用也应该可以在离线模式下显示最近更新的新闻，并标记出每条新闻是否已读。\n然而，从本地存储中载入和同步数据应该迅速、便捷。这不仅需要选择要在本地缓存的数 据和要优化的数据结构，还需要提供一系列的配置选项并确定数据同步的频率。\n如果你的应用使用了本地存储，那么请提供一个清除数据的选项。遗憾的是，市场上的大 部分应用都没有提供此选项。更让人烦恼的是，一些应用竟然会消耗数百兆的存储空间。 用户会频繁地卸载这些应用来回收本地存储。这会导致糟糕的用户体验，从而威胁应用的 成功。\n1.2.7 互操作性用户可能会使用多个应用来完成某个任务，这就需要这些应用直接提供互操作的能力。例 如，一个相册可能需要一个幻灯片应用来实现最佳的浏览体验，但需要另一个应用来编辑 照片。其中浏览照片的应用要能够将照片发送到编辑器，并接收编辑后的图片。\niOS 为实现应用间的互操作和数据共享提供了多种机制，其中包括 UIActivityViewController、 深层链接、MultipeerConnectivity 框架，等等。\n为深层链接定义良好的 URL 结构与编写优异的代码来解析 URL 同样重要。类似地，使用 共享对话框共享数据时，精确识别用于分享的数据非常重要，同时，在处理不同数据源传 入的数据时还要注意安全隐患。\n如果某个应用向附近设备共享数据时需要花费很长时间准备数据，那么用户体验就会非常 糟糕。\n1.2.8 网络环境移动设备会在不同网络环境下使用。为了确保能够提供最好的用户体验，你的应用应当适 应各种网络条件:\n\n高带宽稳定网络\n低带宽稳定网络\n高带宽不稳定网络\n低带宽不稳定网络\n无网络\n\n1.2.9 带宽人们会在不同的网络条件下使用自己的移动设备，网速从每秒数千字节到每秒数十兆字节。 因此，带宽的优化使用是定义应用质量的另一个关键参数。此外，在高带宽网络下运行一 个基于低带宽网络开发的应用可能会产生完全不同的结果。\n2010 年左右，我和我的团队正在印度开发一款应用。由于处于低带宽网络，应用的本地初始化速度要比从服务器端载入资源快得多，于是我们针对这种情况进行了优化。\n然而，当这款应用投入韩国市场时，我们对它进行了测试，结果却让人大跌眼镜。之前所 进行的所有优化几乎毫无意义，我们不得不重写了大部分可能导致资源和数据冲突的相关 代码。\n为提高性能所做的设计并非每次都能如愿，也可能会导致相反的效果。\n1.2.10 数据刷新即使没有提供离线浏览能力，你仍然可以从服务器端周期性地刷新数据。刷新的频率和每 次传输的数据量将决定数据传输的总量。如果传输的字节数过大，那用户必然会快速耗尽 自己的流量计划。当流量消耗大到一定程度时，你的应用很可能会流失用户。\n在 iOS 6.x 或更低版本中，在后台运行的应用不能刷新数据。从 iOS 7 开始，应用可以在后台周期性地刷新数据。对于在线聊天类应用，持久的 HTTP 连接或原生 TCP 连接可能会非常有用。\n1.2.11 多用户支持家庭成员间可能会共享移动设备，或者一个用户可能会拥有同一应用的多个账号。例如， 兄弟姐妹间可能会共享一个 iPad 来玩游戏。再比如，家庭成员可能会在旅游时配置一个设备来查收全家人的电子邮件，以减少漫游费用，尤其是在境外旅游时。类似地，一个人也 可能会配置多个电子邮件账号。\n是否支持多个并发用户取决于产品的需要。一旦决定提供此类功能，请参考以下准则。\n\n添加新用户应尽可能高效。\n在不同用户之间更新应尽可能高效。\n在不同用户之间切换应尽可能高效。\n用户数据的界限应该简洁且没有 bug。\n\n1.2.12 单点登录如果你已经创建了多个允许或需要登录的应用，那么支持单点登录(single sign-on，SSO) 是非常棒的选择。如果用户登录了一个应用，只需要点击一次，就可以登录到其他的应用中。\n这个过程不仅需要支持跨应用的数据共享，还需要分享状态、跨应用同步等。例如，如果 用户注销了其中某个应用，则通过 SSO 登录的所有其他应用也应能注销掉。 此外，应用之间的同步应该是安全的。\n1.2.13 安全安全对移动应用来说是最重要的，因为敏感信息可能会在应用间共享。因此，对所有通信 以及本地数据和共享数据进行加密就显得尤为重要了。\n实现安全需要更多的计算、内存和存储，但这与最大化运行速度、最小化内存和存储使用 的目标相冲突。\n因此，你需要在安全和其他因素之间进行权衡。\n引入多个安全层会影响性能，并对用户体验造成可感知的负面影响。如何设定安全的基线 需要参考对用户群体的统计分析。此外，硬件在其中扮演了重要的角色:选择会因为不同 设备的计算能力而有所不同。\n1.2.14 崩溃应用可能会而且确实会崩溃。过度优化会导致崩溃。同样，使用原始 C 代码也可能会导致 崩溃。 高性能的应用不仅应尽可能地避免崩溃，还应该在崩溃发生时优雅地恢复，尤其是在进行 某个操作的过程中发生崩溃时。\n综上所述\n性能主要从以上所有面向用户的基本属性指标分析\n\n\n\n","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","categories_index":"","tags_index":"iOS性能优化","author_index":"LittleLight"},{"id":"eafabc105702abbd3d554d5c51e703dd","title":"iOS内存对齐","content":"iOS中内存对齐数据对齐规则\n结构体和联合体（union）的数据成员，第一个数据成员放到offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员子成员大小（只要该成员有子成员，比如说数组，结构体等）的整数倍开始（比如int为4自己接，则要从4的整数倍地址开始存储）\n\n结构体作为成员，则结构体成员要从其内部最大元素大小的整数倍开始存储( 那么b应该从8的整数倍开始存储)\nstruct GLStruct1 &#123;\n  char a; &#x2F;&#x2F; 1 + 7（不全七个）\n  double b; &#x2F;&#x2F; 8 字节\n  int c; &#x2F;&#x2F; 4 字节\n  short d; &#x2F;&#x2F; 2 字节\n&#125; GLStruct1;\n\n\nstruct GLStruct2 &#123;\n  double b; &#x2F;&#x2F; 8字节\n  char a; &#x2F;&#x2F; 1 字节\n   int c; &#x2F;&#x2F; 4 字节\n  short d; &#x2F;&#x2F;  2字节\n&#125; GLStruct2;\n\nNSLog(@&quot;%lu - %lu&quot;, sizeof(GLStruct1), sizeof(GLStruct1));\n\n关于分配内存8字节对齐#import &lt;Foundation&#x2F;Foundation.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface GLPerson : NSObject\n  \n@Property (nonatomic, copy) NSString *name;\n@Property (nonatomic, assign) int age;\n@Property (nonatomic, assign) long height;\n@Property (nonatomic, copy) NSString *hobby;\n\n\n\n&#x2F;&#x2F; @Property (nonatomic, assign) int sex;\n&#x2F;&#x2F; @Property (nonatomic) char ch1;\n&#x2F;&#x2F; @Property (nonatomic) char ch2;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n\n\nGLPerson *person &#x3D; [GLPerson alloc];\nperson.name &#x3D; @&quot;张三&quot;；\nperson.age &#x3D; 18;\nperson.height &#x3D; 180;\nperson.hobby &#x3D; @&quot;nv&quot;\n  \n总共分配对象实例的内存大小： \n  isa 8个字节\n  name 8个字节\n  age  4个字节\n  height 8个字节\n  hobby  8个字节\n  \nNSLog(@&quot;%lu - %lu&quot;, class_getInstancesClass([person class]))\n\n注意：对象申请的内存大小  VS  系统开辟的大小 不一致\nvoid *\ncalloc(size_t num_items, size_t size)\n&#123;\n\tvoid *retval;\n\tretval &#x3D; malloc_zone_calloc(default_zone, num_items, size);\n\tif (retval &#x3D;&#x3D; NULL) &#123;\n\t\terrno &#x3D; ENOMEM;\n\t&#125;\n\treturn retval;\n&#125;\n\n\n\n\nvoid *\nmalloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n\tMALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);\n\n\tvoid *ptr;\n\tif (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;&#x3D; malloc_check_start)) &#123;\n\t\tinternal_check();\n\t&#125;\n\n\tptr &#x3D; zone-&gt;calloc(zone, num_items, size);\n\t\n\tif (malloc_logger) &#123;\n\t\tmalloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,\n\t\t\t\t(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);\n\t&#125;\n\n\tMALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);\n\treturn ptr;\n&#125;\n\n\n\n\n\n找到对应下方方法\n\np zone-&gt;calloc\n\n\n\nstatic void *\ndefault_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n\tzone &#x3D; runtime_default_zone();\n\t\n\treturn zone-&gt;calloc(zone, num_items, size);\n&#125;\n\n\n\nstatic void *\nnano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)\n&#123;\n\tsize_t total_bytes;\n\n\tif (calloc_get_size(num_items, size, 0, &amp;total_bytes)) &#123;\n\t\treturn NULL;\n\t&#125;\n\n\tif (total_bytes &lt;&#x3D; NANO_MAX_SIZE) &#123;\n\t\tvoid *p &#x3D; _nano_malloc_check_clear(nanozone, total_bytes, 1);\n\t\tif (p) &#123;\n\t\t\treturn p;\n\t\t&#125; else &#123;\n\t\t\t&#x2F;* FALLTHROUGH to helper zone *&#x2F;\n\t\t&#125;\n\t&#125;\n\tmalloc_zone_t *zone &#x3D; (malloc_zone_t *)(nanozone-&gt;helper_zone);\n\treturn zone-&gt;calloc(zone, 1, total_bytes);\n&#125;\n\n\n\n\nstatic void *\n_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)\n&#123;\n\tMALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, 0);\n\n\tvoid *ptr;\n\tsize_t slot_key;\n\tsize_t slot_bytes &#x3D; segregated_size_to_fit(nanozone, size, &amp;slot_key); &#x2F;&#x2F; Note slot_key is set here\n\tmag_index_t mag_index &#x3D; nano_mag_index(nanozone);\n\n\tnano_meta_admin_t pMeta &#x3D; &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);\n\n\tptr &#x3D; OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));\n\tif (ptr) &#123;\n\t\tunsigned debug_flags &#x3D; nanozone-&gt;debug_flags;\n#if NANO_FREE_DEQUEUE_DILIGENCE\n\t\tsize_t gotSize;\n\t\tnano_blk_addr_t p; &#x2F;&#x2F; the compiler holds this in a register\n\n\t\tp.addr &#x3D; (uint64_t)ptr; &#x2F;&#x2F; Begin the dissection of ptr\n\t\tif (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Invalid signature for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tif (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Mismatched magazine for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tgotSize &#x3D; _nano_vet_and_size_of_free(nanozone, ptr);\n\t\tif (0 &#x3D;&#x3D; gotSize) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Invalid pointer %p dequeued from free list\\n&quot;, ptr);\n\t\t&#125;\n\t\tif (gotSize !&#x3D; slot_bytes) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Mismatched size for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tif (!_nano_block_has_canary_value(nanozone, ptr)) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Heap corruption detected, free list canary is damaged for %p\\n&quot;\n\t\t\t\t\t&quot;*** Incorrect guard value: %lu\\n&quot;, ptr,\n\t\t\t\t\t((chained_block_t)ptr)-&gt;double_free_guard);\n\t\t&#125;\n\n#if defined(DEBUG)\n\t\tvoid *next &#x3D; (void *)(((chained_block_t)ptr)-&gt;next);\n\t\tif (next) &#123;\n\t\t\tp.addr &#x3D; (uint64_t)next; &#x2F;&#x2F; Begin the dissection of next\n\t\t\tif (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Invalid next signature for pointer %p dequeued from free &quot;\n\t\t\t\t\t\t&quot;list, next &#x3D; %p\\n&quot;, ptr, &quot;next&quot;);\n\t\t\t&#125;\n\n\t\t\tif (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Mismatched next magazine for pointer %p dequeued from &quot;\n\t\t\t\t\t\t&quot;free list, next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\n\t\t\tgotSize &#x3D; _nano_vet_and_size_of_free(nanozone, next);\n\t\t\tif (0 &#x3D;&#x3D; gotSize) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Invalid next for pointer %p dequeued from free list, &quot;\n\t\t\t\t\t\t&quot;next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\t\t\tif (gotSize !&#x3D; slot_bytes) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Mismatched next size for pointer %p dequeued from free &quot;\n\t\t\t\t\t\t&quot;list, next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\t\t&#125;\n#endif &#x2F;* DEBUG *&#x2F;\n#endif &#x2F;* NANO_FREE_DEQUEUE_DILIGENCE *&#x2F;\n\n\t\t((chained_block_t)ptr)-&gt;double_free_guard &#x3D; 0;\n\t\t((chained_block_t)ptr)-&gt;next &#x3D; NULL; &#x2F;&#x2F; clear out next pointer to protect free list\n\t&#125; else &#123;\n\t\tptr &#x3D; segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);\n\t&#125;\n\n\tif (cleared_requested &amp;&amp; ptr) &#123;\n\t\tmemset(ptr, 0, slot_bytes); &#x2F;&#x2F; TODO: Needs a memory barrier after memset to ensure zeroes land first?\n\t&#125;\n\treturn ptr;\n&#125;\n\n\n\nstatic MALLOC_INLINE size_t\nsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)\n&#123;\n\t&#x2F;&#x2F; size &#x3D; 40\n\tsize_t k, slot_bytes;\n\n\tif (0 &#x3D;&#x3D; size) &#123;\n\t\tsize &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior\n\t&#125;\n\t&#x2F;&#x2F; 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4\n\t&#x2F;&#x2F; 40 - 16*3 &#x3D; 48\n\n\t&#x2F;&#x2F;\n\t&#x2F;&#x2F; 16 字节对齐\n\tk &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta\n\tslot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;\t\t\t\t\t\t\t&#x2F;&#x2F; multiply by power of two quanta size\n\t*pKey &#x3D; k - 1;\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; Zero-based!\n\n\treturn slot_bytes;\n&#125;\n\n","slug":"Memory-alignment","date":"2021-05-03T00:55:06.000Z","categories_index":"","tags_index":"","author_index":"LittleLight"},{"id":"a519dcebcf7b75aa7909ffb897e4913c","title":"Spring基础了解","content":"Spring 简介​        Spring 是分层的 full-stack（全栈） 轻量级开源框架，以IoC和 AOP 为内核，提供了展现层Spring MVC和业务层事务管理等众多的企业级应⽤技术，还能整合开源世界众多著名的第三⽅框架和类库，已 经成为使⽤最多的Java EE企业应⽤开源框架。\nSpring Framework\n\n提供依赖注入的核心支持，事务管理，web apps 、数据访问、消息以及其他更多\n\n\n\nSpring 的优势整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀ 天，就能体会到它的⼀些优势。 \n\n**⽅便解耦，简化开发 **\n\n通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的 过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更 专注于上层的应⽤。 \n\n**AOP编程的⽀持 **\n\n通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过 AOP轻松应付。 \n\n**声明式事务的⽀持 **\n\n@Transactional 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼ 开发效率和质量。\n\n**⽅便程序的测试 **\n\n可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的 事情。 \n\n⽅便集成各种优秀框架 \n\nSpring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接⽀持。 降低JavaEE API的使⽤难度 Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤ 难度⼤为降低。\n\n**源码是经典的 Java 学习范例 **\n\nSpring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对 Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。\nSpring 的核⼼结构Spring是⼀个分层⾮常清晰并且依赖关系、职责定位⾮常明确的轻量级框架，主要包括⼏个⼤模块：数 据处理模块、Web模块、AOP（Aspect Oriented Programming）/Aspects模块、Core Container模块 和 Test 模块，如下图所示，Spring依靠这些基本模块，实现了⼀个令⼈愉悦的融合了现有解决⽅案的零 侵⼊的轻量级框架。\n\n\nSpring核⼼容器（Core Container） 容器是Spring框架最核⼼的部分，它管理着Spring应⽤中 bean的创建、配置和管理。在该模块中，包括了Spring bean⼯⼚，它为Spring提供了DI的功能。 基于bean⼯⼚，我们还会发现有多种Spring应⽤上下⽂的实现。所有的Spring模块都构建于核⼼ 容器之上。 \n⾯向切⾯编程（AOP）/Aspects Spring对⾯向切⾯编程提供了丰富的⽀持。这个模块是Spring应 ⽤系统中开发切⾯的基础，与DI⼀样，AOP可以帮助应⽤对象解耦。\n数据访问与集成（Data Access/Integration）\nSpring的JDBC和DAO模块封装了⼤量样板代码，这样可以使得数据库代码变得简洁，也可以更专 注于我们的业务，还可以避免数据库资源释放失败⽽引起的问题。 另外，Spring AOP为数据访问 提供了事务管理服务，同时Spring还对ORM进⾏了集成，如Hibernate、MyBatis等。该模块由 JDBC、Transactions、ORM、OXM 和 JMS 等模块组成。\nWeb 该模块提供了SpringMVC框架给Web应⽤，还提供了多种构建和其它应⽤交互的远程调⽤⽅ 案。 SpringMVC框架在Web层提升了应⽤的松耦合⽔平。\nTest 为了使得开发者能够很⽅便的进⾏测试，Spring提供了测试模块以致⼒于Spring应⽤的测 试。 通过该模块，Spring为使⽤Servlet、JNDI等编写单元测试提供了⼀系列的mock对象实现\n核⼼思想1.1 什么是IoC？IoC Inversion of Control (控制反转/反转控制)，注意它是⼀个技术思想，不是⼀个技术实现 描述的事情：Java开发领域对象的创建，管理的问题 传统开发⽅式：⽐如类A依赖于类B，往往会在类A中new⼀个B的对象\nIoC思想下开发⽅式：我们不⽤⾃⼰去new对象了，⽽是由IoC容器（Spring框架）去帮助我们实例化对 象并且管理它，我们需要使⽤哪个对象，去问IoC容器要即可 我们丧失了⼀个权利（创建、管理对象的权利）,得到了⼀个福利（不⽤考虑对象的创建、管理等⼀系列 事情）\n为什么叫做控制反转？ 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器)\n没有IoC容器\n\n\n使用IoC容器\n\n\nIoC 解决什么问题\n主要解决对象之间的耦合问题\n\n IoC和DI的区别 DI：\n\n Dependancy Injection（依赖注⼊）  IOC和DI描述的是同⼀件事情，只不过⻆度不⼀样罢了\n\n\nIOC 和 DI 描述的是同一件事情，对象实例化以及依赖关系的维护这件事情，只不过角度不同\nIOC是从对象的角度，对象实例化以及管理权交给IoC容器\nDI是在容器角度，容器会把对象依赖其他对象注入（送进去）比如A对象实例化过程因为声明啦一个B类型的属性，那么就要把对象B注入到A中\n\nAOP什么是AOP AOP\n Aspect oriented Programming ⾯向切⾯编程/⾯向⽅⾯编程 AOP是OOP的延续，从OOP说起\n\nOOP三⼤特征\n 封装、继承和多态 oop是⼀种垂直继承体系\n\nOOP编程思想可以解决⼤多数的代码重复问题，但是有⼀些情况是处理不了的，⽐如下⾯的在顶级⽗类 Animal中的多个⽅法中相同位置出现了重复代码，OOP就解决不了\n","slug":"Spring-base","date":"2021-05-02T06:22:41.000Z","categories_index":"","tags_index":"","author_index":"LittleLight"},{"id":"83f1863d7d241c1d5ddb943bddf231fd","title":"动态SQL","content":"动态sql语句**动态sql语句概述 **\n\n Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动 态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n\n","slug":"dynamicSQL","date":"2021-05-01T23:43:13.000Z","categories_index":"","tags_index":"","author_index":"LittleLight"},{"id":"20c5d0afd79142c4ce377e5e3d6eadea","title":"alloc&init探究","content":"alloc 和 init 基本原理LGPerson *p &#x3D; [[LGPerson alloc] init];\n LGPerson *p1 &#x3D; [p init];\n &#x2F;&#x2F; objc_msgSend （id 消息接收者，sel 发送消息）\n LGPerson *p2 &#x3D; [p init];\n NSLog(@&quot;输出将结果如下： %p-%p-%p&quot;, p, p1, p2);\n NSLog(@&quot;end&quot;); &#x2F;&#x2F;\n\n1. 探究问题\nalloc 探究\nalloc 已经创建了对象init\nalloc 怎么实现创建\nalloc 实现- 原理-源码实现\n\n2. 探究方式\nlibobjc.A.dylib\n\n下断点： control + in - objc_alloc\n\n下符号断点：libobjc.A.dylib`+[NSObjject alloc]\n\n通过汇编方式libobjc.A.dylib\nDebug -&gt; Debug workflow -&gt; Always Show Disassembly\n\n\n![](截屏2021-05-01 下午6.01.02.png)\n\n\n注意：\n使用真机调试\n\nlibobjc.A.dylib 库关于 objc_alloc: \n\nalloc 方法实现\n首先申请内存空间，给指针地址\nregister read x0 方法读取寄存器的值\nx0 即是返回对象的地址，以及存储数据的地方\n\nalloc 实现源码执行的过程\n调用alloc方法\n\n+ (id)alloc &#123;\n  return _objc_rootAlloc(self);\n&#125;\n\n\n调用_objc_rootAlloc(Class cls) 方法\n\n_objc_rootAlloc(Class cls)\n&#123;\n    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);\n&#125;\n\n\nstatic ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) \n\nstatic ALWAYS_INLINE id\ncallAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)\n&#123;\n    if (slowpath(checkNil &amp;&amp; !cls)) return nil;\n\n#if __OBJC2__\n    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;\n        &#x2F;&#x2F; No alloc&#x2F;allocWithZone implementation. Go straight to the allocator.\n        &#x2F;&#x2F; fixme store hasCustomAWZ in the non-meta class and \n        &#x2F;&#x2F; add it to canAllocFast&#39;s summary\n        if (fastpath(cls-&gt;canAllocFast())) &#123;\n            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.\n            bool dtor &#x3D; cls-&gt;hasCxxDtor();\n            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            obj-&gt;initInstanceIsa(cls, dtor);\n            return obj;\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.\n            id obj &#x3D; class_createInstance(cls, 0);\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            return obj;\n        &#125;\n    &#125;\n#endif\n\n    &#x2F;&#x2F; No shortcuts available.\n    if (allocWithZone) return [cls allocWithZone:nil];\n    return [cls alloc];\n&#125;\n\n\n通过class_createInstance创建类的实例\n\nid \nclass_createInstance(Class cls, size_t extraBytes)\n&#123;\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n&#125;\n\n\nstatic __attribute__((always_inline))  id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil) 方法\n\nstatic __attribute__((always_inline)) \nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct &#x3D; true, \n                              size_t *outAllocatedSize &#x3D; nil)\n&#123;\n    if (!cls) return nil;\n\n    assert(cls-&gt;isRealized());\n\n    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance\n    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();\n    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();\n    bool fast &#x3D; cls-&gt;canAllocNonpointer();\n\n    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize &#x3D; size;\n\n    id obj;\n    if (!zone  &amp;&amp;  fast) &#123;\n      \t&#x2F;&#x2F; 分配内存空间的方法\n        obj &#x3D; (id)calloc(1, size);\n        if (!obj) return nil;\n        &#x2F;&#x2F; 关联内存空间\n        &#x2F;&#x2F; obj 指向实例对象\n        obj-&gt;initInstanceIsa(cls, hasCxxDtor);\n    &#125; \n    else &#123;\n        if (zone) &#123;\n          &#x2F;&#x2F;  分配内存空间\n            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);\n        &#125; else &#123;\n          &#x2F;&#x2F; 分配内存空间\n            obj &#x3D; (id)calloc(1, size);\n        &#125;\n        if (!obj) return nil;\n\n        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be \n        &#x2F;&#x2F; doing something weird with the zone or RR.\n        obj-&gt;initIsa(cls);\n    &#125;\n\n    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;\n        obj &#x3D; _objc_constructOrFree(obj, cls);\n    &#125;\n\n    return obj;\n&#125;\n\n\n\n\n\n读取寄存器方法register read\n\n\n\n\n\n内存对齐size_t instanceSize(size_t extraBytes) &#123;\n        size_t size &#x3D; alignedInstanceSize() + extraBytes;\n        &#x2F;&#x2F; CF requires all objects be at least 16 bytes.\n        if (size &lt; 16) size &#x3D; 16;\n        return size;\n&#125;\n\n内存对齐\nuint32_t alignedInstanceSize() &#123;\n        return word_align(unalignedInstanceSize());\n    &#125;\n\n内存查看地址\n通过下面LLDB命令读取内从地址\n\nx p (倒着读取相应的数据)\n\n\n\nx&#x2F;4xg p （4xg 可以 5xg 6xg）\n\n","slug":"alloc","date":"2021-05-01T09:45:39.000Z","categories_index":"","tags_index":"","author_index":"LittleLight"},{"id":"9d874e909a3a7a396d1451469b922294","title":"Mybatis对象关系映射","content":"对象/关系数据库映射(ORM)\nORM全称Object/Relation Mapping:表示对象-关系映射的缩写\n\nORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向 对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对 象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架 后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这 些面向对象的操作转换成底层SQL操作。ORM框架实现的效果:把对持久化对象的保存、修改、删除 等操作，转换为对数据库的操作\nMybatis简介MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映 射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML或注解来配置和映射原生类型、接口和Java的POJO (Plain Old Java Objects,普通老式Java对 象) 为数据库中的记录。\nMybatis优势Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n        &lt;transactionManager type=\"JDBC\"/>\n    &lt;!--Mybatis使用的连接池-->\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"password\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;!--引入映射文件件-->\n    &lt;mappers>\n        &lt;mapper resource=\"UserMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n\n配置文件解析其中，事务管理器(transactionManager)类型有两种:\n\nJDBC:这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作\n\n用域。\n\nMANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生 命周期(比如 JEE 应用服务器的上下文)。 默认情况下它会关闭连接，然而一些容器并不希望这样，因 此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。\n\n其中，数据源(dataSource)类型有三种:\n\n**UNPOOLED:**这个数据源的实现只是每次被请求时打开和关闭连接。\n\n**POOLED:**这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。\n\n**JNDI:**这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置 数据源，然后放置一个 JNDI 上下文的引用。\n\n\n@Test\n    public void demoTest() throws IOException &#123;\n\n        //加载核心配置文件\n        InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //获得sqlSession工厂对象\n        // 见解析配置文件，并创建建sqlSessionFactory 工厂\n        SqlSessionFactory sqlSessionFactory = new\n                SqlSessionFactoryBuilder().build(resourceAsStream);\n            //获得sqlSession对象，默认开启一个事务，但是不会自动提交事务，需要shou\n        SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句\n        List&lt;User> userList = sqlSession.selectList(\"userMapper.findAll\"); //打印结果\n        System.out.println(userList);\n        // sqlSession.insert(\"userMapper.saveUser\");\n//释放资源\n        sqlSession.close();\n    &#125;\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"userMapper\">\n    &lt;select id=\"findAll\" resultType=\"com.lagou.pojo.User\">\n    select * from User\n  &lt;/select>\n\n    &lt;insert id=\"saveUser\" parameterType=\"com.lagou.pojo.User\">\n        insert into user values(#&#123;id&#125;,#&#123;username&#125;)\n    &lt;/insert>\n\n    &lt;update id=\"updateUser\" parameterType=\"com.lagou.pojo.User\">\n        update user set username = #&#123;username&#125; where id = #&#123;id&#125;\n    &lt;/update>\n&lt;!--删除操作，都是随便写的-->\n    &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #&#123;id&#125;\n    &lt;/delete>\n\n&lt;/mapper>\n\n\n\nSqlSession会话对象\n SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和 获取映射器实例的方法。 执行语句的方法主要有：\n\n主要使用方法\n&lt;T> T selectOne(String statement, Object parameter)\n&lt;E> List&lt;E> selectList(String statement, Object parameter)\nint insert(String statement, Object parameter)\nint update(String statement, Object parameter)\nint delete(String statement, Object parameter)\n\n操作事务的方法\nvoid commit()\nvoid rollback()\n\n\n\n代理开发模式 代理开发方式介绍 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 \nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口 定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\nMapper 接口开发需要遵循以下规范：**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 **\n**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 **\n**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 **\n4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n","slug":"Mybatis对象关系映射","date":"2021-04-29T12:12:40.000Z","categories_index":"","tags_index":"Mybatis","author_index":"LittleLight"},{"id":"8d5bb184f1a8d1302f056982173a3dd0","title":"如何Category中增加属性","content":"如何在Category中增加属性（关联对象）在实际开发中，如果为Category添加一个属性，那么系统将不会为这个属性设置访问器方法，也就是setter和getter方法。这时候可以使用runtime提供的关联对象方法，动态地为该属性实现访问器方法。\n开发者可以将关联对象想象成一个Objective-C对象，这个对象通过一个预先设置好的key连接到类的一个实例上。runtime提供了如下方法让一个对象连接到其他对象。\nvoid objc_setAssociatedObject(id  _Nonnull NSObject, const void * _Nonnull key_, id  _Nullable value, objc_AssociationPolicy policy)\n\n参数object是将要被关联的对象。参数key是一个void指针。\n参数value是关联对象，它是id类型。\n参数policy是指定一个内存管理策略来处理关联对象如下：\n指定的策略 \n\nOBJC_ASSOCIATION_ASSIGN，那么被关联对象释放时，关联对象不会被释放，\n\n\nOBJC_ASSOCIATION_RETAIN或OBJC_ASSOCIATION_COPY，那么关联对象就会被释放。\n\nOBJC_ASSOCIATION_RETAIN_NONATOMIC和OBJC_ASSOCIATION_COPY_NONATOMIC两种策略，当需要在多个线程中处理访问关联对象的多线程代码时，就会变得非常有用。\n\n\nruntime还提供了移除关联对象的方法：\nobjc_removeAssociatedObjects(id  _Nonnull object)\n\n\n可以使用这个方法移除所有和参数object关联的对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。\n例子：\n给Person类别添加一个属性 address\n#import &quot;Person.h&quot;\n#import &lt;objc&#x2F;runtime.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface Person (Cate)\n\n@property (nonatomic, strong) NSString *address;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n\nPerson+Cate.m 文件\n#import &quot;Person+Cate.h&quot;\n\n@implementation Person (Cate)\n\n- (id)address &#123;\n    id value &#x3D; objc_getAssociatedObject(self, &quot;address&quot;);\n    return value;\n&#125;\n\n- (void)setAddress:(NSString *)address &#123;\n    objc_setAssociatedObject(self, &quot;address&quot;, address, OBJC_ASSOCIATION_RETAIN);\n&#125;\n\n@end\n\n\n结果说明已经成功地在Category中为类添加了一个新的属性，并且能够正常地使用这个属性。事实上，关联对象是使用哈希表实现的，将一个类映射到一张哈希表上，然后根据key找到关联对象，所以严格来说，关联对象和被关联对象没有任何关系，它不是存储在对象的内部。\n","slug":"如何Category中增加属性","date":"2021-04-29T11:17:24.000Z","categories_index":"","tags_index":"","author_index":"LittleLight"},{"id":"afb2b07e802409f4fec5da7128301e15","title":"如何提高面试率.md","content":"\n“成功者讲方法，失败者讲理由！”虽然是一句老掉牙的话，但却饱含人生哲理。面对越来越激烈的竞争局面，以及后续大批新人的涌入，我们不仅要埋头苦干，提升自己的专业技能，更需要学会一些面试技巧，因为这些技巧会让你的求职之路事半功倍，为你赢得更多可能性。\n我的这些面试技巧分为，面试前准备、面试中展现，以及面试后复盘这三部分，有了这些技巧再加上你的专业技能，相信一定可以“披荆斩棘”斩获更多的 Offer，为自己的未来赢得更多可能。\n首先，是面试前准备凡事预则立不预则废，在正式“打仗”之前，我们一定要仔细研究“对手”，对于面试也是这样，只有预先准备才有可能获得成功，面试前或者是投简历前我们要先研究两个问题，第一，这个公司的主营业务是什么？第二，这个公司使用的技术栈是什么？研究了公司的主营业务后，你自然就会知道在简历中应体现哪些重点内容了。比如这家公司是做电商的，你之前既做过教育，又做过电商，也做过医疗，那么你应该重点将电商的项目经验和从业经历体现在简历上，这样你获得面试的概率和成功的概率就会大很多，毕竟公司都希望招聘到“更合适”的人。这里并不是鼓励你造假，只是提醒你可以从众多项目中，提取并展示和这个公司业务相匹配的项目。\n研究公司的技术栈也是同样的道理，技术经理也希望招来的人能直接上手，所以在写简历时或者面试时就可以重点向目标公司的技术栈靠拢。但有一点要特别注意，你说的这些技术点也是应聘单位擅长的技术栈，如果你真的懂，可以引导面试官往这个技术点上靠拢。但如果你对这些技术不是很擅长，切记千万不要这么做，这样只会适得其反，所以你应在简历和面试中重点突出你擅长的技术栈，并尽量向应聘公司的技术栈靠拢。除以上内容外，你还要准备一些常见的面试问题，比如你是如何看待加班的？你可以这样回答：你个人不认同无效加班，更倾向于以事情为导向，高效地处理完成工作，但如果公司赶项目或者有偶尔有加班的情况，自己也并不排斥，愿意跟着公司步伐走。又比如面试结尾，你还有什么问题要问我吗？等等类似的问题，都需要提前准备一下。\n在写简历时，还需要注意以下几点：• 第一，扬长避短，将优势点放在核心位置。比如你是大专文凭，那么就应该把教育背景写在简历的最下方也就是最不起眼的地方，而在最重要的位置优先展示自己的特长信息；• 第二，信息清晰，写清必要的内容。比如你要应聘的岗位以及期望薪资，而不是“面议”，因为有些 HR 看到信息模糊的简历会将其直接将其丢弃，因为她不确认你的能力和你期望的薪资是否匹配，如果应聘者很多的情况下，应聘单位就没必要“冒险”给一个不确定的人面试的机会了；• 第三，准确地描述项目经验。项目经验一般 3 个左右即可，需要描述的内容大致有：这个项目是什么？你负责什么模块？项目中使用了什么技术栈？项目的上线地址是什么？项目中有没有遇到什么问题？你是如何解决？等等内容。面试中展现在面试中你首先应该展示的是你的专业技术技能，让面试官充分了解你对某项技术的掌握情况，你可以深入讲解某个项目中的细节技术处理方案，或者通过一个深入的技术点展示你对这项技术的熟练掌握程度。如果你是学生的话，可以用成果证明，比如你的竞赛成绩或者获奖证书等。除了专业技能外，你还应在面试中展示你良好的沟通能力和理解能力，通过你的言行举止和沟通交流的内容，面试官便能对此有所察觉和判断，你需要注意的就是不要有抵抗或者是消极的情绪，正常发挥就行。面试中另一个需要注意的点就是要尽量展现你坦诚的一面。不会的知识点，回答不会就好，不要滥竽充数，也不要顾左右而言他，因为面试官一般都不傻，并且在面试的过程中，有不会的知识点和面试题也很正常，每个人不可能知道所有的答案，坦诚回答就好。\n另一个是和你的专业技能同样重要，在面试中你应该尽量展现你对技术的热爱，因为只有热爱的东西你才可能把它做好，它决定了你以后技术发展的速度和深度，因此面试官对此会特别在意，能展现你对技术的热爱的点有以下几个：• 写技术博客• 创作技术视频，比如在 B 站分享你的技术视频• 在 GitHub 上有参与开源项目或者自己的开源项目• 有自己的个人博客或者是其他个人工具网站• 出书或者是技术专栏\n以上这些方面，都是你对技术热爱的一些具体体现。最后在面试中你也要尽量展现你的求知欲，比如爱好看书、参加技术沙龙等，这些都能体现你对技术的孜孜追求，有追求的人进步一般都很快，因此也更受用人企业的欣赏和认同。\n","slug":"如何提高面试率","date":"2021-04-24T02:06:35.000Z","categories_index":"","tags_index":"iOS","author_index":"LittleLight"}]