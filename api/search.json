[{"id":"39ade3484174d56b659a76daf70210b1","title":"Flutter的Function函数对象","content":"Function 函数对象\n\n\n\n\n\n\n\n\n在 Dart 中一切都是对象，函数也不例外，函数可以作为一个参数传递。其中 Function 类是代表所有函数的公共顶层接口抽象类。Function 类中并没有声明任何实例方法。但是它有一个非常重要的静态类函数 apply。\n\n\n\n\n\n\n\n\n\n该函数接收一个 Function 对象 function，一个 List 的参数 positionalArguments，以及一个可选参数  Map&lt;Symbol, dynamic&gt;  类型的 namedArguments。\n为什么 Dart 中函数支持位置参数和命名参数吗？没错就是它们两个参数功劳。实际上，apply() 函数提供一种使用动态确定的参数列表来调用函数的机制，通过它我们就能处理在编译时参数列表不确定的情况。\nabstract class Function &#123;\n  external static apply(Function function, List positionalArguments,\n      [Map&lt;Symbol, dynamic> namedArguments]);//可以看到这是 external 声明，我们需要找到对应的 function_patch.dart 实现\n  int get hashCode;\n  bool operator ==(Object other);\n&#125;\n\nFunction 中源码实现实现基本原理\n\n计算外部参数位置参数个数\n\n计算外部参数命名参数的个数\n\n计算所有外部参数个数 = 外部位置参数 + 外部命名参数\n\n创建一个订场为所有参数个数的List 集合 arguments \n\n集合第一个参数是传入的function 对象\n\n然后从1 位置开始插入所有的位置参数到 arguments 参数列表中\n\n然后再创建一个为定长的命名参数长度 List 集合\n\n遍历命名参数Map列表\n\n\nclass Function &#123;\n  // TODO(regis): Pass type arguments to generic functions. Wait for API spec.\n  //可以看到内部私有的 _apply 函数，最终接收两个 List 原生类型的参数 arguments、names 分别代表着我们使用函数时\n  //定义的所有参数 List 集合 arguments（包括位置参数和命名参数）以及命名参数名 List 集合 names，不过它是委托到 native 层的 Function_apply C++ 函数实现的。\n  static _apply(List arguments, List names) native \"Function_apply\";\n\n  @patch\n  static apply(Function function, List positionalArguments,\n      [Map&lt;Symbol, dynamic> namedArguments]) &#123;\n    //计算外部函数位置参数的个数  \n    int numPositionalArguments = 1 + // 默认同时会传入 function 参数，所以默认 +1\n        (positionalArguments != null ? positionalArguments.length : 0);//位置参数的集合不为空就返回集合长度否则返回 0\n    //计算外部函数命名参数的个数    \n    int numNamedArguments = namedArguments != null ? namedArguments.length : 0;;//命名参数的集合不为空就返回集合长度否则返回 0\n    //计算所有参数个数总和: 位置参数个数 + 命名参数个数\n    int numArguments = numPositionalArguments + numNamedArguments;\n    //创建一个定长为所有参数个数大小的 List 集合 arguments\n    List arguments = new List(numArguments);\n    //集合第一个元素默认是传入的 function 对象\n    arguments[0] = function;\n    //然后从 1 的位置开始插入所有的位置参数到 arguments 参数列表中\n    arguments.setRange(1, numPositionalArguments, positionalArguments);\n    //然后再创建一个定长为命名参数长度的 List 集合\n    List names = new List(numNamedArguments);\n    int argumentIndex = numPositionalArguments;\n    int nameIndex = 0;\n    //遍历命名参数 Map 集合\n    if (numNamedArguments > 0) &#123;\n      namedArguments.forEach((name, value) &#123;\n        arguments[argumentIndex++] = value;//把命名参数对象继续插入到 arguments 集合中\n        names[nameIndex++] = internal.Symbol.getName(name);//并把对应的参数名标识存入 names 集合中\n      &#125;);\n    &#125;\n    return _apply(arguments, names);//最后调用_apply 函数传入所有参数对象集合以及命名参数名称集合\n  &#125;\n&#125;\n","slug":"Flutter的Function函数对象","date":"2021-12-17T01:07:57.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"ef5aa7e92bb61e597e24d0ade2427469","title":"Flutter参数","content":"","slug":"Flutter参数","date":"2021-12-17T01:01:05.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"92ebd029be42f71fd12661e2724b68c4","title":"Runtime总结","content":"","slug":"Runtime总结","date":"2021-12-09T08:41:58.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"1e44f5b3bd24c99dd3f8c314188c1ad6","title":"Dart函数","content":"","slug":"Dart函数","date":"2021-12-08T07:42:51.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"a18a0021d0e3774e23afd0f4a2e611d8","title":"Dart运算符","content":"Dart 基础语法（运算符）本篇文章上接初探 Dart 语法上篇，主要涉及一些 Dart 中的运算符、异常、函数、面向对象等。\n1. 运算符1.1 算术运算符\n\n\n名称\n运算符\n例子\n\n\n\n加\n+\nvar result = 1 + 1;\n\n\n减\n-\nvar result = 5 - 1;\n\n\n乘\n*\nvar result = 3 * 5;\n\n\n除\n/\nvar result = 3 / 5; //0.6\n\n\n整除\n~/\nvar result = 3 ~/ 5; //0\n\n\n取余\n%\nvar result = 5 % 3; //2\n\n\n1.2 条件运算符\n\n\n名称\n运算符\n例子\n\n\n\n大于\n&gt;\n2 &gt; 1\n\n\n小于\n&lt;\n1 &lt; 2\n\n\n等于\n==\n1 == 1\n\n\n不等于\n!=\n3 != 4\n\n\n大于等于\n&gt;=\n5 &gt;= 4\n\n\n小于等于\n&lt;=\n4 &lt;= 5\n\n\n1.3 逻辑运算符\n\n\n名称\n运算符\n例子\n\n\n\n或\n\n\n\n\n与\n&amp;&amp;\n2 &gt; 1 &amp;&amp; 3 &lt; 1\n\n\n非\n！\n!(2 &gt; 1)\n\n\n1.4 位运算符\n\n\n名称\n运算符\n\n\n\n位与\n&amp;\n\n\n位或\n\n\n\n位非\n~\n\n\n异或\n^\n\n\n左移\n&lt;&lt;\n\n\n右移\n&gt;&gt;\n\n\n1.5 三目运算符condition ? expr1 : expr2\nvar isOpened = (value == 1) ? true : false;\n\n1.6 空安全运算符\n\n\n操作符\n解释\n\n\n\nresult = expr1 ?? expr2\n若 expr1 为 null，返回 expr2 的值，否则返回 expr1 的值\n\n\nexpr1 ??= expr2\n若 expr1 为 null，则把 expr2 的值赋值给 expr1\n\n\nresult = expr1?.value\n若 expr1 为 null，就返回 null，否则就返回 expr1.value 的值\n\n\nresult = expr1 ?? expr2\n如果发现 expr1 为 null，就返回 expr2 的值，否则就返回 expr1 的值\nmain() &#123;\n    var choice = question.choice ?? 'A';\n    //等价于\n    var choice2;\n    if(question.choice == null) &#123;\n        choice2 = 'A';\n    &#125; else &#123;\n        choice2 = question.choice;\n    &#125;\n&#125;\n\nexpr1 ??= expr2\n等价于  expr1 = expr1 ?? expr2（转化成第一种）。\nmain() &#123;\n    var choice ??= 'A';\n    //等价于\n    if(choice == null) &#123;\n        choice = 'A';\n    &#125;\n&#125;\n\nresult = expr1?.value\n如果 expr1 不为 null 就返回 expr1.value，否则就会返回 null，类似 Kotlin 中的  ?.。如果 expr1 不为 null，就执行后者。\nvar choice = question?.choice;\n//等价于\nif(question == null)&#123;\n    return null;\n&#125; else &#123;\n    return question.choice;\n&#125;\n\nquestion?.commit();\n//等价于\nif(question == null)&#123;\n    return;//不执行 commit()\n&#125; else &#123;\n    question.commit();//执行 commit 方法    \n&#125;\n\n1.7 级联操作符（..）级联操作符是  ..，可以让你对一个对象中字段进行链式调用操作\nquestion\n    ..id = '10001'\n    ..stem = '第一题: xxxxxx'\n    ..choices = &lt;String> ['A','B','C','D']\n    ..hint = '听音频做题';\n\n1.8 运算符重载在 Dart 支持运算符自定义重载，使用operator关键字定义重载函数。\nclass Vip &#123;\n  final int level;\n  final int score;\n\n  const Vip(this.level, this.score);\n\n  bool operator &gt;(Vip other) &#x3D;&gt;\n      level &gt; other.level || (level &#x3D;&#x3D; other.level &amp;&amp; score &gt; other.score);\n\n  bool operator &lt;(Vip other) &#x3D;&gt;\n      level &lt; other.level || (level &#x3D;&#x3D; other.level &amp;&amp; score &lt; other.score);\n\n  bool operator &#x3D;&#x3D;(Vip other) &#x3D;&gt;\n      level &#x3D;&#x3D; other.level &amp;&amp;\n      score &#x3D;&#x3D; other.level; &#x2F;&#x2F;注意：这段代码可能在高版本的 Dart 中会报错，在低版本是 OK 的\n  &#x2F;&#x2F;上述代码，在高版本 Dart 中，Object 中已经重载了 &#x3D;&#x3D;，所以需要加上 covariant 关键字重写这个重载函数。\n  @override\n  bool operator &#x3D;&#x3D;(covariant Vip other) &#x3D;&gt;\n      (level &#x3D;&#x3D; other.level &amp;&amp; score &#x3D;&#x3D; other.score);\n\n  @override\n  int get hashCode &#x3D;&gt; super.hashCode; &#x2F;&#x2F;伴随着你还需要重写 hashCode，至于什么原因大家应该都知道\n&#125;\n\n\nmain() &#123;\n    var userVip1 &#x3D; Vip(4, 3500);\n    var userVip2 &#x3D; Vip(4, 1200);\n    if(userVip1 &gt; userVip2) &#123;\n        print(&#39;userVip1 is super vip&#39;);\n    &#125; else if(userVip1 &lt; userVip2) &#123;\n        print(&#39;userVip2 is super vip&#39;);\n    &#125;\n&#125;\n\n2. 异常Dart 中的异常捕获方法和 Java、Kotlin 类似，使用的也是 try-catch-finally；对特定异常的捕获使用 on 关键字。\nDart 中的常见异常有：NoSuchMethodError（当在一个对象上调用一个该对象没有 实现的函数会抛出该错误）、ArgumentError（调用函数的参数不合法会抛出这个错误）。\nmain() &#123;\n  int num &#x3D; 18;\n  int result &#x3D; 0;\n  try &#123;\n    result &#x3D; num ~&#x2F; 0;\n  &#125; catch (e) &#123;&#x2F;&#x2F;捕获到 IntegerDivisionByZeroException\n    print(e.toString());\n  &#125; finally &#123;\n    print(&#39;$result&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F;使用 on 关键字捕获特定的异常\nmain() &#123;\n  int num &#x3D; 18;\n  int result &#x3D; 0;\n  try &#123;\n    result &#x3D; num ~&#x2F; 0;\n  &#125; on IntegerDivisionByZeroException catch (e) &#123;&#x2F;&#x2F;捕获特定异常\n    print(e.toString());\n  &#125; finally &#123;\n    print(&#39;$result&#39;);\n  &#125;\n&#125;\n\n3. 函数在 Dart 中函数的地位一点都不亚于对象，支持闭包和高阶函数，而且 Dart 中的函数也会比 Java 要灵活的多，而且 Kotlin 中的一些函数特性，它也支持甚至比 Kotlin 支持得更全面。比如支持默认值参数、可选参数、命名参数等。\n3.1 函数的基本用法main() &#123;\n    print(&#39;sum is $&#123;sum(2, 5)&#125;&#39;);\n&#125;\n\nnum sum(num a, num b) &#123;\n    return a + b;\n&#125;\n\n3.2 函数参数列表传参规则&#x2F;&#x2F;num a, num b, num c, num d 最普通的传参：调用时，参数个数和参数顺序必须固定\nadd1(num a, num b, num c, num d) &#123;\n  print(a + b + c + d);\n&#125;\n\n&#x2F;&#x2F;[num a, num b, num c, num d]传参：调用时，参数个数不固定，但是参数顺序需要一一对应，不支持命名参数\nadd2([num a, num b, num c, num d]) &#123;\n  print(a + b + c + d);\n&#125;\n\n&#x2F;&#x2F;&#123;num a, num b, num c, num d&#125;传参：调用时，参数个数不固定，参数顺序也可以不固定，支持命名参数，也叫可选参数，是 Dart 中的一大特性，这就是为啥 Flutter 代码那么多可选属性，大量使用可选参数\nadd3(&#123;num a, num b, num c, num d&#125;) &#123;\n  print(a + b + c + d);\n&#125;\n\n&#x2F;&#x2F;num a, num b, &#123;num c, num d&#125;传参：调用时，a、b 参数个数固定顺序固定，c、d 参数个数和顺序也可以不固定\nadd4(num a, num b, &#123;num c, num d&#125;) &#123;\n  print(a + b + c + d);\n&#125;\n\nmain() &#123;\n  add1(100, 100, 100, 100); &#x2F;&#x2F;最普通的传参：调用时，参数个数和参数顺序必须固定\n  add2(100, 100); &#x2F;&#x2F;调用时，参数个数不固定，但是参数顺序需要一一对应，不支持命名参数（也就意味着顺序不变）\n  add3(\n      b: 200,\n      a: 200,\n      c: 100,\n      d: 100); &#x2F;&#x2F;调用时，参数个数不固定，参数顺序也可以不固定，支持命名参数（也就意味着顺序可变）\n  add4(100, 100, d: 100, c: 100); &#x2F;&#x2F;调用时，a、b 参数个数固定顺序笃定，c、d 参数个数和顺序也可以不固定\n&#125;\n\n3.3 函数默认参数和可选参数（以及与 Kotlin 对比）Dart 中函数的默认值参数和可选参数和 Kotlin 中默认值参数和命名参数一致，只是写法上不同而已。\nadd3(&#123;num a, num b, num c, num d &#x3D; 100&#125;) &#123;&#x2F;&#x2F;d 就是默认值参数，给的默认值是 100\n   print(a + b + c + d);\n&#125;\n\nmain() &#123;\n    add3(b: 200, a: 100, c: 800);\n&#125;\n\n与 Kotlin 对比：\nfun add3(a: Int, b: Int, c: Int, d: Int = 100) &#123;\n    println(a + b + c + d)\n&#125;\n\nfun main(args: Array&lt;String>) &#123;\n    add3(b = 200, a = 100, c = 800)\n&#125;\n\n3.4 函数类型与高阶函数在 Dart 函数也是一种类型 Function，可以作为函数参数传递，也可以作为返回值。类似 Kotlin 中的 FunctionN 系列函数。\nmain() &#123;\n  Function square &#x3D; (a) &#123;\n    return a * a;\n  &#125;;\n\n  Function square2 &#x3D; (a) &#123;\n    return a * a * a;\n  &#125;;\n\n  add(3, 4, square, square2)\n&#125;\n\nnum add(num a, num b, [Function op, Function op2]) &#123;\n  &#x2F;&#x2F;函数作为参数传递\n  return op(a) + op2(b);\n&#125;\n\n3.5 函数的简化以及箭头函数在 Dart 中的如果在函数体内只有一个表达式，那么就可以使用箭头函数来简化代码，这点也和 Kotlin 类似，只不过在 Kotlin 中人家叫 lambda 表达式，只是写法上不一样而已。\nadd4(num a, num b, &#123;num c, num d&#125;) &#123;\n  print(a + b + c + d);\n&#125;\n\nadd5(num a, num b, &#123;num c, num d&#125;)  &#x3D;&gt;  print(a + b + c + d);\n\n4. 面向对象在 Dart 中一切皆是对象，所以面向对象在 Dart 中依然举足轻重，下面就先通过一个简单的例子认识下 Dart 的面向对象，后续会继续深入。\n4.1 类的基本定义和使用abstract class Person &#123;\n    String name;\n    int age;\n    double height;\n    Person(this.name, this.age, this.height);&#x2F;&#x2F;注意，这里写法可能大家没见过， 这点和 Java 是不一样，这里实际上是一个 Dart 的语法糖。但是这里不如 Kotlin，Kotlin 是直接把 this.name 传值的过程都省了。\n    &#x2F;&#x2F;与上述的等价代码，当然这也是 Java 中必须要写的代码\n    Person(String name, int age, double height) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n        this.height &#x3D; height;\n    &#125;   \n    &#x2F;&#x2F;然而 Kotlin 很彻底只需要声明属性就行，下面是 Kotlin 实现代码\n    abstract class Person(val name: String, val age: Int, val height: Double)     \n&#125;\n\nclass Student extends Person &#123;&#x2F;&#x2F;和 Java 一样同时使用 extends 关键字表示继承\n    Student(String name, int age, double height, double grade): super(name, age, height);&#x2F;&#x2F;在 Dart 里：类名(变量,变量,...) 是构造函数的写法，:super() 表示该构造调用父类，这里构造时传入三个参数\n&#125;\n\n4.2 类中属性的 getter 和 setter 访问器（类似 Kotlin）abstract class Person &#123;\n  String _name; &#x2F;&#x2F;&#x2F;&#x2F;相当于 kotlin 中的 var 修饰的变量有 setter、getter 访问器，在 Dart 中没有访问权限, 默认_下划线开头变量表示私有权限，外部文件无法访问\n  final int _age;&#x2F;&#x2F;相当于 kotlin 中的 val 修饰的变量只有 getter 访问器\n  Person(this._name, this._age); &#x2F;&#x2F;这是上述简写形式\n\n  &#x2F;&#x2F;使用 set 关键字 计算属性 自定义 setter 访问器\n  set name(String name) &#x3D;&gt; _name &#x3D; name;\n  &#x2F;&#x2F;使用 get 关键字 计算属性 自定义 getter 访问器\n  bool get isStudent &#x3D;&gt; _age &gt; 18;\n&#125;\n\n","slug":"Dart运算符","date":"2021-12-08T07:14:50.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"b31cd86eb2d45436159ffec7e16dc297","title":"Dart基础语法总结","content":"Dart 基本输出操作void main() &#123;\n  print('Hello World!');//注意：Dart 和 Java 一样表达式以分号结尾，写习惯 Kotlin 的小伙伴需要注意了，这可能是你从 Kotlin 转 Dart 最大不适之一。\n&#125;\n\n//Dart 中所有函数的类型都是可以省略的，省略的时候返回值类型为 dynamic\nmain() &#123;\n  print('Hello World!');  \n&#125;\n\n//如果函数内部只有一个表达式，可以省略大括号，使用\"=>\"箭头函数；\n//而对于 Kotlin 则是如果只有一个表达式，可以省略大括号，使用\"=\"连接，类似 fun main(args: Array&lt;String>) = println('Hello World!')\nvoid main() => print('Hello World!');\n\n//最简写形式\nmain() => print('Hello World!');\n复制\n\n2. 数据类型在 Dart 中的一切皆是对象，包括数字、布尔值、函数等，它们和 Java 一样都继承于 Object，所以它们的默认值也就是 null。在 Dart 主要有：布尔类型 bool、数字类型 num（数字类型又分为 int、double，并且两者父类都是 num）、字符串类型 String、集合类型（List、Set、Map）、Runes 类和 Symbols 类型（后两个用的并不太多）。\n\n\n2.1 布尔类型（bool）在 Dart 中和 C 语言一样，都是使用 bool 来声明一个布尔类型变量或常量，而在 Kotlin 则是使用 Boolean 来声明，但是一致的是，它对应的值只有两个 true 和 false。\nmain() &#123;\n    bool islose = true;\n    bool isOpen = false;\n&#125;\n\n2.2 数字类型（num、int、double）\n\n\n\n\n\n\n\n\n在 Dart 中 int、double 都是类，然后 int、double 都继承** num 抽象类，这点和 Kotlin 很类似但是在 Dart 中没有 float、short、long 类型\nmain() &#123;\n  int width = 20;\n  int height = 3;\n  double result = width / height;\n  int resultTwo = width ~/ height; // 整除操作\n  print(resultTwo);\n\n&#125;\n\n数字常用的函数main() &#123;\n    print(3.141592653.toStringAsFixed(3)); //3.142 保留有效数字\n    print(6.6.floor());//6 向下取整\n    print((-6.6).ceil()); //-6 向上取整\n    print(9.9.ceil()); //10 向上取整\n    print(666.6.round()); //667 四舍五入\n    print((-666.6).abs()); // 666.6 取绝对值\n    print(666.6.toInt()); //666 转化成 int,这中 toInt、toDouble 和 Kotlin 类似\n    print(999.isEven); //false 是否是偶数\n    print(999.isOdd); //true 是否是奇数\n    print(666.6.toString()); //666.6 转化成字符串\n&#125;\n\nDart 中字符串操作main() &#123;\n    String name = 'Hello Dart!';//单引号\n    String title = \"'Hello Dart!'\";//双引号\n    String description = \"\"\"\n          Hello Dart! Hello Dart!\n          Hello Dart!\n          Hello Dart! Hello Dart!\n    \"\"\";//三引号\n    num value = 2;\n    String result = \"The result is $value\";//单值引用\n    num width = 200;\n    num height = 300;\n    String square = \"The square is $&#123;width * height&#125;\";//表达式的值引用\n&#125;\n\n字符串拆分相关操作main() &#123;\n  String url = \"https://mrale.ph/dartvm/\";\n\n  print(url.split(\"://\")[0]); //字符串分割 split 方法，类似 Java 和 Kotlin\n\n  print(url.substring(3, 9)); //字符串截取 substring 方法，类似 Java 和 Kotlin\n\n  print(url.codeUnitAt(0)); //取当前索引位置字符的 UTF-16 码\n\n  print(url.startsWith(\"https\")); //当前字符串是否以指定字符开头，类似 Java 和 Kotlin\n\n  print(url.endsWith(\"/\")); //当前字符串是否以指定字符结尾，类似 Java 和 Kotlin\n\n  print(url.toUpperCase()); //大写，类似 Java 和 Kotlin\n\n  print(url.toLowerCase()); //小写，类似 Java 和 Kotlin\n\n  print(url.indexOf(\"ph\")); //获取指定字符的索引位置，类似 Java 和 Kotlin\n\n  print(url.contains(\"http\")); //字符串是否包含指定字符，类似 Java 和 Kotlin\n\n  print(url.trim()); //去除字符串的首尾空格，类似 Java 和 Kotlin\n\n  print(url.length); //获取字符串长度\n\n  print(url.replaceFirst(\"t\", \"A\")); //替换第一次出现 t 字符位置的字符\n\n  print(url.replaceAll(\"m\", \"M\")); //全部替换，类似 Java 和 Kotlin\n&#125;\n\n2.4 类型检查（is 和 is!）和强制类型转换（as）和 Kotlin 一样，Dart 也是通过  is  关键字来对类型进行检查以及使用  as  关键字对类型进行强制转换，如果判断不是某个类型 Dart 中使用  is!，而在 Kotlin 中正好相反则用  !is  表示。\nmain() &#123;\n    int number = 100;\n    double distance = 200.5;\n    num age = 18;\n    print(number is num);//true\n    print(distance is! int);//true\n    print(age as int);//18\n&#125;\n\n2.6 Object 类型在 Dart 中所有东西都是对象，都继承于 Object，所以可以使用 Object 可以定义任何的变量，而且赋值后，类型也可以更改。\nmain() &#123;\n    Object color = 'black';\n    color = 0xff000000;//运行正常，0xff000000 类型是 int, int 也继承于 Object   \n&#125;\n\n2.7 dynamic 类型在 Dart 中还有一个和 Object 类型非常类似的类型那就是 dynamic 类型，下面讲到的 var 声明的变量未赋值的时候就是 dynamic 类型，它可以像 Object 一样可以改变类型。dynamic 类型一般用于无法确定具体类型，注意：建议不要滥用 dynamic，一般尽量使用 Object，如果你对 Flutter 和 Native 原生通信 PlatformChannel 代码熟悉的话，你会发现里面大量使用了 dynamic，因为可能 native 数据类型无法对应 Dart 中的数据类型，此时 Dart 接收一般就会使用 dynamic。\nObject 和 dynamic 区别在于：Object 会在编译阶段检查类型，而 dynamic 不会在编译阶段检查类型。\nmain() &#123;\n    dynamic color = 'black';\n    color = 0xff000000;//运行正常，0xff000000 类型是 int，int 也继承于 Object\n&#125;\n\n3.1 var 关键字\n\n\n\n\n\n\n\n\nvar 并不是直接存储值，而是存储值的对象引用\n在 Dart 中可以使用 var 来替代具体类型的声明，会自动推导变量的类型，这是因为 var 并不是直接存储值，而是存储值的对象引用，所以 var 可以声明任何变量。\n注意：在 Flutter 开发一般会经常使用 var 声明变量，以便于可以自动推导变量的类型。\nmain() &#123;\n  int colorValue = 0xff000000;\n  var colorKey = 'black'; //var 声明变量自动根据赋值的类型，推导为 String 类型 \n  // 使用 var 声明集合变量 \n  var colorList = ['red', 'yellow', 'blue', 'green'];\n  var colorSet = &#123;'red', 'yellow', 'blue', 'green'&#125;;\n  var colorMap = &#123;'white': 0xffffffff, 'black': 0xff000000&#125;;\n&#125;\n\n如果 var 声明的变量开始不初始化，不仅值可以改变，它的类型也是可以被修改的，但是一旦开始初始化赋值后，它的类型就确定了，后续不能被改变。\n3.2 常量（final 和 const）\n如果常量是编译期就能初始化的就用 const\n\n如果常量是运行时期初始化的就用 final\n\n\nmain() &#123;    \n  const PI = 3.141592653;//const 定义常量    \n  final nowTime = DateTime.now();//final 定义常量\n&#125;\n\n4. 集合（List、Set、Map）4.1 集合 List在使用方式上你会感觉它更像数组，但是它是可以随意对元素增删改成的。\nList 初始化方式：\nmain() &#123;\n      List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];//直接使用 [] 形式初始化\n      var colorList = &lt;String> ['red', 'yellow', 'blue', 'green'];\n&#125;\n\nList 常用的函数：main() &#123;\n    List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];\n    colorList.add('white');//和 Kotlin 类似通过 add 添加一个新的元素\n    print(colorList[2]);//可以类似 Kotlin 一样，直接使用数组下标形式访问元素\n    print(colorList.length);//获取集合的长度，这个 Kotlin 不一样，Kotlin 中使用的是 size\n    colorList.insert(1, 'black');//在集合指定 index 位置插入指定的元素\n    colorList.removeAt(2);//移除集合指定的 index=2 的元素，第 3 个元素\n    colorList.clear();//清除所有元素\n    print(colorList.sublist(1,3));//截取子集合\n    print(colorList.getRange(1, 3));//获取集合中某个范围元素\n    print(colorList.join('&lt;--->'));//类似 Kotlin 中的 joinToString 方法，输出：red&lt;--->yellow&lt;--->blue&lt;--->green\n    print(colorList.isEmpty);\n    print(colorList.contains('green'));    \n&#125;\n\nList 的遍历方式：main() &#123;\n    List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];\n    //for-i 遍历\n    for(var i = 0; i &lt; colorList.length; i++) &#123;//可以使用 var 或 int\n        print(colorList[i]);        \n    &#125;\n    //forEach 遍历\n    colorList.forEach((color) => print(color));//forEach 的参数为 Function. =>使用了箭头函数\n    //for-in 遍历\n    for(var color in colorList) &#123;\n        print(color);\n    &#125;\n    //while+iterator 迭代器遍历，类似 Java 中的 iteator\n    while(colorList.iterator.moveNext()) &#123;\n        print(colorList.iterator.current);\n    &#125;\n&#125;\n\n4.2 集合 Set集合 Set 和列表 List 的区别在于“集合中的元素是不能重复”的。所以添加重复的元素时会返回 false，表示添加不成功。\nSet 初始化方式：\nmain() &#123;\n    Set&lt;String> colorSet= &#123;'red', 'yellow', 'blue', 'green'&#125;;//直接使用 &#123;&#125; 形式初始化\n    var colorList = &lt;String> &#123;'red', 'yellow', 'blue', 'green'&#125;;\n&#125;\n\n集合中的交、并、补集，在 Kotlin 并没有直接给到计算集合交、并、补的 API：main() &#123;\n    var colorSet1 = &#123;'red', 'yellow', 'blue', 'green'&#125;;\n    var colorSet2 = &#123;'black', 'yellow', 'blue', 'green', 'white'&#125;;\n    print(colorSet1.intersection(colorSet2));//交集-->输出: &#123;'yellow', 'blue', 'green'&#125;\n    print(colorSet1.union(colorSet2));//并集--->输出: &#123;'black', 'red', 'yellow', 'blue', 'green', 'white'&#125;\n    print(colorSet1.difference(colorSet2));//补集--->输出: &#123;'red'&#125;\n&#125;\n\nSet 的遍历方式（和 List 一样）：main() &#123;\n  Set&lt;String> colorSet = &#123;'red', 'yellow', 'blue', 'green'&#125;;\n  //for-i 遍历\n  for (var i = 0; i &lt; colorSet.length; i++) &#123;\n    //可以使用 var 或 int\n    print(colorSet[i]);\n  &#125;\n  //forEach 遍历\n  colorSet.forEach((color) => print(color)); //forEach 的参数为 Function. =>使用了箭头函数\n  //for-in 遍历\n  for (var color in colorSet) &#123;\n    print(color);\n  &#125;\n  //while+iterator 迭代器遍历，类似 Java 中的 iteator\n  while (colorSet.iterator.moveNext()) &#123;\n    print(colorSet.iterator.current);\n  &#125;\n&#125;\n\n4.3 集合 Map集合 Map 和 Kotlin 类似，key-value 形式存储，并且  Map 对象的中 key 是不能重复的。\nMap 初始化方式：\nmain() &#123;\n    Map&lt;String, int> colorMap = &#123;'white': 0xffffffff, 'black':0xff000000&#125;;//使用 &#123;key:value&#125; 形式初始化\n var colorMap = &lt;String, int>&#123;'white': 0xffffffff, 'black':0xff000000&#125;;\n&#125;\n\nMap 中常用的函数：\nmain() &#123;\n    Map&lt;String, int> colorMap = &#123;'white': 0xffffffff, 'black':0xff000000&#125;;\n    print(colorMap.containsKey('green'));//false\n    print(colorMap.containsValue(0xff000000));//true\n    print(colorMap.keys.toList());//['white','black']\n    print(colorMap.values.toList());//[0xffffffff, 0xff000000]\n    colorMap['white'] = 0xfffff000;//修改指定 key 的元素\n    colorMap.remove('black');//移除指定 key 的元素\n&#125;\n\nMap 的遍历方式：\nmain() &#123;\n    Map&lt;String, int> colorMap = &#123;'white': 0xffffffff, 'black':0xff000000&#125;;\n    //for-each key-value\n    colorMap.forEach((key, value) => print('color is $key, color value is $value'));\n&#125;\n\nMap.fromIterables 将 List 集合转化成 Map：\nmain() &#123;\n    List&lt;String> colorKeys = ['white', 'black'];\n    List&lt;int> colorValues = [0xffffffff, 0xff000000];\n    Map&lt;String, int> colorMap = Map.fromIterables(colorKeys, colorValues);\n&#125;\n\n4.4 集合常用的操作符Dart 对于集合操作的也非常符合现代语言的特点，含有丰富的集合操作符 API，可以让你处理结构化的数据更加简单。\nmain() &#123;\n  List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];\n  //forEach 箭头函数遍历\n  colorList.forEach((color) => &#123;print(color)&#125;);\n  colorList.forEach((color) => print(color)); //箭头函数遍历，如果箭头函数内部只有一个表达式可以省略大括号\n\n  //map 函数的使用\n  print(colorList.map((color) => '$color_font').join(\",\"));\n\n  //every 函数的使用，判断里面的元素是否都满足条件，返回值为 true/false\n  print(colorList.every((color) => color == 'red'));\n\n  //sort 函数的使用\n  List&lt;int> numbers = [0, 3, 1, 2, 7, 12, 2, 4];\n  numbers.sort((num1, num2) => num1 - num2); //升序排序\n  numbers.sort((num1, num2) => num2 - num1); //降序排序\n  print(numbers);\n\n  //where 函数使用，相当于 Kotlin 中的 filter 操作符，返回符合条件元素的集合\n  print(numbers.where((num) => num > 6));\n\n  //firstWhere 函数的使用，相当于 Kotlin 中的 find 操作符，返回符合条件的第一个元素，如果没找到返回 null\n  print(numbers.firstWhere((num) => num == 5, orElse: () => -1)); //注意: 如果没有找到，执行 orElse 代码块，可返回一个指定的默认值\n\n  //singleWhere 函数的使用，返回符合条件的第一个元素，如果没找到返回 null，但是前提是集合中只有一个符合条件的元素，否则就会抛出异常\n  print(numbers.singleWhere((num) => num == 4, orElse: () => -1)); //注意：如果没有找到，执行 orElse 代码块，可返回一个指定的默认值\n\n  //take(n)、skip(n) 函数的使用，take(n) 表示取当前集合前 n 个元素，skip(n) 表示跳过前 n 个元素，然后取剩余所有的元素\n  print(numbers.take(5).skip(2));\n\n  //List.from 函数的使用，从给定集合中创建一个新的集合,相当于 clone 一个集合\n  print(List.from(numbers));\n\n  //expand 函数的使用，将集合一个元素扩展成多个元素或者将多个元素组成二维数组展开成平铺一个一位数组\n  var pair = [\n    [1, 2],\n    [3, 4]\n  ];\n  print('flatten list: $&#123;pair.expand((pair) => pair)&#125;');\n\n  var inputs = [1, 2, 3];\n  print('duplicated list: $&#123;inputs.expand((number) =>[\n    number,\n    number,\n    number\n  ])&#125;');\n&#125;\n\n5. 流程控制5.1 for 循环main() &#123;\n    List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];\n    for (var i = 0; i &lt; colorList.length; i++) &#123;//可以用 var 或 int\n        print(colorList[i]);\n    &#125;\n&#125;\n\n5.2 while 循环main() &#123;\n    List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];\n    var index = 0;\n    while (index &lt; colorList.length) &#123;\n        print(colorList[index++]);\n    &#125;\n&#125;\n\n5.3 do-while 循环main() &#123;\n    List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];\n    var index = 0;\n    do &#123;\n        print(colorList[index++]);\n    &#125; while (index &lt; colorList.length);\n&#125;\n\n5.4 break 和 continuemain() &#123;\n    List&lt;String> colorList = ['red', 'yellow', 'blue', 'green'];\n    for (var i = 0; i &lt; colorList.length; i++) &#123;//可以用 var 或 int\n        if(colorList[i] == 'yellow') &#123;\n            continue;\n        &#125;\n        if(colorList[i] == 'blue') &#123;\n            break;\n        &#125;\n        print(colorList[i]);\n    &#125;\n&#125;\n\n5.5 if-elsevoid main() &#123;\n  var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n  for (var i = 0; i &lt; numbers.length; i++) &#123;\n    if (numbers[i].isEven) &#123;\n      print('偶数: $&#123;numbers[i]&#125;');\n    &#125; else if (numbers[i].isOdd) &#123;\n      print('奇数: $&#123;numbers[i]&#125;');\n    &#125; else &#123;\n      print('非法数字');\n    &#125;\n  &#125;\n&#125;\n\n5.6 三目运算符（?、:）void main() &#123;\n  var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n  for (var i = 0; i &lt; numbers.length; i++) &#123;\n      num targetNumber = numbers[i].isEven ? numbers[i] * 2 : numbers[i] + 4;\n      print(targetNumber);\n  &#125;\n&#125;\n\n5.7 switch-case 语句Color getColor(String colorName) &#123;\n  Color currentColor = Colors.blue;\n  switch (colorName) &#123;\n    case \"read\":\n      currentColor = Colors.red;\n      break;\n    case \"blue\":\n      currentColor = Colors.blue;\n      break;\n    case \"yellow\":\n      currentColor = Colors.yellow;\n      break;\n  &#125;\n  return currentColor;\n&#125;\n\n5.8 Assert（断言）在 Dart 中如果条件表达式结果不满足条件，则可以使用 assert 语句中断代码的执行。特别是在 Flutter 源码中随处可见都是 assert 断言的使用。\n注意：断言只在检查模式下运行有效，如果在生产模式运行，则断言不会执行。\nassert(text != null);//text 为 null，就会中断后续代码执行\nassert(urlString.startsWith('https'));\n\n6. 总结到这里，关于初探 Dart 语法上篇就结束了，这篇主要讲述 Dart 中的基本语法、数据类型、常量和变量、集合以及流程控制。下一篇将接着初探 Dart 语法下篇进行分析。\n","slug":"Dart基础语法总结","date":"2021-12-08T05:36:37.000Z","categories_index":"","tags_index":"Flutter","author_index":"LittleStart"},{"id":"859f0b706fef61b48159b2531ea13be9","title":"NSDictionary实现原理","content":"/Users/jiajiagao/Desktop/截屏2021-11-26 下午2.39.43.png\n","slug":"NSDictionary实现原理","date":"2021-12-08T05:04:53.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"762c36802ec13a21aa701b7f071811de","title":"RunTime中","content":"Runtime 中关于对象\n\n\n\n\n\n\n\n\n涉及到的数据结构\n//对象\nstruct objc_object &#123;\n    Class isa  OBJC_ISA_AVAILABILITY;\n&#125;;\n//类\nstruct objc_class &#123;\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n&#125; OBJC2_UNAVAILABLE;\n//方法列表\nstruct objc_method_list &#123;\n    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;\n    int method_count                                         OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n    /* variable length structure */\n    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;\n&#125;                                                            OBJC2_UNAVAILABLE;\n//方法\nstruct objc_method &#123;\n    SEL method_name                                          OBJC2_UNAVAILABLE;\n    char *method_types                                       OBJC2_UNAVAILABLE;\n    IMP method_imp                                           OBJC2_UNAVAILABLE;\n&#125;\n\n系统查找方法的过程\n系统首先找到消息的接收对象，然后通过对象的isa找到它的类。\n在它的类中查找method_list，是否有selector方法。\n没有则查找父类的method_list。\n找到对应的method，执行它的IMP。\n转发IMP的return值。\n\n下面讲讲消息传递用到的一些概念：\n类对象(objc_class)\n实例(objc_object)\n元类(Meta Class)\nMethod(objc_method)\nSEL(objc_selector)\nIMP\n类缓存(objc_cache)\nCategory(objc_category)\n\nRunTime 消息转发（动态方法解析）\n\n\n\n\n\n\n\n\nObjective-C运行时会调用 让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。\n\n+resolveClassMethod:，\n\n- (void)viewDidLoad &#123;\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    //执行foo函数\n    [self performSelector:@selector(foo:)];\n&#125;\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;\n    if (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMP\n        class_addMethod([self class], sel, (IMP)fooMethod, \"v@:\");\n        return YES;\n    &#125;\n    return [super resolveInstanceMethod:sel];\n&#125;\n\nvoid fooMethod(id obj, SEL _cmd) &#123;\n    NSLog(@\"Doing foo\");//新的foo函数\n&#125;\n\n第一步：消息转发+resolveInstanceMethod:\n\n第二步：消息转发（备用接受者）forwardingTargetForSelector\n\n如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。\n#import \"ViewController.h\"\n#import \"objc/runtime.h\"\n\n@interface Person: NSObject\n\n@end\n\n@implementation Person\n\n- (void)foo &#123;\n    NSLog(@\"Doing foo\");//Person的foo函数\n&#125;\n\n@end\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad &#123;\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    //执行foo函数\n    [self performSelector:@selector(foo)];\n&#125;\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;\n    return NO;//返回YES，进入下一步转发\n&#125;\n\n// 消息转发\n- (id)forwardingTargetForSelector:(SEL)aSelector &#123;\n    if (aSelector == @selector(foo)) &#123;\n        return [Person new];//返回Person对象，让Person对象接收这个消息\n    &#125;\n\n    return [super forwardingTargetForSelector:aSelector];\n&#125;\n\n@end\n\n完整消息转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。\n实现一个完整转发的例子如下：\n#import \"ViewController.h\"\n#import \"objc/runtime.h\"\n\n@interface Person: NSObject\n\n@end\n\n@implementation Person\n\n- (void)foo &#123;\n    NSLog(@\"Doing foo\");//Person的foo函数\n&#125;\n\n@end\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad &#123;\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    //执行foo函数\n    [self performSelector:@selector(foo)];\n&#125;\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;\n    return YES;//返回YES，进入下一步转发\n&#125;\n\n- (id)forwardingTargetForSelector:(SEL)aSelector &#123;\n    return nil;//返回nil，进入下一步转发\n&#125;\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;\n    if ([NSStringFromSelector(aSelector) isEqualToString:@\"foo\"]) &#123;\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];//签名，进入forwardInvocation\n    &#125;\n\n    return [super methodSignatureForSelector:aSelector];\n&#125;\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;\n    SEL sel = anInvocation.selector;\n\n    Person *p = [Person new];\n    if([p respondsToSelector:sel]) &#123;\n        [anInvocation invokeWithTarget:p];\n    &#125;\n    else &#123;\n        [self doesNotRecognizeSelector:sel];\n    &#125;\n\n&#125;\n\n@end\n\n应用场景\n关联对象(Objective-C Associated Objects)给分类增加属性\n方法魔法(Method Swizzling)方法添加和替换和KVO实现\n消息转发(热更新)解决Bug(JSPatch)\n实现NSCoding的自动归档和自动解档\n实现字典和模型的自动转换(MJExtension)\n\n方法替换@implementation ViewController\n\n+ (void)load &#123;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        Class class = [self class];\n        SEL originalSelector = @selector(viewDidLoad);\n        SEL swizzledSelector = @selector(jkviewDidLoad);\n\n        Method originalMethod = class_getInstanceMethod(class,originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);\n\n        //judge the method named  swizzledMethod is already existed.\n        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));\n        // if swizzledMethod is already existed.\n        if (didAddMethod) &#123;\n            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));\n        &#125;\n        else &#123;\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        &#125;\n    &#125;);\n&#125;\n\n- (void)jkviewDidLoad &#123;\n    NSLog(@\"替换的方法\");\n\n    [self jkviewDidLoad];\n&#125;\n\n- (void)viewDidLoad &#123;\n    NSLog(@\"自带的方法\");\n\n    [super viewDidLoad];\n&#125;\n\n@end\n\n\n\n\n\n\n\n\n\n\nswizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。\n- (id)initWithCoder:(NSCoder *)aDecoder &#123;\n    if (self = [super init]) &#123;\n        unsigned int outCount;\n        Ivar * ivars = class_copyIvarList([self class], &amp;outCount);\n        for (int i = 0; i &lt; outCount; i ++) &#123;\n            Ivar ivar = ivars[i];\n            NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];\n            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];\n        &#125;\n    &#125;\n    return self;\n&#125;\n\n- (void)encodeWithCoder:(NSCoder *)aCoder &#123;\n    unsigned int outCount;\n    Ivar * ivars = class_copyIvarList([self class], &amp;outCount);\n    for (int i = 0; i &lt; outCount; i ++) &#123;\n        Ivar ivar = ivars[i];\n        NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];\n        [aCoder encodeObject:[self valueForKey:key] forKey:key];\n    &#125;\n&#125;\n\nmessage: &quot;nested exception is org.apache.ibatis.exceptions.PersistenceException: ↵### Error querying database.  Cause: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Error: Method queryTotal execution error of sql : ↵ SELECT COUNT(1) FROM re_clues LEFT JOIN re_employee ON re_clues.employee_id &#x3D; re_employee.id WHERE (belong_company_id &#x3D; ? AND company_name LIKE ?) ↵↵### The error may exist in com&#x2F;inquiry&#x2F;mapper&#x2F;ReCluesMapper.xml↵### The error may involve defaultParameterMap↵### The error occurred while setting parameters↵### Cause: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Error: Method queryTotal execution error of sql : ↵ SELECT COUNT(1) FROM re_clues LEFT JOIN re_employee ON re_clues.employee_id &#x3D; re_employee.id WHERE (belong_company_id &#x3D; ? AND company_name LIKE ?) ↵&quot;\n","slug":"runtime数据结构","date":"2021-12-07T07:54:39.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"84c46e71d38f152fbededa209add7e56","title":"Mybatis环境搭建","content":"MyBatis 环境搭建\n\n\n\n\n\n\n\n\nmybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中,sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并 返回。采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。                          \n一、Maven 相关依赖&lt;dependencies>\n\t&lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> \n  &lt;artifactId>mybatis&lt;/artifactId>\n\t&lt;version>3.4.5&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n  &lt;groupId>junit&lt;/groupId>\n  &lt;artifactId>junit&lt;/artifactId> \n  &lt;version>4.10&lt;/version>\n&lt;scope>test&lt;/scope>\n&lt;/dependency>\n&lt;dependency>\n\t&lt;groupId>mysql&lt;/groupId> \n  &lt;artifactId>mysql-connector-java&lt;/artifactId>\n\t&lt;version>5.1.6&lt;/version>\n\t&lt;scope>runtime&lt;/scope> \n&lt;/dependency>\n&lt;dependency>\n\t&lt;groupId>log4j&lt;/groupId> \n  &lt;artifactId>log4j&lt;/artifactId>\n\t&lt;version>1.2.12&lt;/version> &lt;/dependency>\n&lt;/dependencies>\n\n二、实体类实现 Serializable 方法public class User implements Serializable &#123;\n\n&#125;\n\n三、在XML编写查询语句&lt;mapper namespace=\"com.study.dao.IUserDao\">\n  &lt;!-- 配置查询所有操作 -->\n  &lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\">\n  select * from user\n  &lt;/select>\n&lt;/mapper>\n\n四、自定义流程分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mybatis环境搭建","date":"2021-10-30T11:49:03.000Z","categories_index":"","tags_index":"mybatis","author_index":"LittleStart"},{"id":"5c41202f364c38ccdbd34c8ae458f2bb","title":"内存管理","content":"内存布局栈(stack):方法调用，局部变量等，是连续的，高地址往低地址扩展\n堆(heap):通过alloc等分配的对象，是离散的，低地址往高地址扩展，需要我们手动控制\n未初始化数据(bss):未初始化的全局变量等\n已初始化数据(data):已初始化的全局变量等\n代码段(text):程序代码\n\n\n","slug":"内存管理","date":"2021-10-03T11:47:40.000Z","categories_index":"","tags_index":"内存管理","author_index":"LittleStart"},{"id":"1f36431921db0064bd4a7d93ff9bda02","title":"UIView图像卡顿掉帧原因","content":"UI卡顿掉帧原因\n\niOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GPU共同决定的。 一般来说，页面滑动流畅是60fps，也就是1s有60帧更新，即每隔16.7ms就要产生一帧画面，而如果CPU和GPU加起来的处理时间超过了16.7ms，就会造成掉帧甚至卡顿。\n五、滑动优化方案 CPU：把以下操作放在子线程中 1.对象创建、调整、销毁 2.预排版（布局计算、文本计算、缓存高度等等） 3.预渲染（文本等异步绘制，图片解码等）\nGPU: 纹理渲染，视图混合\n一般遇到性能问题时，考虑以下问题： 是否受到CPU或者GPU的限制？ 是否有不必要的CPU渲染？ 是否有太多的离屏渲染操作？ 是否有太多的图层混合操作？ 是否有奇怪的图片格式或者尺寸？ 是否涉及到昂贵的view或者效果？ view的层次结构是否合理？\n六、UI绘制原理\n\n\n异步绘制： [self.layer.delegate displayLayer: ] 代理负责生成对应的bitmap 设置该bitmap作为该layer.contents属性的值\n\n七、离屏渲染\nOn-Screen Rendering:当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行 Off-Screen Rendering:离屏渲染，分为CPU离屏渲染和GPU离屏渲染两种形式。GPU离屏渲染指的是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作 应当尽量避免的则是GPU离屏渲染\nGPU离屏渲染何时会触发呢？ 圆角（当和maskToBounds一起使用时）、图层蒙版、阴影，设置\nlayer.shouldRasterize ＝ YES\n\n为什么要避免GPU离屏渲染？ GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到offscreen-render的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响。另外由于离屏渲染会增加GPU的工作量，可能会导致CPU+GPU的处理时间超出16.7ms，导致掉帧卡顿。所以可以的话应尽量减少offscreen-render的图层\n","slug":"UIView图像卡顿掉帧原因","date":"2021-10-03T11:08:04.000Z","categories_index":"","tags_index":"UIView","author_index":"LittleStart"},{"id":"150d0752192ea36adfb8f6a2036d586d","title":"UIView图像显示原理","content":"图像显示原理\n\nimage\n1.CPU:输出位图 2.GPU :图层渲染，纹理合成 3.把结果放到帧缓冲区(frame buffer)中 4.再由视频控制器根据vsync信号在指定时间之前去提取帧缓冲区的屏幕显示内容 5.显示到屏幕上\n\nCPU工作 1.Layout: UI布局，文本计算 2.Display: 绘制 3.Prepare: 图片解码 4.Commit：提交位图\nGPU渲染管线(OpenGL) 顶点着色，图元装配，光栅化，片段着色，片段处理\n四、UI卡顿掉帧原因\n\niOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GPU共同决定的。 一般来说，页面滑动流畅是60fps，也就是1s有60帧更新，即每隔16.7ms就要产生一帧画面，而如果CPU和GPU加起来的处理时间超过了16.7ms，就会造成掉帧甚至卡顿。\n五、滑动优化方案 CPU：把以下操作放在子线程中 1.对象创建、调整、销毁 2.预排版（布局计算、文本计算、缓存高度等等） 3.预渲染（文本等异步绘制，图片解码等）\nGPU: 纹理渲染，视图混合\n一般遇到性能问题时，考虑以下问题： 是否受到CPU或者GPU的限制？ 是否有不必要的CPU渲染？ 是否有太多的离屏渲染操作？ 是否有太多的图层混合操作？ 是否有奇怪的图片格式或者尺寸？ 是否涉及到昂贵的view或者效果？ view的层次结构是否合理？\n六、UI绘制原理\n\nimage\n\nimage\n异步绘制： [self.layer.delegate displayLayer: ] 代理负责生成对应的bitmap 设置该bitmap作为该layer.contents属性的值\n\nimage\n七、离屏渲染\nOn-Screen Rendering:当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行 Off-Screen Rendering:离屏渲染，分为CPU离屏渲染和GPU离屏渲染两种形式。GPU离屏渲染指的是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作 应当尽量避免的则是GPU离屏渲染\nGPU离屏渲染何时会触发呢？ 圆角（当和maskToBounds一起使用时）、图层蒙版、阴影，设置\nlayer.shouldRasterize ＝ YES\n\n为什么要避免GPU离屏渲染？ GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到offscreen-render的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响。另外由于离屏渲染会增加GPU的工作量，可能会导致CPU+GPU的处理时间超出16.7ms，导致掉帧卡顿。所以可以的话应尽量减少offscreen-render的图层\n","slug":"UIView图像显示原理","date":"2021-10-03T11:05:50.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"e9b46794781d0a34e4fb025b5a7d50ca","title":"UIView事件传递机制","content":"事件传递与视图响应链 :\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;\n\n- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;\n\n\nimage\n\nimage\n如果事件一直传递到UIAppliction还是没处理，那就会忽略掉\n","slug":"UIView事件传递机制","date":"2021-10-03T10:54:58.000Z","categories_index":"","tags_index":"UIView","author_index":"LittleStart"},{"id":"5aeaa1caf03061ebea03dd5070710347","title":"iOS中关于锁总结","content":"7、自旋锁\n何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。\n7.1 OSSpinLock\n\n使用方式\n\n// 初始化 spinLock = OS_SPINKLOCK_INIT; // 加锁 OSSpinLockLock(&amp;spinLock); // 解锁 OSSpinLockUnlock(&amp;spinLock);复制代码\n然而，YYKit作者的文章不再安全的 OSSpinLock有说到这个自旋锁存在优先级反转的问题。\n7.2 os_unfair_lock\n\n自旋锁已经不再安全，然后苹果又整出来个 os_unfair_lock_t ,这个锁解决了优先级反转的问题。\n\n​    os_unfair_lock_t unfairLock;    unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);    os_unfair_lock_lock(unfairLock);    os_unfair_lock_unlock(unfairLock);\n8、atomic(property) set / get\n利用set / get 接口的属性实现原子操作，进而确保“被共享”的变量在多线程中读写安全，这已经是不能满足部分多线程同步要求。\n\n在定义 property 的时候， 有atomic 和 nonatomic的属性修饰关键字。\n对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。\n而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。\n\n-\nraw3d\nAtomic\n\n是默认的\n会保证 CPU 能在别的线程来访问这个属性之前，先执行完当前流程\n速度不快，因为要保证操作整体完成\n\nNon-Atomic\n\n不是默认的\n更快\n线程不安全\n如有两个线程访问同一个属性，会出现无法预料的结果\n\n-\nVijayendra Tripathi\n\n假设有一个 atomic 的属性 “name”，如果线程 A 调[self setName:@”A”]`，线程 B 调[self setName:@”B”]，线程 C 调[self name]``，那么所有这些不同线程上的操作都将依次顺序执行——也就是说，如果一个线程正在执行 getter/setter，其他线程就得等待。因此，属性 name 是读/写安全的。\n\n但是，如果有另一个线程 D 同时在调[name release]，那可能就会crash，因为 release 不受 getter/setter 操作的限制。也就是说，这个属性只能说是读/写安全的，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。\n\n如果 name 属性是 nonatomic 的，那么上面例子里的所有线程 A、B、C、D 都可以同时执行，可能导致无法预料的结果。如果是 atomic 的，那么 A、B、C 会串行，而 D 还是并行的。\n\n\n-\n\n简单来说，就是atomic会加一个锁来保障线程安全，并且引用计数会+1，来向调用者保证这个对象会一直存在。假如不这样做，如果另一个线程调setter，可能会出现线程竞态，导致引用计数降到0，原来那个对象就是否了。\n\n","slug":"iOS中关于锁总结","date":"2021-10-03T09:58:28.000Z","categories_index":"","tags_index":"锁","author_index":"LittleStart"},{"id":"cf0e611562c137ce26a0fd876069298a","title":"类对象具体操作方法","content":"类与对象操作函数runtime提供了大量的函数来直接操作类与对象数据结构，类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。\n类相关操作函数我们可以回过头去看看objc_class的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。\n类名(name)类名操作的函数主要有：// 获取类的类名const char * class_getName ( Class cls )\n\n对于class_getName函数，如果传入的cls为Nil，则返回一个char字符串\n\n父类(super_class)和元类(meta-class)父类和元类操作的函数主要有： // 获取类的父类 Class class_getSuperclass ( Class cls ); // 判断给定的Class是否是一个元类 BOOL class_isMetaClass ( Class cls );\nclass_getSuperclass函数，当cls为Nil或者cls为根类时，返回Nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。\nclass_isMetaClass函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。\n实例变量大小(instance_size)实例变量大小操作的函数有：// 获取实例大小size_t class_getInstanceSize ( Class cls );\n成员变量(ivars)及属性在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：\n\n成员变量操作函数，主要包含以下函数： // 获取类中指定名称实例成员变量的信息 Ivar class_getInstanceVariable ( Class cls, const char *name ); // 获取类成员变量的信息 Ivar class_getClassVariable ( Class cls, const char *name ); // 添加成员变量 BOOL class_addIvar( Class cls, const char *name, size_t size, uint8_t alignment, const char *types ); // 获取整个成员变量列表 Ivar * class_copyIvarList( Class cls, unsigned int *outCount );\n\nclass_getInstanceVariable函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。\nclass_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。\nObjective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？\n这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。\nclass_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。\n","slug":"类对象具体操作方法","date":"2021-10-03T09:52:41.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"7d5af61f6682832ceaf909aad79a5565","title":"OC消息发送","content":"消息的发送ObjC中使用[Receiver message]方式来进行方法调用,本质其实就是向Receiver发送message消息.而message告诉这个Receiver要做什么\n\n给nil发送消息 在ObjC中，给nil发送消息是合法的，但在运行时什么都不做，而发送给nil的消息带有返回值也是合法的。 ■ 如果一个方法返回一个对象、任何类型的指针、任何size小于或等于sizeof(void*)的类型，如float、 double、 long double、或者long long，那么给nil发送消息将返回0。 ■ 如果一个方法返回一个数据结构，那么将这个消息传递给nil将为这个数据结构的每个成员都返回0.0。 ■ 如果一个方法返回上述类型外的其它类型，那么将这个消息传递给nil，返回值为定义。\n\n多态和动态绑定\n\n函数和它的参数是在编译时绑定在一起\n消息和接收者直到程序运行时，消息被发送才实现这种绑定，响应一个消息体是在运行时才决定的，而不是在代码编译时候\nMessage中的方法名是用来选择 Receiver的Method实体,因此,Message中的方法名也被称为**(selector)**选择器.\n\n方法和选取器\n\n选取器确定的是方法名,不是方法的实现, 这是多态和动态绑定的基础.它使得向不同对象发送相同的消息成为现实.\n\n方法返回值和参数类型:\n\n消息机制是通过选取器找到方法的返回值类型和参数类型. 因此: 动态绑定需要同名方法的实现 拥有相同返回值类型和相同的参数类型;否则,运行时可能出现找不到对应方法的错误.(有一个例外，虽然同名静态方法和实例方法拥有相同的选取器，但是它们可以有不同的参数类型和返回值类型。)\n\n&#x2F;&#x2F; SEL和@selector区别:选择器的类型是SEL.而 @selector指示符是用来引用选择器的, 它返回类型是SEL.\n  SEL response;      \n  response &#x3D; @selector(load:)\n\n  &#x2F;&#x2F; 1. 通过字符串来得到选取器:\n  responseSEL &#x3D; NSSelectorFromString(@&quot;loadDataForTableView:&quot;);\n  &#x2F;&#x2F;  2 . 通过选择器转换来得到方法名: \n  NSString  *methodName &#x3D; NSStringFromSelector(responseSEL);\n\n","slug":"OC消息发送","date":"2021-10-03T03:48:29.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"07b3470a92b5218af5f032e4b7c9894f","title":"OC中的类","content":"OC中的类\n\n\n\n\n\n\n\n\n编译器为每个类定义一个类对象(Class_object)。Class_object 是Class的编译版本，而它所构建的对象被称为类的实例\n\n程序中真正做工作的是类在运行时对象创建的那些实例\n一个类的所有实例有同一套方法，而且有相同一套实例变量\n每个对象都有自己的实例变量，但他们却共享这套方法\n\n继承（Inheritance）\n一个新的类往往都基于另外一个类，而这个新类继承了原来类的方法和实例变量\n新类通常简单地添加实例变量或者修改它所继承的方法，它不需要复制继承的代码。继承将这些类连接成一个只有一个根继承关系树\n在OC中，写基于功能框架的代码时，这个根类通常是NSObject\n每个类(除了根类)都有一个父类，而每个类，包括根类都可以成为任何数量子类的父类\n\n抽象类\nNSObject类就是一个重要的抽象类。程序中经常会定义NSObject的子类并使用这些子类的实例，但从来没有直接使用这个类的实例\n\n抽象类通常包含一些帮助定义应用程序架构的代码，当你定义这些类的子类时，这些子类的实例能很好地适应这种应用程序架构，并能够自动地和别的对象协作。由于抽象类只有定义了子类才能成为一个有用的类，因此它们常常被称为抽象超类。\n\n\n类类型\n类实际上是一类对象的详细说明，定义了一个数据类型。这个类型不但基于它所定义的数据结构，还取决于它所定义的一些行为，这些行为就是方法\n类名可以出现在任何C语言允许的类型说明符出现的地方，例如作为sizeof操作符的参数：Int i = sizeof(Circle);\n\n静态类型匹配 Circle *myCircle; 这种声明对象的方式为编译器提供了对象种类的信息，所以被称为静态类型匹配，静态类型匹配使编译器具备了一些类型检查功能，例如如果一个对象接收一个没有定义的消息时，可以发出警告，而如果把对象定义为id，就会放松这种限制\n动态类型匹配id myCircle；\n\n对象通常都是被定义成指针，上面的静态匹配使得指针的含义更加明确，而id却隐藏了这些信息。 id类型是一种灵活的数据类型, 只表示它是一个对象，不能为编译器提供例如实例变量，可执行操作等信息。\n\n每个对象在运行时必须提供这些信息。 而之所以能做到这点， 是因为每个对象都有一个isa 实例变量来标示这个对象所属的类每个Circle对象都能告诉运行时系统它是一个几何类，因此，动态类型匹配实际上发生在程序被执行时。\n\n运行时系统就能够查明一个对象到底属于哪个类，而这只需要查询对象的isa实例变量就可以了。这个isa指针还为对象提供了一种称为“自省”(introspection)的功能。编译器会在数据机构中记录关于类定义的信息为运行时环境\n\n\n类型自省实例在运行时可以获取自己的类。例如，NSObject类中定义的isMemberOfClass（或isKindOfClass）方法可以检查接收者是不是特定类的实例（或继承特定类的实例）\n","slug":"OC中的类","date":"2021-10-03T01:07:27.000Z","categories_index":"","tags_index":"OC类","author_index":"LittleStart"},{"id":"024b1a5a8576bdfa18efbc793fd20736","title":"Runloop探究总结（一）","content":"RunLoop 是什么？\n\n\n\n\n\n\n\n\nRunloop是通过内部维护一个事件循环来对事件、消息进行管理的一个对象。是的，它是一个对象。 大家用C语言过main函数的都知道，main函数运行完成后程序就结束退出了。但是为什么iOS的App的main函数运行完之后APP还能一直运行呢？这就是Runloop的功劳。 \nRunloop最基本的应用就是iOS的main函数：int main(int argc, char * argv[]) &#123;\n    @autoreleasepool &#123;\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    &#125;\n&#125; \n\nRunloop 基本方法\nRunloop是个对象,获取当前线程的runLoop\n\n[NSRunloop currentRunLoop]\n\n\n\n获得主线程的Runloop对象\n\n[NSRunLoop mainRunLoop]\n\n获得当前线程的RunLoop对象 \nCore Foundation 中获取RunLoop 方法\n获得当前线程的RunLoop对象CFRunLoopGetCurrent()\n获得主线程的Runloop对象\n\nCFRunLoopGetMain();\n\nRunLoop的实现机制\n\n\n\n\n\n\n\n\n为了方便Runloop机制的理解，下面写一段伪代码来表示一下RunLoop循环。\nfunction runloop() &#123;\n    initialize();\n    do &#123;\n        var message = get_next_message();  //从队列获取消息\n        process_message(message); //处理消息\n    &#125; while (message != quite);  //当触发quite条件时，Runloop退出\n&#125;\n\n从上面的源代码可以看出Runloop的处理机制是\n\n\n\n\n\n\n\n\n“接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quite 的消息）。 \nRunLoop的核心是什么？\n在没有消息处理时休眠，在有消息时又能唤醒。这样可以提高CPU资源使用效率 当然RunLoop它不是简单的while循环，不是用sleep来休眠，毕竟sleep这方法也是会占用cpu资源的。\n\n那它是如何实现真正的休眠的呢？那就是：没有消息需要处理时，就会从用户态切换到内核态，用户态进入内核态后，把当前线程控制器交给内核态，这样的休眠线程是被挂起的，不会再占用cpu资源。\n\n\n\n这里要注意用户态和内核态 这两个概念，还有mach_msg()方法。 内核态 这个机制是依靠系统内核来完成的(苹果操作系统核心组件 Darwin 中的 Mach )。\n\nRunLoop的实现整个流程：\n\n根据modeName 找到对应的mode\n\nCFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);\n\n\n如果mode里面source/timer/observer 直接返回\n\nif (__CFRunLoopModeIsEmpty(currentMode)) return;\n\n\n通知 Observers: RunLoop 即将进入 loop。\n\n__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n\n内部函数进入RunLoop进入相应的操作\n\n\n内部函数处理流程分析\n\n\n通知 Observers: RunLoop 即将触发 Timer 回调。\n\n\n\n通知 Observers: RunLoop 即将触发 Timer 回调。\n__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n\n\n\n通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。\n\n\n\n通知 Observers: RunLoop 即将触发 Timer 回调。\n__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n\n\n执行被加入的block\n\n\n\n// 执行被加入的block\n__CFRunLoopDoBlocks(runloop, currentMode);\n\n\n\nRunLoop 触发 Source0 (非port) 回调。\n\n\n\nsourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);\n\n\n 执行被加入的block\n\n\n\n_CFRunLoopDoBlocks(runloop, currentMode);\n\n\n 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。\n\n\n\nif (__Source0DidDispatchPortLastTime) &#123;\n    Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)\n    if (hasMsg) goto handle_msg;\n&#125;\n\n\n\n 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。\n\n\n\n通知 Observers: RunLoop 的线程即将进入休眠(sleep)。\nif (!sourceHandledThisLoop) &#123;\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n&#125;\n\n\n\n调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。\n\n\n\n  \n• 一个基于 port 的Source 的事件。\n• 一个 Timer 到时间了\n• RunLoop 自身的超时时间到了\n• 被其他什么调用者手动唤醒\n__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;\n    mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg\n&#125;\n            \n\n\n\n通知 Observers: RunLoop 的线程刚刚被唤醒了。\n\n\n\n  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n/// 收到消息，处理消息。\nhandle_msg:\n9.1 如果一个 Timer 到时间了，触发这个Timer的回调。\nif (msg_is_timer) &#123;\n    __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n&#125; else if (msg_is_dispatch) &#123;\n   如果有dispatch到main_queue的block，执行block。\n    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n&#125; \n/// 如果没超时，mode里没空，loop也没被停止，那继续loop。\n\n整体源代码\nint CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;\n\n    // 首先根据modeName找到对应mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);\n    /// 如果mode里没有source/timer/observer, 直接返回。\n    if (__CFRunLoopModeIsEmpty(currentMode)) return;\n\n    // 通知 Observers: RunLoop 即将进入 loop。\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n\n    /// 内部函数，进入loop\n    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;\n\n        Boolean sourceHandledThisLoop = NO;\n        int retVal = 0;\n        do &#123;\n\n            /// 2\\. 通知 Observers: RunLoop 即将触发 Timer 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n            /// 3\\. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n            /// 4\\. RunLoop 触发 Source0 (非port) 回调。\n            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n\n            /// 5\\. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。\n            if (__Source0DidDispatchPortLastTime) &#123;\n                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)\n                if (hasMsg) goto handle_msg;\n            &#125;\n\n            ///6\\. 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。\n            if (!sourceHandledThisLoop) &#123;\n                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n            &#125;\n\n            /// 7\\. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。\n            /// • 一个基于 port 的Source 的事件。\n            /// • 一个 Timer 到时间了\n            /// • RunLoop 自身的超时时间到了\n            /// • 被其他什么调用者手动唤醒\n            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;\n                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg\n            &#125;\n\n            /// 8\\. 通知 Observers: RunLoop 的线程刚刚被唤醒了。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n\n            /// 收到消息，处理消息。\n            handle_msg:\n\n            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。\n            if (msg_is_timer) &#123;\n                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n            &#125; \n\n            /// 9.2 如果有dispatch到main_queue的block，执行block。\n            else if (msg_is_dispatch) &#123;\n                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            &#125; \n\n            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。\n        &#125; while (retVal == 0);\n    &#125;\n\n    // 通知 Observers: RunLoop 即将退出。\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n&#125;\n\n   看源码里的注释，可以了解个Runloop运行的流程。 咱们还是围绕RunLoop的核心来理解， 既然上面提到休眠是通过内核来完成的，那唤醒条件呢？ \n下面几个就是主要的唤醒Runloop的事件：\n收到基于 port 的 Source1 的事件\nTimer到时间执行\nRunLoop自身的超时时间到了\n被其他调用者手动唤醒\n\n关于RunLoop的source1和source0上面介绍了source1包括系统事件捕捉和基于port的线程间通信。\n什么是系统事件捕捉？又如何理解基于port的线程间通信？\n\n\n\n\n\n\n\n\n我们手指点击屏幕，首先产生的是一个系统事件，通过source1来接受捕捉，然后由Springboard程序包装成source0分发给应用去处理，因此我们在App内部接受到触摸事件，就是source0，这一前一后的关系。source1 通过程序包装是会变成 source0的\nRunLoop的有几种Mode, RunLoop设置Mode作用是什么？\n\n\n\n\n\n\n\n\nRunLoop的运行模式共有5种，RunLoop只会运行在一个模式下，要切换模式，就要暂停当前模式，重新启动一个运行模式\n\nkCFRunLoopDefaultMode, App的默认运行模式，通常主线程是在这个运行模式下运行\nUITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）\nkCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式\nUIInitializationRunLoopMode：在刚启动App时进入的第一个Mode，启动完成后就不再使用\nGSEventReceiveRunLoopMode：接受系统内部事件，通常用不到\n\n**RunLoop设置Mode作用 **\n  设置Mode作用是指定事件在运行循环（Loop）中的优先级。 线程的运行需要不同的模式，去响应各种不同的事件，去处理不同情境模式。(比如可以优化tableview的时候可以设置UITrackingRunLoopMode下不进行一些操作)\n为什么只有主线程的Runloop是自动开启的？\n\n\n\n\n\n\n\n\n\n看iOS的main函数代码， 代码自动生成了autoreleasepool，这里就是调用了runloop。app启动时main函数就自动开启了主线程的runloop。\nint main(int argc, char * argv[]) &#123;\n    @autoreleasepool &#123;\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    &#125;\n&#125; \n\nPerformSelector:afterDelay:这个方法在子线程中是否起作用?为什么?怎么解决?当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动TableView的Cell时，label是否刷新？为什么？不刷新了。 因为NSTimer对象是以NSDefaultRunLoopMode添加到主运行循环中的时候, TableView（ScrollView）滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。如果希望在滚动时，定时器也能运行，那就应该使用common mode。 通过 CFRunloopAddTimer(runloop,timer ,commonMode) 实现。就是同步把事件源timer用同一个mode.AFNetworking 中如何运用 Runloop?AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：\n\n(void)networkRequestThreadEntryPoint:(id)__unused object {  @autoreleasepool {\n  [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];\n  NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n  [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n  [runLoop run];\n\n  }  }\n\n(NSThread *)networkRequestThread {  static NSThread *_networkRequestThread = nil;  static dispatch_once_t oncePredicate;  dispatch_once(&amp;oncePredicate, ^{\n  _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n  [_networkRequestThread start];\n\n  });  return _networkRequestThread;  }\n\n\nRunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。\n\n(void)start {  [self.lock lock];  if ([self isCancelled]) {  [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n\n  } else if ([self isReady]) {  self.state = AFOperationExecutingState;\n  [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n\n  }  [self.lock unlock];  }  当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。  解释一下Runloop在 NSTimer中的的作用  NSTimer 其实就是 CFRunLoopTimerRef，这两个类之间，是可以交换使用的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，在发生阻塞状态并不会准时回调给Timer。某个时间点被错过了，不会在延期时间后给你执行。比如等公交，如果10:10 有一趟公交，我没赶上，那我只能等 10:20 这一趟。10:10分那趟不会再回来的。  Runloop 和线程的关系？  Runloop 和是一对一的关系，一个线程对应一个 Runloop。主线程的默认就有了 Runloop。 可以通过数据结构看出来，创建线程时，线程默认是没有runloop的，需要手工创建线程的runloop。  有了线程，你觉得为什么还要有runloop？  Runloop最主要的作用 就是它如何在没有消息处理时休眠，在有消息时又能唤醒。这样可以提高CPU资源使用效率 。runloop 另外一个作用是消息处理。只有线程，是做不到这点的。  GCD 在Runloop中的使用？  GCD由子线程返回到主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。  AFNetworking 中如何运用 Runloop?  AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：\n\n\n(void)networkRequestThreadEntryPoint:(id)__unused object {  @autoreleasepool {\n  [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];\n  NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n  [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n  [runLoop run];\n\n  }  }\n\n(NSThread *)networkRequestThread {  static NSThread *_networkRequestThread = nil;  static dispatch_once_t oncePredicate;  dispatch_once(&amp;oncePredicate, ^{\n  _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n  [_networkRequestThread start];\n\n  });  return _networkRequestThread;  }\n\n\nRunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。\n\n(void)start {  [self.lock lock];  if ([self isCancelled]) {  [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n\n  } else if ([self isReady]) {  self.state = AFOperationExecutingState;\n  [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n\n  }  [self.lock unlock];  }\n\n当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。PerformSelector:afterDelay:这个方法在子线程中是否起作用？不起作用，子线程默认没有 Runloop。 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。可以使用 GCD的dispatch_after来实现afterDelay这样的需求。当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效，CADispalyTimer和Timer哪个更精确当然是CADisplayLink 更精确。iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。看上面Runloop在 NSTimer中的使用的问题，就知道NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。可见 NSTimer的定时是很不靠谱的。CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。\n","slug":"Runloop探究总结（一）","date":"2021-10-03T00:34:38.000Z","categories_index":"","tags_index":"Runloop","author_index":"LittleStart"},{"id":"888e58a89b2f989fb3e2e1a0413d4445","title":"OC 对象的本质","content":"OC对象的本质\nOC中类和对象都是基于C和C++的结构体实现的;\nOC中的对象分为三种：实例对象、类对象、元类对象\n\n实例对象内存分批\n\nOC 基类为NSObject，实例对象只有一个成员变量 isa\ntypedef struct objc_class *Class;\nstruct objc_object &#123;\n   Class isa;\n&#125;;\ntypedef struct objc_object *id;\n\n\nisa是一个指针在64位系统下占用8字节、实例化之后占用的空间是 16字节 在源码中内存分配最小是16字节（主要是内存对齐、从而分配的内存空间是16的整数倍，CPU 读取内存 iOS是从高位开始读取）\n\n实例对象就是通过alloc分配内存生成的对象，内部结构是一个isa指针和它的成员变量的值\nstruct objc_class &#123;\n   Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n   Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n   long instance_size                                       OBJC2_UNAVAILABLE;\n   struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n   struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n   struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n   struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n&#125; OBJC2_UNAVAILABLE;\n类对象在内存中有且只有一个，通过类和实例都能获取到类对象。其中包括isa指针，superClass指针，类的属性信息，类的对象方法信息，类的协议信息、类的成员变量信息\n\n元类对象在每个类的内存中也只有一个，通过runtime方法object_getClass(类对象)获取。内部结构跟类对象一样都是Class类型，只是用途不一样。其中包括：isa指针，superclass指针，类的类方法信息；\n\n实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向基元类，基元类的isa则指向自己\n\n实例对象中没有superclass指针，只有类对象和元类对象中有，superclass就是指向父类，根元类对象的superclass指向根类对象，根类对象的superclass指向nil\n\n\n类对象一个类的定义会包含丰富的信息（详见附录），但大部分都是关于这个类的实例的，如：\n\n类名及超类\n关于实例变量的完整描述\n关于方法名及其参数的说明\n方法的实现\n\n虽然类对象保存了类的属性，但它本身并不是一个类的实例。它没有自己的实例变量，而且它也不能执行为类实例设计的方法\n类名就代表类对象，下面的例子中，Circle类使用继承自NSObject的方法返回类的版本号:\nInt versionNumber = [Circle version]\n只有在作为接收者接收一个消息时，类名才能代表类对象\n给类发送class消息来获得一个类id\nId aClass &#x3D; [anObject class];\nId rectClass &#x3D; [Circle class];\n\n类对象可以被转化为id类型，而且类对象还可以更精确地转化为类类型，如：\nClass aClass &#x3D; [anObject class]\n Class rectClass &#x3D; [Circle class]\n\n\n所有的类都属于类对象，使用Class类型和使用类名进行静态类型匹配是等效的\n类对象也像类实例那样，可以进行动态类型匹配、接收消息以及从别的类继承方法。不同之处在于它们是由编译器产生的，没有自己的数据结构，它们是用于运行时系统产生类实例的代理。\n\n","slug":"OC-对象的本质","date":"2021-10-02T11:30:44.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"723aff21bbff3d47a1a80bce7952c340","title":"iOS总结（UIViewController）相关","content":"UIViewController\n\n\n\n\n\n\n\n\n在iOS应用运行中，屏幕中显示的内容是一组一组的视图对象，他们负责显示屏幕中的内容，而在视图的后面是UIViewController视图控制器，它的作用是管理哪些视图中显示的内容，并协调他们和应用其他部分的关系。\nUIViewController 主要职责\n\n更新视图的内容，通常是为了响应底层数据的变化。\n响应用户与视图的交互。\n调整视图大小并管理整个界面的布局。\n\n基本生命周期\nalloc  创建一个视图控制器对象，并分配内存空间。\ninit() 对视图控制器对象进行初始化。\nloadView 如果从storyboard创建视图，则从storyboard中加载视图。\nviewDidLoad 视图加入完成，可以进行一些自定义操作\nviewWillAppear 视图即将要展示在屏幕上。\nviewDidAppear 视图已经站在屏幕上显示并完成渲染。\nviewWillLayoutSubviews 视图即将布局其子视图\nviewDidLayoutSubviews 视图已经完成子视图的布局\nviewWillDisappear 视图即将从屏幕中消失\nviewDidDisappear 视图已经从屏幕上消失\ndealloc 视图被销毁\n\n\n\n\n\n\n\n作为视图控制器(ViewController)容器也可以使用viewController作为容器管理其他viewcontroller。 以下是作为容器可以调用的基本方法：\n\naddChildViewController:\nremoveFromParentViewController\nwillMoveToParentViewController:\ndidMoveToParentViewController:\n\n内存管理内存是iOS的关键资源，viewController提供内置的支持以减少关键时刻的内存占用。当内存不足的时候，会自动调用didReceiveMemoryWarning这个方法。 一般我们可以在这个方法中\n\n清理缓存\n将一些数据存储到硬盘\n清除不可见的UIViewController\n\n","slug":"iOS面试总结（UIViewController）","date":"2021-10-02T10:21:11.000Z","categories_index":"","tags_index":"UIViewController","author_index":"LittleStart"},{"id":"14b08975a30eb8616d67d5a52db5f251","title":"iOS面试问题总结（架构设计模式）","content":"设计模式\n\n\n\n\n\n\n\n\n设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。\n设计模式是什么？ 你知道哪些设计模式，并简要叙述？\n 1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。 2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。 3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。 4). 观察者模式：KVO是典型的观察者模式，观察某个属性的状态，状态发生变化时通知观察者。 5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。 6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。\n单利模式\n\n\n\n\n\n\n\n\n单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，并提供一个访问它的全剧访问点。\n使用场景系统只需要一个实例对象，客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。比较典型的例子是音乐播放器，日志系统类等等。\n优点\n提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。\n因为该类在系统内存中只存在一个对象，所以可以节约系统资源。\n\n缺点\n由于单例模式中没有抽象层，因此单例类很难进行扩展。\n\n\n工厂模式\n\n\n\n\n\n\n\n\n简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。\n适用场景如果我们希望将一些为数不多的类似的对象的创建和他们的创建细节分离开，也不需要知道对象的具体类型，可以使用简单工厂模式。\n举个形象点的例子：开发中，常常会使用外观各式各样的按钮：比如有的按钮有圆角，有的按钮有阴影，有的按钮有边\n优点\n客户端只需要给工厂类传入一个正确的（约定好的）参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合。\n客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，减少开发者的记忆成本。\n\niOS SDK 应用场景\nObjective-C中的类簇就是简单工厂设计模式的一个应用。如果给NSNumber的工厂方法传入不同类型的数据，则会返回不同数据所对应的NSNumber的子类。\n\n\n抽象工厂模式\n\n\n\n\n\n\n\n\n\n抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。\n​        我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。比如系统中有多于一个的产品族，而每次只使用其中某一产品族，属于同一个产品族的产品将在一起使用\n抽象工厂模式的成员和工厂方法模式的成员是一样的，只不过抽象工厂方法里的工厂是面向产品族的。\n\n抽象工厂（Abstract Factory）：抽象工厂负责声明具体工厂的创建产品族内的所有产品的接口。\n具体工厂（Concrete Factory）：具体工厂负责创建产品族内的产品。\n抽象产品（Abstract Product）：抽象产品是工厂所创建的所有产品对象的父类，负责声明所有产品实例所共有的公共接口。\n具体产品（Concrete Product）：具体产品是工厂所创建的所有产品对象类，它以自己的方式来实现其共同父类声明的接口。\n\n抽象工厂和工厂模式区别\n抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构\n增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。\n\n五. 生成器模式\n\n\n\n\n\n\n\n\n生成器模式(Builder Pattern)：也叫创建者模式，它将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n有些对象的创建流程是一样的，但是因为自身特性的不同，所以在创建他们的时候需要将创建过程和特性的定制分离开\n当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时比较适合使用生成器模式。\n一些复杂的对象，它们拥有多个组成部分（如汽车，它包括车轮、方向盘、发送机等各种部件）。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车。而且这些部分的创建顺序是固定的，或者是需要指定的。\n在这种情况下可以通过建造者模式对其进行设计与描述，生成器模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。\n","slug":"iOS面试问题总结（架构设计模式）","date":"2021-10-02T02:57:55.000Z","categories_index":"","tags_index":"设计模式、架构、MVVM","author_index":"LittleStart"},{"id":"386fc4bc5a18ec12e9fe740e6fc9c9ef","title":"iOS UIView和CALayer关系","content":"一、UIView 和 CALayer 探究\n\n\n\n\n\n\n\n\n所有的UIView都有CALayer 驱动、view 和 Layer 紧密关系，view从layer 中获取所需要所有数据、layer 侧重图形表示，view 相当于layer管理者\nUIView\n\n\n\n\n\n\n\n\n继承自 UIResponder\nNS_CLASS_AVAILABLE_IOS(2_0) @interface UIView : UIResponder &lt;NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusItem, CALayerDelegate&gt;\n\n\nCALayer\n\n\n\n\n\n\n\n\n继承NSObject\nCALayer是属于QuartzCore框架，而这个框架是一个跨平台的绘制框架。这里的跨平台指的是在iOS和OS X系统上均能使用，也就是说CALayer能在iOS和OS X上面绘制内容（这也说明了为什么CALayer的很多属性都不是UIKit框架下面的东西，比如它的backgroundColor是CGColorRef，因为OS X中没有UIKit）。但是这两个平台接收用户交互的方式完全不一样：iOS是通过触摸事件（touch event）而OS X则是监听鼠标和键盘事件。\nCA_CLASS_AVAILABLE (10.5, 2.0, 9.0, 2.0)\n@interface CALayer : NSObject &lt;NSCoding, CAMediaTiming&gt;\n\n\n\nUILayer 和 UIView 的 Frame 关系\n一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 transform 共同决定\n View 的 frame 只是简单的返回 Layer的 frame\nView 的 center和 bounds 也是返回 Layer 的一些属性\n\n自定义两个类TSView和TSLayer分别集成UIView和CALyer可以测试初始化过程 \n- (instancetype)init&#123;\n    self &#x3D; [super init];\n    if (self) &#123;\n        NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; TSView init&quot;);\n    &#125;\n    return self;\n&#125;\n\n+ (Class)layerClass&#123;\n    return [TSLayer class];\n&#125;\n\n- (void)setFrame:(CGRect)frame&#123;\n    [super setFrame:frame];\n&#125;\n\n- (void)setCenter:(CGPoint)center&#123;\n    [super setCenter:center];\n&#125;\n\n- (void)setBounds:(CGRect)bounds&#123;\n    [super setBounds:bounds];\n&#125;\n\nTSLayer中重写以下方法\n- (instancetype)init&#123;\n    self &#x3D; [super init];\n    if (self) &#123;\n        NSLog(@&quot;TSLayer init&quot;);\n    &#125;\n    return self;\n&#125;\n\n+ (Class)layerClass&#123;\n    return [TSLayer class];\n&#125;\n\n- (void)setFrame:(CGRect)frame&#123;\n    [super setFrame:frame];\n&#125;\n\n- (void)setPosition:(CGPoint)position&#123;\n    [super setPosition:position];\n&#125;\n\n- (void)setBounds:(CGRect)bounds&#123;\n    [super setBounds:bounds];\n&#125;\n\n创建UIView 可以通过断点可以看到调用的过程\n[TSLayer setBounds:];\n[TSView setFrame:];\n[TSLayer setFrame:];\n[TSLayer setPosetion:];\n[TSLayer setBounds:];\n\n通过上面分析调用过程\nLayer 的设置尺寸和位置并没有调用View 的setCenter 和 setBounds 方法\n修改view的bound.size 或者 bounds.origin 时候调用的是Layer 的一些方法\n\n总结：\n\n\n\n\n\n\n\n\nView 的 Center 和 Bounds 只是直接返回layer 对应的 Position 和 Bounds\nUIView主要是对显示内容的管理，而CALayer主要是对显示的绘制\n\n分别重写UIView的drawRect和CALayer的display方法\n\n在TSView中重写drawRect：\n\n\n可以看到 UIView 是 CALayer 的CALayerDelegate，由此可以猜测是在代理方法内部[UIView(CALayerDelegate) drawLayer:inContext]调用 UIView 的`drawRect``方法，从而绘制出了 UIView 的内容。\n\n每个View都有自己Layer\n\n也有独立的layer 例如CAShapelayer 他们不需要附加到view 上就可以在屏幕上显示内容\n\n一个单独layer 改变任何属性，都会触发从一个从旧值到新值的过程（隐式动画）\n\n改变view 中的layer 属性，直接从当前帧跳到下一帧\n\nUIView默认禁止layer 动画 \n\n当layer 在背后支持一个view时候，view就是它的代理\n\nUIView的尺寸样式，都是有内部Layer提供（CALayerDelegate）``View显示内容取决于CALayer 的display\n\nLayer 内部维护 Layer Tree\n\npresentLayer tree （动画树）\nmodelLayer tree (模型树)\nRender Tree （渲染树）\niOS动画改变属性，是layer 的``presentLayer 属性，最终渲染提供给View 显示是modelLayer Tree`\nlayer可以设置圆角显示（cornerRadius），也可以设置阴影 (shadowColor)。但是如果layer树中某个layer设置了圆角，树种所有layer的阴影效果都将不显示了。因此若是要有圆角又要阴影，变通方法只能做两个重叠的UIView，一个的layer显示圆角，·一个layer显示阴影……\n当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用setNeedsDisplay方法来重绘显示。\n\n\n\n\n","slug":"iOS-UIView和CALayer关系","date":"2021-10-01T12:27:26.000Z","categories_index":"","tags_index":"UIView","author_index":"LittleStart"},{"id":"72c9fa0d926f81572e4b5de9847c1152","title":"《腾讯iOS测试实践》学习（一）","content":"\n\n工程效率\n\n\n\n\n\n\n\n\n 需求评审：需求评审机制以及更新通知，避免需求有改动而没有及时同步到相关角色。\n\n代码质量：静态代码扫描，千行代码缺陷率等。\n架构评审：代码架构的讨论以及评审。\nBug流程：Bug生命周期，避免随便修改Bug状态以及备注缺失。\nCode Review：代码评审，如果有代码评审委员会就更好了。\nDogfood：自己做的产品自己（项目各成员）先体验。\nShowcase：完成某个特性，可以通过会议针对某个特性进行展示，一般由产品经理主持。\n\n测试工程师最主要的工作内容\n测试周期：\n\n测试与研发周期是密切关联的，包括迭代测试、集成测试、回归测试、上线测试等，每个阶段都要把握好测试效率和测试资源分配。\n\n\n测试设计：\n\n包括需求覆盖度、用例覆盖度、用例执行效率等。\n\n\n自动化测试：\n\n使用自动化执行的方式进行测试，可以快速得出测试结果，节省人力成本。\n\n\n静态代码分析：\n\n使用一定的工具来对代码进行静态扫描，提前发现代码隐藏的问题。\n\n\n\n自动化测试\n\n\n\n\n\n\n\n\n业界自动化测试金字塔模型建议做单元测试或者接口测试多于UI自动化测试\n主流自动化测试类型1．BVT（Build Verification Test）业界现在流行持续交付的模式。\n\n那么每次持续集成编译出包后，自动化会运行一些基础功能测试用例，保证版本基础功能可用，而不会因为新代码合入影响基础功能。\n\n2．监控类\n\n我们会对产品进行一些监控，例如手机QQ浏览器（iPhone）项目实现了三种类型的监控测试，即终端视频嗅探监控、终端feeds流短视频可播性监控、终端资讯类监控。这部分监控的基础框架和BVT实现是一致的，只是基于业务形态做了调整，采用的也是EarlGrey框架并进行了二次开发\n\n3．性能自动化测试\n\n性能测试涉及各种数据的采集和分析，而数据采集往往很复杂并且非常耗时，性能自动化测试也都集中在数据采集这一块。目前我们针对页面速度、产品稳定性、电量、流量、内存等各个方面进行性能自动化测试的尝试\n\n静态代码分析\n\n\n\n\n\n\n\n\n静态代码分析就是在不执行代码的情况下，通过一定的算法规则（词法分析、语法分析、单函数分析、代码段分析、数据流分析、资源分析、依赖链分析、更高级的智能逻辑分析）对整个工程的代码进行分析，以此来找出代码中的缺陷。这样就可以提早发现问题，大大降低研发成本\n如果能够在Coding阶段发现大部分缺陷，就能大大降低修复缺陷的成本iOS平台比较好用两款工具\n\nClang的Scan-Build工具（下载地址：http://clang-analyzer.llvm.org/scan-build.html）\nFaceBook的Infer工具（下载地址：https://github.com/facebook/infer）\n\n\n\n\n\n\n\n\n\n\nQQ浏览器（iPhone）项目采用Scan-Build工具发现代码缺陷\n品质管理\n\n\n\n\n\n\n\n\n品质管理分为两大类，即研发品质和线上品质。\n​    一、研发品质\n    - 品质体系（性能指标 + 用户评测）、测试过程数据（Bug、通过率）\n\n​    二、线上品质\n\n线上数据、用户反馈、漏测率\n\n品质体系、除了产品特性、还包含流畅度、内存、耗电量、启动速度、弱网、要考虑各个指标的比重、从而更好优化核心指标\n\n通过预设埋点上报、以及通过用户反馈、对反馈进行分析\n\n代码质量： 代码扫描、架构评审、代码规范、分支覆盖\n\n代码覆盖率： 指行覆盖、类覆盖、条件覆盖、分支覆盖\n\n测试过程数据： 测试通过率、回归通过率\n\n性能指标： 指启动时间、响应时间、内存、流畅度、CPU、耗电量。\n\n用户评测： 指产品进行用户调研、用户体验、用户问卷调查\n\n线上数据： 只上线后的产品数据、启动时间、用户行为数据\n\nBug：指Bug模块分类（FT分布）、Bug各研发阶段数据、Bug分析。\n\n\n例： 下面是腾讯的质量测试\n\n开发质量工作：涉及架构评审、代码规范、代码评审、单元测试、开发自测等。\n测试质量工作：需求评审、用例设计（利用测试建模、测试分析等方法来提升测试设计覆盖度）、自动化测试（BVT或者接口测试等）、性能测试、精准测试、探索式测试、基于风险测试（RBT）、Bug大扫除、Bug分析、Bug统计、众测等。测试质量工作涉及的内容很多，可以考虑再抽练几个分类\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"《腾讯iOS测试实践》学习（一）","date":"2021-10-01T07:06:49.000Z","categories_index":"","tags_index":"测试","author_index":"LittleStart"},{"id":"837320c05a767825bb487e2f2edb4766","title":"block基本结构（一）","content":"block基本结构\nblock 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成\n在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类\nimpl 是实际的指针函数、本例中，它指向 _main_block_func_0 这里面 _impl 相当于以前的invoke 变量\ndescriptor 是描述这个block的附加信息，包括结构体大小、需要 capture 和 dispose 的变量列表等、结构体大小需要保存的原因\n\n\n\n\n\n1，在MRC 时代，__block 修饰，可以避免循环引用；ARC时代，__block 修饰，同样会引起循环引用问题； \n2，__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型； __\n3，weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；\n 4，__block对象可以在block中被重新赋值，__weak不可以； \n5，__unsafe_unretained修饰符可以被视为iOS SDK 4.3以前版本的__weak的替代品，不过不会被自动置空为nil。所以尽可能不要使用这个修饰符。(__weak 会自动置为nil)\n_weak与__block区别\n问到 block 避免循环引用的问题时，发现好多人都说通过添加 __block 修饰词来避免。再加上我对__block和__weak也没有区分的太明确，搞得我都有点儿怀疑我自己以前是不是用错了。正好借这个机会来一探究竟~\n首先我定义了一个类 MyObject 继承 NSObject，并添加了一个属性 text，重写了description方法，返回 text 的值。这个主要是因为编译器本身对 NSString 是有优化的，创建的 string 对象有可能是静态存储区永不释放的，为了避免使用 NSString 引起一些问题，还是创建一个 NSObject 对象比较合适。\n","slug":"Block底层实现原理","date":"2021-10-01T02:06:49.000Z","categories_index":"","tags_index":"block","author_index":"LittleStart"},{"id":"69226c43fa619d7df7756bf099da8b7a","title":"iOS设计模式（一）","content":"类继承和对象组合\n类继承简单直接、关系在编译时静态定义\n被复用的实现易于修改\n\n缺点：\n\n因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现\n子类描述在父类、\n子类直接面对父类的封装、因此破坏了封装\n父类实现的任何变更都会强制爱子类到的变更\n因为在新的问题场景下京城实现过时或者不使用，所以必须重写父类或继承来实现\n\n只从协议或者抽象的基类继承、应为他们只有很少的实现，而协议没有\n对象组合让我们同时使用多个对象，而每个对象都假定其他对象接口正常运行，\n优点：\n不会破坏封装，只能通过接口来访问对象\n大大减少实现的依存关系、因为对象实现是通过接口定义的\n可以运行时任意对象替换为其他同类型对象\n有助于保持类的封装、以专注单一任务\n类及其层次结构能保持简洁，不至于过度膨胀而无法管理\n\n\n缺点：\n设计中涉及较多对象\n系统的行为将依赖于不同对象间的关系、而不是定义在单个类中\n\n\n\n\n\n\n\n\n\n\n\n\n优先使用对象组合而不是类继承、类继承与对象可以配合，找出冗余设计，此处应该使用类继承。\n\n圆角 ： 类实体\n抽象斜体\n抽象\n\n\n","slug":"iOS设计模式（一）","date":"2021-09-30T12:30:53.000Z","categories_index":"","tags_index":"设计模式","author_index":"LittleStart"},{"id":"78bacd8b33e55bbfb6a2cbf684cbf20b","title":"单元测试","content":"别测试代码，而应该验证程序的行为测试应该只在程序的行为和预期的不一样时，才不通过。测试应该测试程序的代码做了什么，而不是测试程序如何实现。\n\n验证应用程序做了什么的，叫做行为测试。\n即使应用程序的行为不发生变化，只要应用程序的代码发生了变化，测试就不通过的，叫做脆性测试。\n\n假设我们有一个香蕉数据库，叫做 GorillaDB。GorillaDB 是一个以键－值对来储存香蕉的数据库。我们可以用这样的方式储存香蕉：\nlet database = GorillaDB()\nlet banana = Banana()\ndatabase.save(banana: banana, key: \"my-banana\")\n\n之后可以从数据库里取回香蕉：\nlet banana = database.load(key: \"my-banana\")\n\n行为测试编写行为测试的关键，就是准确的定位你想让你的程序代码做什么。\n在我们的 testSave_savesTheBananaToTheDatabase 的测试中：当我们在数据库中储存一根香蕉时，我们所希望程序完成的是一个怎样的行为呢？应该是保存香蕉，即之后可以取回香蕉。因此，我们不该测试数据库大小的增加，而应该测试我们能不能从数据库里取回香蕉。\n编写行为测试的关键，就在于思考这些问题：\n\n这段程序代码是用来做什么的？\n我的测试只验证了程序的行为吗？它可能因为代码运行的其他原因而不通过吗？\n\nNimber 断言expect(1 + 1).to(equal(2))\nexpect(1.2).to(beCloseTo(1.1, within: 0.1))\nexpect(3) > 2\nexpect(\"seahorse\").to(contain(\"sea\"))\nexpect([\"Atlantic\", \"Pacific\"]).toNot(contain(\"Mississippi\"))\nexpect(ocean.isClean).toEventually(beTruthy())\n\n用 Quick 例子和例子群组织测试Quick 使用特殊的语法定义例子（examples）和例子群（example groups）。\n在*编写高效的 XCTest 测试: Arrange，Act 和 Assert*，我们了解了一个好的测试方法名称是至关重要的，尤其是当测试失败时。它能够帮助我们判断是修改程序代码或者是更新测试内容。\nQuick 的例子和例子群主要有两个目的：\n\n它们促使你使用具有描述性的测试名称。\n它们极大地简化了 Arrange 步骤的测试代码。\n\n例子：使用 it定义了 it 函数的例子，使用断言代码指明了程序应有的行为。这些就像 XCTest 中的测试方法一样。\nit 函数有两个参数：例子的名称和闭包。下面这个例子具体说明了 Sea.Dolphin 类应有的行为。 一只新的海豚（dolphin）应该是聪明（smart）且友好（friendly）的：\n// Swift\n\nimport Quick\nimport Nimble\nimport Sea\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    it(\"is friendly\") &#123;\n      expect(Dolphin().isFriendly).to(beTruthy())\n    &#125;\n\n    it(\"is smart\") &#123;\n      expect(Dolphin().isSmart).to(beTruthy())\n    &#125;\n  &#125;\n&#125;\n// Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\nit(@\"is friendly\", ^&#123;\n  expect(@([[Dolphin new] isFriendly])).to(beTruthy());\n&#125;);\n\nit(@\"is smart\", ^&#123;\n  expect(@([[Dolphin new] isSmart])).to(beTruthy());\n&#125;);\n\nQuickSpecEnd\n\n用描述性的语言使例子所测试的内容清晰明了。 描述性的语言可以是任意长度、任意字符的，涵盖了英语以及其他语言的字符，甚至可以是表情符号！✌️ 😎\n例子群：使用 describe 和 context例子群是按一定逻辑关系组织的例子。例子群里可以共享配置（setup）和卸载（teardown）代码。\n使用 describe 描述类和方法为了具体说明 Dolphin 类中 click 方法的行为 —— 换句话说，为了验证这个方法可用 —— 我们可以把多个 it 例子用 describe 函数组织成为一个群。把相同的例子组织在一起能更方便阅读：\n// Swift\n\nimport Quick\nimport Nimble\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    describe(\"a dolphin\") &#123;\n      describe(\"its click\") &#123;\n        it(\"is loud\") &#123;\n          let click = Dolphin().click()\n          expect(click.isLoud).to(beTruthy())\n        &#125;\n\n        it(\"has a high frequency\") &#123;\n          let click = Dolphin().click()\n          expect(click.hasHighFrequency).to(beTruthy())\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n// Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\ndescribe(@\"a dolphin\", ^&#123;\n  describe(@\"its click\", ^&#123;\n    it(@\"is loud\", ^&#123;\n      Click *click = [[Dolphin new] click];\n      expect(@(click.isLoud)).to(beTruthy());\n    &#125;);\n\n    it(@\"has a high frequency\", ^&#123;\n      Click *click = [[Dolphin new] click];\n      expect(@(click.hasHighFrequency)).to(beTruthy());\n    &#125;);\n  &#125;);\n&#125;);\n\nQuickSpecEnd\n\n当这两个例子在 Xcode 中运行的时候，它们会从 describe 和 it 函数中输出一些描述性的语言：\n\nDolphinSpec.a_dolphin_its_click_is_loud\nDolphinSpec.a_dolphin_its_click_has_a_high_frequency\n\n显然，这两个测试各自测试的内容都很清晰明了。\n使用 beforeEach 和 afterEach 共享配置／卸载代码例子群不仅使它包含的例子更清晰易懂，还有助于在群里共享配置和卸载的代码。\n在下面的这个示例里，例子群中的每一个例子前面，都用 beforeEach 这个函数创建一种新类型的海豚以及它特定的叫声。 这就保证了对每个例子进行了初始化：\n&#x2F;&#x2F; Swift\n\nimport Quick\nimport Nimble\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    describe(&quot;a dolphin&quot;) &#123;\n      var dolphin: Dolphin!\n      beforeEach &#123;\n        dolphin &#x3D; Dolphin()\n      &#125;\n\n      describe(&quot;its click&quot;) &#123;\n        var click: Click!\n        beforeEach &#123;\n          click &#x3D; dolphin.click()\n        &#125;\n\n        it(&quot;is loud&quot;) &#123;\n          expect(click.isLoud).to(beTruthy())\n        &#125;\n\n        it(&quot;has a high frequency&quot;) &#123;\n          expect(click.hasHighFrequency).to(beTruthy())\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\ndescribe(@&quot;a dolphin&quot;, ^&#123;\n  __block Dolphin *dolphin &#x3D; nil;\n  beforeEach(^&#123;\n      dolphin &#x3D; [Dolphin new];\n  &#125;);\n\n  describe(@&quot;its click&quot;, ^&#123;\n    __block Click *click &#x3D; nil;\n    beforeEach(^&#123;\n      click &#x3D; [dolphin click];\n    &#125;);\n\n    it(@&quot;is loud&quot;, ^&#123;\n      expect(@(click.isLoud)).to(beTruthy());\n    &#125;);\n\n    it(@&quot;has a high frequency&quot;, ^&#123;\n      expect(@(click.hasHighFrequency)).to(beTruthy());\n    &#125;);\n  &#125;);\n&#125;);\n\nQuickSpecEnd\n\n对于海豚这个例子来说，像这样共享配置代码并不是一个很大的工程。但是对于更复杂的对象，共享代码能够省去大量写代码的时间！\n如果想在每个例子后面执行特定的代码，可以使用 afterEach。\n使用 context 指定条件的行为海豚使用叫声进行回声定位。当接近了它们感兴趣的东西时，海豚会发出一系列的超声波对其进行更准确的探测。\n这个测试需要展示在不同环境下，click 方法的不同行为。通常，海豚只叫（click）一声。但是当海豚接近它们感兴趣的东西时，它会发出很多次叫声。\n这种情况可以用 context 函数来表示：一个 context 代表正常情况，另一个 context 代表海豚接近感兴趣的东西：\n&#x2F;&#x2F; Swift\n\nimport Quick\nimport Nimble\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    describe(&quot;a dolphin&quot;) &#123;\n      var dolphin: Dolphin!\n      beforeEach &#123; dolphin &#x3D; Dolphin() &#125;\n\n      describe(&quot;its click&quot;) &#123;\n        context(&quot;when the dolphin is not near anything interesting&quot;) &#123;\n          it(&quot;is only emitted once&quot;) &#123;\n            expect(dolphin.click().count).to(equal(1))\n          &#125;\n        &#125;\n\n        context(&quot;when the dolphin is near something interesting&quot;) &#123;\n          beforeEach &#123;\n            let ship &#x3D; SunkenShip()\n            Jamaica.dolphinCove.add(ship)\n            Jamaica.dolphinCove.add(dolphin)\n          &#125;\n\n          it(&quot;is emitted three times&quot;) &#123;\n            expect(dolphin.click().count).to(equal(3))\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\ndescribe(@&quot;a dolphin&quot;, ^&#123;\n  __block Dolphin *dolphin &#x3D; nil;\n  beforeEach(^&#123; dolphin &#x3D; [Dolphin new]; &#125;);\n\n  describe(@&quot;its click&quot;, ^&#123;\n    context(@&quot;when the dolphin is not near anything interesting&quot;, ^&#123;\n      it(@&quot;is only emitted once&quot;, ^&#123;\n        expect(@([[dolphin click] count])).to(equal(@1));\n      &#125;);\n    &#125;);\n\n    context(@&quot;when the dolphin is near something interesting&quot;, ^&#123;\n      beforeEach(^&#123;\n        [[Jamaica dolphinCove] add:[SunkenShip new]];\n        [[Jamaica dolphinCove] add:dolphin];\n      &#125;);\n\n      it(@&quot;is emitted three times&quot;, ^&#123;\n        expect(@([[dolphin click] count])).to(equal(@3));\n      &#125;);\n    &#125;);\n  &#125;);\n&#125;);\n\nQuickSpecEnd\n\n严格地说，context 是 describe 的一种同义的表达，但是像这样有目的地使用能够让你的代码更容易理解。\n测试的可读性：Quick 和 XCTest在*编写高效的 XCTest 测试: Arrange，Act 和 Assert*里，我们知道了对每种情况进行一个测试能够很方便地组织测试代码。 在 XCTest 里，这样做会导致出现冗长的测试方法名称：\nfunc testDolphin_click_whenTheDolphinIsNearSomethingInteresting_isEmittedThreeTimes() &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\n使用 Quick ，每种情况会更容易阅读，并且我们能够为每一个例子群进行配置：\ndescribe(\"a dolphin\") &#123;\n  describe(\"its click\") &#123;\n    context(\"when the dolphin is near something interesting\") &#123;\n      it(\"is emitted three times\") &#123;\n        // ...\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n临时禁用例子或例子群你可以临时禁用那些测试不通过的例子和例子群。 这些例子的名称会随着测试结果一起打印在控制台里，但它们并不运行。\n通过添加前缀 x 就能禁用例子或例子群：\n&#x2F;&#x2F; Swift\n\nxdescribe(&quot;its click&quot;) &#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;\n\nxcontext(&quot;when the dolphin is not near anything interesting&quot;) &#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;\n\nxit(&quot;is only emitted once&quot;) &#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;\n&#x2F;&#x2F; Objective-C\n\nxdescribe(@&quot;its click&quot;, ^&#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;);\n\nxcontext(@&quot;when the dolphin is not near anything interesting&quot;, ^&#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;);\n\nxit(@&quot;is only emitted once&quot;, ^&#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;);\n\n临时运行一部分例子在某些情况下，只关注一个或几个例子有助于测试。毕竟只运行一两个例子比运行整个测试快多了。通过使用 fit 函数，你可以只运行一两个例子。你还可以使用 fdescribe 或 fcontext 把测试重点放在一个例子群：\nfit(&quot;is loud&quot;) &#123;\n  &#x2F;&#x2F; ...only this focused example will be run.\n&#125;\n\nit(&quot;has a high frequency&quot;) &#123;\n  &#x2F;&#x2F; ...this example is not focused, and will not be run.\n&#125;\n\nfcontext(&quot;when the dolphin is near something interesting&quot;) &#123;\n  &#x2F;&#x2F; ...examples in this group are also focused, so they&#39;ll be run.\n&#125;\nfit(@&quot;is loud&quot;, &#123;\n  &#x2F;&#x2F; ...only this focused example will be run.\n&#125;);\n\nit(@&quot;has a high frequency&quot;, ^&#123;\n  &#x2F;&#x2F; ...this example is not focused, and will not be run.\n&#125;);\n\nfcontext(@&quot;when the dolphin is near something interesting&quot;, ^&#123;\n  &#x2F;&#x2F; ...examples in this group are also focused, so they&#39;ll be run.\n&#125;);\n\n使用 beforeSuite 和 afterSuite 进行全局配置／卸载有一些测试的配置需要在所有例子运行之前进行。对于这种情况，可以使用 beforeSuite 和 afterSuite 。\n下面的示例展示了在所有其他例子运行之前，创建一个包含了海洋中所有生物的数据库。当所有例子运行结束的时候，这个数据库就被卸载：\n&#x2F;&#x2F; Swift\n\nimport Quick\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    beforeSuite &#123;\n      OceanDatabase.createDatabase(name: &quot;test.db&quot;)\n      OceanDatabase.connectToDatabase(name: &quot;test.db&quot;)\n    &#125;\n\n    afterSuite &#123;\n      OceanDatabase.teardownDatabase(name: &quot;test.db&quot;)\n    &#125;\n\n    describe(&quot;a dolphin&quot;) &#123;\n      &#x2F;&#x2F; ...\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; Objective-C\n\n@import Quick;\n\nQuickSpecBegin(DolphinSpec)\n\nbeforeSuite(^&#123;\n  [OceanDatabase createDatabase:@&quot;test.db&quot;];\n  [OceanDatabase connectToDatabase:@&quot;test.db&quot;];\n&#125;);\n\nafterSuite(^&#123;\n  [OceanDatabase teardownDatabase:@&quot;test.db&quot;];\n&#125;);\n\ndescribe(@&quot;a dolphin&quot;, ^&#123;\n  &#x2F;&#x2F; ...\n&#125;);\n\nQuickSpecEnd\n\n你可以添加多个 beforeSuite 和 afterSuite 。所有的 beforeSuite 闭包都会在其它测试运行前执行，同样，所有的 afterSuite 闭包都会在其它测试运行结束后执行。 但是这些闭包并不一定按先后顺序执行。\n访问当前例子的元数据在某些情况下，你会想知道当前运行的例子的名称，或者目前已经运行了多少例子。Quick 提供了闭包 beforeEach 和 afterEach ，通过这些闭包，可以访问元数据。\nbeforeEach &#123; exampleMetadata in\n  println(&quot;Example number \\(exampleMetadata.exampleIndex) is about to be run.&quot;)\n&#125;\n\nafterEach &#123; exampleMetadata in\n  println(&quot;Example number \\(exampleMetadata.exampleIndex) has run.&quot;)\n&#125;\nbeforeEachWithMetadata(^(ExampleMetadata *exampleMetadata)&#123;\n  NSLog(@&quot;Example number %l is about to be run.&quot;, (long)exampleMetadata.exampleIndex);\n&#125;);\n\nafterEachWithMetadata(^(ExampleMetadata *exampleMetadata)&#123;\n  NSLog(@&quot;Example number %l has run.&quot;, (long)exampleMetadata.exampleIndex);\n&#125;);\n\nNimber 断言函数列举Nimble中的匹配函数\n用途    函数等值判断使用equal函数\nexpect(actual).to(equal(expected))\nexpect(actual) == expected\nexpect(actual) != expected\n是否是同一个对象\n使用beIdenticalTo函数\nexpect(actual).to(beIdenticalTo(expected))\nexpect(actual) === expected\nexpect(actual) !== expected\n比较expect(actual).to(beLessThan(expected))\nexpect(actual) &lt; expected\nexpect(actual).to(beLessThanOrEqualTo(expected))\nexpect(actual) &lt;= expected\nexpect(actual).to(beGreaterThan(expected))\nexpect(actual) &gt; expected\nexpect(actual).to(beGreaterThanOrEqualTo(expected)) expect(actual) &gt;= expected\n比较浮点数expect(10.01).to(beCloseTo(10, within: 0.1))\n类型检查\nexpect(instance).to(beAnInstanceOf(aClass)) expect(instance).to(beAKindOf(aClass))\n是否为真\n// Passes if actual is not nil, true, or an object with a boolean value of true:\nexpect(actual).to(beTruthy())\n// Passes if actual is only true (not nil or an object conforming to BooleanType true):\nexpect(actual).to(beTrue())\n// Passes if actual is nil, false, or an object with a boolean value of false:\nexpect(actual).to(beFalsy())\n// Passes if actual is only false (not nil or an object conforming to BooleanType false):\nexpect(actual).to(beFalse())\n// Passes if actual is nil:\nexpect(actual).to(beNil())\n是否有异常\n// Passes if actual, when evaluated, raises an exception: expect(actual).to(raiseException())\n// Passes if actual raises an exception with the given name:\nexpect(actual).to(raiseException(named: name))\n// Passes if actual raises an exception with the given name and reason:\nexpect(actual).to(raiseException(named: name, reason: reason))\n// Passes if actual raises an exception and it passes expectations in the block\n// (in this case, if name begins with ‘a r’)\nexpect { exception.raise() }.to(raiseException { (exception: NSException) in\n expect(exception.name).to(beginWith(&quot;a r&quot;))\n\n})\n集合关系\n// Passes if all of the expected values are members of actual:\nexpect(actual).to(contain(expected…))\nexpect([“whale”, “dolphin”, “starfish”]).to(contain(“dolphin”, “starfish”))\n// Passes if actual is an empty collection (it contains no elements):\nexpect(actual).to(beEmpty())\n字符串\n// Passes if actual contains substring expected: expect(actual).to(contain(expected))\n// Passes if actual begins with substring: expect(actual).to(beginWith(expected))\n// Passes if actual ends with substring: expect(actual).to(endWith(expected))\n// Passes if actual is an empty string, “”: expect(actual).to(beEmpty())\n// Passes if actual matches the regular expression defined in expected:\nexpect(actual).to(match(expected))\n检查集合中的所有元素是否符合条件\n// with a custom function:\nexpect([1,2,3,4]).to(allPass({$0 &lt; 5}))\n// with another matcher: expect([1,2,3,4]).to(allPass(beLessThan(5)))\n检查集合个数\nexpect(actual).to(haveCount(expected))\n匹配任意一种检查\n// passes if actual is either less than 10 or greater than 20 expect(actual).to(satisfyAnyOf(beLessThan(10), beGreaterThan(20)))\n// can include any number of matchers – the following will pass\nexpect(6).to(satisfyAnyOf(equal(2), equal(3), equal(4), equal(5), equal(6), equal(7)))\n// in Swift you also have the option to use the || operator to achieve a similar function expect(82).to(beLessThan(50) || beGreaterThan(80))\n————————————————\n","slug":"unit-test","date":"2021-07-13T03:32:17.000Z","categories_index":"","tags_index":"单元测试","author_index":"LittleStart"},{"id":"08c633a5de2fe3edfdf41cfdec1b1bae","title":"iOS 组件化拆分总结","content":"组件化一、为何要组件化?\n\n\n\n\n\n\n\n\n这是我们在做组件化的时候要思考的，它的优点和缺点是什么，这样我们对组件化有个基本认识\n1. 组件化定义\n组件是由一个或多个类构成，能完整描述一个业务场景，并能被其他业务场景复用的功能单位。\n比如内存，硬盘，CPU，显示器等，拿出其中任何一个部件都能被其他的PC所使用。\n日志服务，VOIP服务，内存管理服务等等。说白了我们目标是站在更高的维度去封装功能单元。对这些功能单元进行进一步的分类，才能在具体的业务场景下做更合理的设计。\n\n2. 组件化实施条件\n前期项目比较小，可以按照原有传统的方式进行开发\n随着项目的功能变的复杂，团队扩大，会发现传统的开发方式导致代码管理混乱，发布、集成、测试越来越麻烦，被迫走向组件化的道路\n如果你的团队在不断发展，产品线也越来越多的时候，预计后期可能会更多的时候，那么最好尽早把组件化拆分\n把一些业务、基础功能剥离，划分为一个个的模块，然后通过pods的方式管理而已，同时要搭配一套后台的自动集成、发布、测试流程\n\n3. 普通模式存在问题\n代码冲突多，编译慢。\n迭代速度慢，耦合比较严重，无法单独测试。\n\n4. 组件化优点\n\n\n\n\n\n\n\n\n组件化就是把整个项目进行拆分，分成一个个单独的可独立运行的组件，分开管理，减少依赖。\n\n加快编译速度，可以把不会经常变动的组件做成静态库，同时每个组件可以独立编译，不依赖于主工程或者其他组件\n\n每个组件都可以选择自己擅长的开发模式（MVC / MVVM / MVP）\n\n可以单独测试每个组件\n\n多条业务线可以并行开发，提高开发效率\n\n\n\n\n\n\n\n\n\n\n\n组件化方案在App业务稳定，且规模（业务规模和开发团队规模）增长初期去实施非常重要，它助于将复杂App分而治之，也有助于多人大型团队的协同开发。但组件化方案不适合在业务不稳定的情况下过早实施，至少要等产品已经经过MVP阶段时才适合实施组件化。因为业务不稳定意味着链路不稳定，在不稳定的链路上实施组件化会导致将来主业务产生变化时，全局性模块调度和重构会变得相对复杂。\n总结：\n业务稳定的模块先进行组件化，业务在变化的随着业务稳定之后再做抽离组件化\n\n组件化方案\n\n\n\n\n\n\n\n\n 看上去各家都是各显神通，都有自己的技术方案，但是实际上都可以归类到如下两种方案：\n\n利用runtime实现的target-action方法\n利用url-scheme方案\n\nURL-Scheme库：\n\nJLRoutes\nroutable-ios\nHHRouter\nMGJRouter\nFRDIntent/Intent\n\nTarget-Action库：\n\nCTMediator\n\n路由的设计思路\nURL-Sheme方案一般都是各个组件把自己可以提供的服务通过url的形式注册到一个中心管理器，然后调用发就可以通过openURL的方式来打开这个url，然后中心管理器解析这个url，把请求转发到相应的组件去执行\nTarget-Action方案利用了OC的runtime特性，无需注册，直接在原有的组件之外加一层wrapper，把对外提供的服务都抽离到该层。然后通过runtime的TARGET performSelector:ACTION withObject:PARAMS找到对应的组件，执行方法和传递参数。\n\n实施步骤\n模块化是一个浩大的工程，对于项目有着重大影响。我们在确定目标之后，接着制定了有一个详细的计划。然后按计划一步步实施。\n第一个要解决的问题就是如何拆分组件。这是一个见仁见智的问题，没有太明确的划分边界，大致做到每个组件只包含一个功能即可，具体实施还是要根据实际情况权衡。\n站在更高的维度去封装功能单元，把多个功能单元组合在一起形成一个更大的功能单元，也就是组件。对这些功能单元进行进一步的分类，才能在具体的业务场景下做更合理的设计。\n\n1. 文件夹隔离\n\n\n\n\n\n\n\n\n\n 我们首先需要改变项目的文件组织结构\n\n项目简单地以 View / Controller / Model 划分各类文件。\n\n现在改为每个功能模块都有自己如下模块文件夹，从而先实现文件夹隔离\n\nView \nController\nViewModel\nModel\nNetwork \n\n\n虽然改为按模块组织项目的文件结构，但此时，所有模块仍然还在一个仓库里。这其实只是做到了文件夹隔离，代码并没有被真正隔离\n\n我们会查看各个文件的 #import 部分，减少业务模块间的相互依赖。几个业务模块都用到的文件，则会沉入到公共层\n\n文件夹隔离也为团队提供了一个转变开发方式的缓冲期\n\n文件夹隔离使得组员逐步适应模块化的思维，后续的产品功能也被归入到对应的模块之中\n\n\n2. 抽象出业务无关的库\n我们同时也鼓励将一些业务无关的代码抽象成一个个独立的库。这类库应该是与产品无关，与业务无关的。\n\n拆分出去的模块，必须先处理好它的依赖，它将只能依赖已经拆分出去的组件和第三方库。\n拆分独立的库使得复用成为了可能，我们可以在新项目中使用\n\n3.  拆分公共模块\n\n包括了业务模块所需要的一些公共代码，但是要么是和业务关系较大，要么就是还没到可以抽象成一个库的程度\n我们开始按由容易到困难的顺序拆分各个业务模块\n\n4.  页面跳转解耦\n\n豆瓣开源方案： FRDIntent/Intent  https://github.com/douban/FRDIntent\n 我们开始按由容易到困难的顺序拆分各个业务模块\n\n5.  FRDIntent/Intent 有如下优势：\n\n充分解耦。调用者和被调用者完全隔离，调用者只需要依赖协议：FRDIntentReceivable。一个 UIViewControlller 符合该协议即可被启动。\n对于“启动一个页面，并从该页面获取结果”这种较普遍的需求提供了一个通用的解决方案。具体查看方法：startControllerForResult。这是对 Android 中 startActivityForResult 的模仿和简化。\n支持自定义转场动画。\n支持传递复杂数据对象。\n\n\n组件化方案主要是基于Mediator模式和Target-Action模式，中间采用了runtime来完成调用。这套组件化方案将远程应用调用和本地应用调用做了拆分，而且是由本地应用调用为远程应用调用提供服务，与蘑菇街方案正好相反。\n本地调用\n[[CTMediator sharedInstance] performTarget:targetName action:actionName params:@&#123;...&#125;]向CTMediator发起跨组件调用，CTMediator根据获得的target和action信息，通过objective-C的runtime转化生成target实例以及对应的action选择子，然后最终调用到目标业务提供的逻辑，完成需求。\n\n远程调用\nAppDelegate接收到URL之后，调用CTMediator的openUrl:方法将接收到的URL信息传入。当然，CTMediator也可以用openUrl:options:的方式顺便把随之而来的option也接收，这取决于你本地业务执行逻辑时的充要条件是否包含option数据。传入URL之后，CTMediator通过解析URL，将请求路由到对应的target和action\n\n组件间调用方式所有组件都通过组件自带的Target-Action来响应，也就是说，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。\n组件参数传递\n非常规参数是包含非常规类型的参数。\n非常规类型的定义就是不能被json解析的类型都叫非常规类型。\n\n本地组件间调用来支持远程应用调用\n通过performTarget:action:params:是能够提供非常规参数的，于是我们可以知道，远程App调用时的上下文环境以及功能是本地组件间调用时上下文环境以及功能的子集。\n远程App调用只能走CTMediator提供的专用远程的方法，本地组件间调用只能走CTMediator提供的专用本地的方法，两者不能通过同一个接口来调用。\n\n组件化去Model\n组件间调用时，是需要针对参数做去model化的。如果组件间调用不对参数做去model化的设计，就会导致业务形式上被组件化了，实质上依然没有被独立。\n\n假设模块A和模块B之间采用model化的方案去调用，那么调用方法时传递的参数就会是一个对象。\n\n\n使用对象化的参数无论是否面向接口，带来的结果就是业务模块形式上是被组件化了，但实质上依然没有被独立。\n跨模块调用\n以字典的方式去传递。这样就能够做到只有调用方依赖mediator，而响应方不需要依赖mediator\n在去model的组件化方案中，影响效率的点有两个：调用方如何知道接收方需要哪些key的参数？调用方如何知道有哪些target可以被调用？其实后面的那个问题不管是不是去model的方案，都会遇到。\n为什么放在一起说，因为我接下来要说的解决方案可以把这两个问题一起解决。\n\n解决方案\n\n\n\n\n\n\n\n\n通mediator这个repo维护了若干个针对mediator的category，每一个对应一个target，每个category里的方法对应了这个target下所有可能的调用场景，这样调用者在包含mediator的时候，自动获得了所有可用的target-action，无论是调用还是参数传递，都非常方便。接下来我要解释一下为什么是category而不是其他：\n\ncategory本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用category封装是很合理的。\n在category的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category就提供了补救的入口。\ncategory可以很轻松地做请求转发，如果不采用category，请求转发逻辑就非常难做了。\ncategory统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。\n由于category统一了所有的调用入口，使得在跨模块调用时，对于param的hardcode在整个App中的作用域仅存在于category中，在这种场景下的hardcode就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。\n\n\n\n\n\n项目组件化拆分传统项目结构\n\n\n\n![截屏2021-06-18 下午2.46.07](iOS-component/截屏2021-06-18 下午2.46.07.png)\n![截屏2021-06-18 上午10.40.36](iOS-component/截屏2021-06-18 上午10.40.36.png)\n\n\n\n@interface A_VC : UIViewController\n  \n  -(void)action_A:(NSString*)para1;\n\n@end\n       \nimport &quot;A_VC.h&quot;\n@implementation A_VC\n\n-(void)action_A:(NSString*)para1 &#123;\n  NSLog(@&quot;call action_A %@&quot;,para1);\n&#125;\n       \n@end\n       \n \n@interface B_VC : UIViewController\n       \n  -(void)action_B:(NSString*)para1 para2:(NSInteger)para2;\n       \n@end\n       \n            \nimport &quot;B_VC.h&quot;     \n@implementation B_VC\n\n-(void)action_B:(NSString*)para1 para2:(NSInteger)para2&#123;\n        NSLog(@&quot;call action_B %@---%zd&quot;,para1,para2);\n&#125;\n@end\n\n@interface Mediator : NSObject\n-(void)A_VC_Action:(NSString*)para1;\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2;\n+ (instancetype)sharedInstance;\n\n@end\n\nimport &quot;Mediator.h&quot;\n\n@implementation Mediator\n\n+ (instancetype)sharedInstance &#123;\n\tstatic Mediator *mediator;\n  static dispatch_once_t onceToken;\n  dispatch_once(&amp;onceToken, ^&#123;\n    mediator &#x3D; [[Mediator alloc] init];\n  &#125;);\n  return mediator;\n&#125;\n\n-(void)A_VC_Action:(NSString*)para1 &#123;\n  Class cls &#x3D; NSClassFromString(@&quot;A_VC&quot;);\n  NSObject *target &#x3D; [[cls alloc] init];\n  [target performSelector: NSSelectorFromString(@&quot;action_A:&quot;) withObject:para1];\n&#125;\n\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2&#123;\n  Class cls &#x3D; NSClassFromString(@&quot;B_VC&quot;);\n  NSObject *target &#x3D; [[cls alloc] init];\n  [target performSelector: NSSelectorFromString(@&quot;action_B:para2:&quot;) withObject: para1 withObject: para2];\n&#125;\n\n@end\n       \n\n组件之间调用&gt; B 调用 A \n[[Mediator sharedInstance] A_VC_Action:@&quot;参数1&quot; ];\n&gt;  A 调用 B\n[[Mediator sharedInstance] B_VC_Action:@&quot;参数1&quot; para2: 123];\n\n反思\n看到这里，大概有人会问，既然用runtime就可以解耦取消依赖，那还要Mediator做什么？我直接在每个组件里面用runtime调用其他组件不就完了吗，干嘛还要多一个mediator？\n但是这样做会存在如下问题：\n\n调用者写起来很恶心，代码提示都没有， 参数传递非常恶心，每次调用者都要查看文档搞清楚每个参数的key是什么，然后自己去组装成一个 NSDictionary。维护这个文档和每次都要组装参数字典很麻烦。\n当调用的组件不存在的时候，没法进行统一处理\n\n那么加一个mediator的话，就可以做到：\n\n调用者写起来不恶心，代码提示也有了, 参数类型明确。\nMediator可以做统一处理，调用某个组件方法时如果某个组件不存在，可以做相应操作，让调用者与组件间没有耦合。\n\n改进\n聪明的读者可能已经发现上面的mediator方案还是存在一个小瑕疵，受限于performselector方法，最多只能传递两个参数，如果我想传递多个参数怎么办呢？\n答案是使用字典进行传递，此时我们还需要个组件增加一层wrapper，把对外提供的业务全部包装一次，并且接口的参数全部改成字典。 假设我们现在的B组件需要接受多个参数，如下所示：\n-(void)action_B:(NSString*)para para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    NSLog(@&quot;call action_B %@---%zd---%zd----%zd&quot;,para1,para2,para3,para4);\n&#125;\n\n那么此时需要对B组件增加一层wrapper，如下：#import @interface target_B : NSObject\n-(void)B_Action:(NSDictionary*)para;\n\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n#import &quot;target_B.h&quot;\n#import &quot;B_VC.h&quot;\n\n@implementation target_B\n\n-(void)B_Action:(NSDictionary*)para&#123;\n    NSString *para1 &#x3D; para[@&quot;para1&quot;];\n    NSInteger para2 &#x3D; [para[@&quot;para2&quot;]integerValue];\n    NSInteger para3 &#x3D; [para[@&quot;para3&quot;]integerValue];\n    NSInteger para4 &#x3D; [para[@&quot;para4&quot;]integerValue];\n    B_VC *VC &#x3D; [B_VC new];\n    [VC action_B:para1 para2:para2 para3:para3 para4:para4];\n&#125;\n@end\n\n此时mediator也需要做相应的更改，由原来直接调用组件B，改成了调用B的wrapper层：-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    Class cls &#x3D; NSClassFromString(@&quot;target_B&quot;);\n    NSObject *target &#x3D; [[cls alloc]init];\n    [target performSelector:NSSelectorFromString(@&quot;B_Action:&quot;) withObject:@&#123;@&quot;para1&quot;:para1, @&quot;para2&quot;:@(para2),@&quot;para3&quot;:@(para3),@&quot;para4&quot;:@(para4)&#125; ];\n&#125;\n\n\n\n\n\n继续改进\n做到这里，看似比较接近我的要求了，但是还有有点小瑕疵：\n\nMediator 每一个方法里都要写 runtime 方法，格式是确定的，这是可以抽取出来的。\n每个组件对外方法都要在 Mediator 写一遍，组件一多 Mediator 类的长度是恐怖的。\n\n接着优化就是casa的方案了，我们来看看如何改进，直接看代码：\n针对第一点，我们可以抽出公共代码，当做mediator：\n#import &quot;CTMediator.h&quot;\n#import @interface CTMediator ()\n\n@property (nonatomic, strong) NSMutableDictionary *cachedTarget;\n\n@end\n\n@implementation CTMediator\n\n#pragma mark - public methods\n+ (instancetype)sharedInstance\n&#123;\n    static CTMediator *mediator;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        mediator &#x3D; [[CTMediator alloc] init];\n    &#125;);\n    return mediator;\n&#125;\n\n&#x2F;*\n scheme:&#x2F;&#x2F;[target]&#x2F;[action]?[params]\n\n url sample:\n aaa:&#x2F;&#x2F;targetA&#x2F;actionB?id&#x3D;1234\n *&#x2F;\n\n- (id)performActionWithUrl:(NSURL *)url completion:(void (^)(NSDictionary *))completion\n&#123;\n    NSMutableDictionary *params &#x3D; [[NSMutableDictionary alloc] init];\n    NSString *urlString &#x3D; [url query];\n    for (NSString *param in [urlString componentsSeparatedByString:@&quot;&amp;&quot;]) &#123;\n        NSArray *elts &#x3D; [param componentsSeparatedByString:@&quot;&#x3D;&quot;];\n        if([elts count] &lt; 2) continue;\n        [params setObject:[elts lastObject] forKey:[elts firstObject]];\n    &#125;\n\n    &#x2F;&#x2F; 这里这么写主要是出于安全考虑，防止黑客通过远程方式调用本地模块。这里的做法足以应对绝大多数场景，如果要求更加严苛，也可以做更加复杂的安全逻辑。\n    NSString *actionName &#x3D; [url.path stringByReplacingOccurrencesOfString:@&quot;&#x2F;&quot; withString:@&quot;&quot;];\n    if ([actionName hasPrefix:@&quot;native&quot;]) &#123;\n        return @(NO);\n    &#125;\n\n    &#x2F;&#x2F; 这个demo针对URL的路由处理非常简单，就只是取对应的target名字和method名字，但这已经足以应对绝大部份需求。如果需要拓展，可以在这个方法调用之前加入完整的路由逻辑\n    id result &#x3D; [self performTarget:url.host action:actionName params:params shouldCacheTarget:NO];\n    if (completion) &#123;\n        if (result) &#123;\n            completion(@&#123;@&quot;result&quot;:result&#125;);\n        &#125; else &#123;\n            completion(nil);\n        &#125;\n    &#125;\n    return result;\n&#125;\n\n- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget\n&#123;\n\n    NSString *targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];\n    NSString *actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];\n    Class targetClass;\n\n    NSObject *target &#x3D; self.cachedTarget[targetClassString];\n    if (target &#x3D;&#x3D; nil) &#123;\n        targetClass &#x3D; NSClassFromString(targetClassString);\n        target &#x3D; [[targetClass alloc] init];\n    &#125;\n\n    SEL action &#x3D; NSSelectorFromString(actionString);\n\n    if (target &#x3D;&#x3D; nil) &#123;\n        &#x2F;&#x2F; 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的\n        return nil;\n    &#125;\n\n    if (shouldCacheTarget) &#123;\n        self.cachedTarget[targetClassString] &#x3D; target;\n    &#125;\n\n    if ([target respondsToSelector:action]) &#123;\n        return [self safePerformAction:action target:target params:params];\n    &#125; else &#123;\n        &#x2F;&#x2F; 有可能target是Swift对象\n        actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName];\n        action &#x3D; NSSelectorFromString(actionString);\n        if ([target respondsToSelector:action]) &#123;\n            return [self safePerformAction:action target:target params:params];\n        &#125; else &#123;\n            &#x2F;&#x2F; 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理\n            SEL action &#x3D; NSSelectorFromString(@&quot;notFound:&quot;);\n            if ([target respondsToSelector:action]) &#123;\n                return [self safePerformAction:action target:target params:params];\n            &#125; else &#123;\n                &#x2F;&#x2F; 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。\n                [self.cachedTarget removeObjectForKey:targetClassString];\n                return nil;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n- (void)releaseCachedTargetWithTargetName:(NSString *)targetName\n&#123;\n    NSString *targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];\n    [self.cachedTarget removeObjectForKey:targetClassString];\n&#125;\n\n#pragma mark - private methods\n- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params\n&#123;\n    NSMethodSignature* methodSig &#x3D; [target methodSignatureForSelector:action];\n    if(methodSig &#x3D;&#x3D; nil) &#123;\n        return nil;\n    &#125;\n    const char* retType &#x3D; [methodSig methodReturnType];\n\n    if (strcmp(retType, @encode(void)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        return nil;\n    &#125;\n\n    if (strcmp(retType, @encode(NSInteger)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        NSInteger result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(BOOL)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        BOOL result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(CGFloat)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        CGFloat result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(NSUInteger)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        NSUInteger result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;\n    return [target performSelector:action withObject:params];\n#pragma clang diagnostic pop\n&#125;\n\n#pragma mark - getters and setters\n- (NSMutableDictionary *)cachedTarget\n&#123;\n    if (_cachedTarget &#x3D;&#x3D; nil) &#123;\n        _cachedTarget &#x3D; [[NSMutableDictionary alloc] init];\n    &#125;\n    return _cachedTarget;\n&#125;\n\n@end\n\n针对第二点，我们通过把每个组件的对外接口进行分离，剥离到多个mediator的category里面，感官上把本来在一个mediator里面实现的对外接口分离到多个category里面，方便管理\n下面展示的是个组件B添加的category，组件A类似\n#import &quot;CTMediator.h&quot;\n\n@interface CTMediator (B_VC_Action)\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4;\n\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n#import &quot;CTMediator+B_VC_Action.h&quot;\n\n@implementation CTMediator (B_VC_Action)\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    [self performTarget:@&quot;target_B&quot; action:@&quot;B_Action&quot; params:@&#123;@&quot;para1&quot;:para1, @&quot;para2&quot;:@(para2),@&quot;para3&quot;:@(para3),@&quot;para4&quot;:@(para4)&#125; shouldCacheTarget:YES];\n&#125;\n@end\n\n此时调用者只要引入该category，然后调用即可，调用逻辑其实和上面没有拆分出category是一样的。此时的项目结构如下：\n\n\nURL-Scheme方案\n这个方案是流传最广的，也是最多人使用的，因为Apple本身也提供了url-scheme功能，同时web端也是通过URL的方式进行路由跳转，那么很自然的iOS端就借鉴了该方案。\n如何实现\nRouter实现代码\n#import typedef void (^componentBlock) (NSDictionary *param);\n\n@interface URL_Roueter : NSObject\n+ (instancetype)sharedInstance;\n- (void)registerURLPattern:(NSString *)urlPattern toHandler:(componentBlock)blk;\n- (void)openURL:(NSString *)url withParam:(id)param;\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n#import &quot;URL_Roueter.h&quot;\n\n@interface URL_Roueter()\n@property (nonatomic, strong) NSMutableDictionary *cache;\n@end\n\n\n@implementation URL_Roueter\n\n+ (instancetype)sharedInstance\n&#123;\n    static URL_Roueter *router;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        router &#x3D; [[URL_Roueter alloc] init];\n    &#125;);\n    return router;\n&#125;\n\n\n\n-(NSMutableDictionary *)cache&#123;\n    if (!_cache) &#123;\n        _cache &#x3D; [NSMutableDictionary new];\n    &#125;\n    return _cache;\n&#125;\n\n\n- (void)registerURLPattern:(NSString *)urlPattern toHandler:(componentBlock)blk &#123;\n    [self.cache setObject:blk forKey:urlPattern];\n&#125;\n\n- (void)openURL:(NSString *)url withParam:(id)param &#123;\n    componentBlock blk &#x3D; [self.cache objectForKey:url];\n    if (blk) blk(param);\n&#125;\n\n\n@end\n\n组件A#import &quot;A_VC.h&quot;\n#import &quot;URL_Roueter.h&quot;\n\n@implementation A_VC\n\n&#x2F;&#x2F;把自己对外提供的服务(block)用url标记，注册到路由管理中心组件\n+(void)load&#123;\n    [[URL_Roueter sharedInstance]registerURLPattern:@&quot;test:&#x2F;&#x2F;A_Action&quot; toHandler:^(NSDictionary* para) &#123;\n        NSString *para1 &#x3D; para[@&quot;para1&quot;];\n        [[self new] action_A:para1];\n    &#125;];\n&#125;\n\n\n-(void)viewDidLoad&#123;\n    [super viewDidLoad];\n    UIButton *btn &#x3D; [UIButton new];\n    [btn setTitle:@&quot;调用组件B&quot; forState:UIControlStateNormal];\n    btn.frame &#x3D; CGRectMake(100, 100, 100, 50);\n    [btn addTarget:self action:@selector(btn_click) forControlEvents:UIControlEventTouchUpInside];\n    [btn setBackgroundColor:[UIColor redColor]];\n\n    self.view.backgroundColor &#x3D; [UIColor blueColor];\n    [self.view addSubview:btn];\n\n&#125;\n\n&#x2F;&#x2F;调用组件B的功能\n-(void)btn_click&#123;\n    [[URL_Roueter sharedInstance] openURL:@&quot;test:&#x2F;&#x2F;B_Action&quot; withParam:@&#123;@&quot;para1&quot;:@&quot;PARA1&quot;, @&quot;para2&quot;:@(222),@&quot;para3&quot;:@(333),@&quot;para4&quot;:@(444)&#125;];\n&#125;\n\n\n-(void)action_A:(NSString*)para1 &#123;\n    NSLog(@&quot;call action_A: %@&quot;,para1);\n&#125;\n\n@end\n\n从上面的代码可以看出来，实现原理很简单：每个组件在自己的load方面里面，把自己对外提供的服务(回调block)通过url-scheme标记好，然后注册到URL-Router里面。\nURL-Router接受各个组件的注册，用字典保存了每个组件注册过来的url和对应的服务，只要其他组件调用了openURL方法，就会去这个字典里面根据url找到对应的block执行(也就是执行其他组件提供的服务)\n存在的问题\n需要专门的管理后台维护\n\n要提供一个文档专门记录每个url和服务的对应表，每次组件改动了都要即使修改，很麻烦。参数的格式不明确，是个灵活的 dictionary，同样需要维护一份文档去查这些参数。\n\n\n内存问题\n每个组件在初始化的时候都需要要路由管理中心去注册自己提供的服务，内存里需要保存一份表，组件多了会有内存问题。\n\n混淆了本地调用和远程调用\n\nurl-scheme是Apple拿来做app之间跳转的，或者通过url方式打开APP，但是上述的方案去把他拿来做本地组件间的跳转，这会产生问题，大概分为两点：\n\n\n远程调用和本地调用的处理逻辑是不同的，正确的做法应该是把远程调用通过一个中间层转化为本地调用，如果把两者两者混为一谈，后期可能会出现无法区分业务的情况。比如对于组件无法响应的问题，远程调用可能直接显示一个404页面，但是本地调用可能需要做其他处理。如果不加以区分，那么久无法完成这种业务要求。\n\n远程调用只能传能被序列化为json的数据，像 UIImage这样非常规的对象是不行的。所以如果组件接口要考虑远程调用，这里的参数就不能是这类非常规对象，接口的定义就受限了。出现这种情况的原因就是，远程调用是本地调用的子集，这里混在一起导致组件只能提供子集功能(远程调用)，所以这个方案是天生有缺陷的\n\n理论上来讲，组件化是接口层面的东西，应该用语言自身的特性去解决，而url是用于远程通信的，不应该和组件化扯上关系\n\n\n\n\n\n\n链家完整组件化实例","slug":"iOS-component","date":"2021-06-11T08:05:51.000Z","categories_index":"","tags_index":"组件化","author_index":"LittleStart"},{"id":"d68e4e31d1e8b7032dd88c62b8f9b3ca","title":"Xcode Server CI 持续集成","content":"Xcode Server CI 持续集成一、 Xcode Server 基本概念\nXcode Server是配置在Mac端的一个服务器，服务器上我们可以创建Bot自动执行机器人\n软件应用程序在本地（Xcode development Macs）开发过程中，会将代码不断合并到git上(SCM Repository)， \nBot会在指定的时间将git上的代码拉取到Server上，并且执行需要的操作，例如pod install以及创建ipa上传到测试分发平台\n执行完成之后会生成执行报告，如果有自动化测试的话，还会输出测试统计数据。\n\n二、 如何使用 Xcode Server 进行持续集成\n在Mac 电脑上, 安装 Xcode，并启用这个功能，一个持续集成的服务器就搭建好了\n启动Xcode，点击 Xcode 菜单: Xcode-&gt;XcodeServer\n 在Server&amp;Bots界面，将开关由OFF设置为ON, 输入系统账户密码, 选择一个用户作为 Xcode Server用户，然后continue等待完成，即成功启用Xcode Server。\n\n\n\n\n\n\n设置超时时间。超过时间后就会自动取消，如果项目仓库较大并且网速较慢第一次拉取会很耗时，可以先设置长一点时间。\n\n\n\n\n配置创建和查看bot权限的成员\n\n配置邮件通知\n\n\n","slug":"Xcode-Server-CI-持续集成","date":"2021-06-10T07:58:03.000Z","categories_index":"","tags_index":"持续集成","author_index":"LittleStart"},{"id":"549def405a2020c02b3886501c2d84f3","title":"async 和 await 同步等待","content":"Dart\n\n\n\n\n\n\n\n\n获取相应数据操作\n","slug":"async-await","date":"2021-06-01T03:45:18.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"6af98c5762fa00ab05498386038da6c3","title":"抽象构造函数","content":"抽象类\nabstract关键字修饰class\n继承的方式使用\n接口的方式使用\n\nabstract class Message &#123;\n  \n  factory Message(String type) &#123;\n    switch(type) &#123;\n      case 'foot': \n        return new Footmessage();\n      case 'back': \n        return new Footmessage();\n      case 'special': \n        return new Footmessage();\n    &#125;\n  &#125;\n  \n  void doMessage(); // \n&#125;\n\nclass FootMessge implements Message &#123;\n  @override\n   void doMessage() &#123;\n     \n   &#125;\n&#125;\n\nclass BackMessge implements Message &#123;\n  @override\n   void doMessage() &#123;\n     \n   &#125;\n&#125;\n\nclass SpecialMessge implements Message &#123;\n  @override\n   void doMessage() &#123;\n     \n   &#125;\n&#125;\n\n// 函数调用\nvar footMessage = new Message('foot')\nvar backMessage = new Message('back')\nvar specialMessage = new Message('special')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"abstractClass","date":"2021-06-01T02:16:37.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"3b284d7eb9880174f64e9bf09d231aff","title":"DartClass","content":"Dart 类相关的使用命名构造函数\nPoint.fromJSON(Map json)\n\nclass Point &#123;\n  num x;\n  num y;\n\n  Point(this.x, this.y);\n\n  &#x2F;&#x2F; 命名构造函数（命名构造函数）\n  Point.fromJSON(Map json) &#123;\n    x &#x3D; json[&#39;x&#39;];\n    y &#x3D; json[&#39;y&#39;];\n  &#125;\n&#125;\n\n重定向构造函数\n使用冒号:调用其他构造函数\n\nclass Point &#123;\n  num x;\n  num y;\n\n  Point(this.x, this.y);\n\n  &#x2F;&#x2F; 命名构造函数（命名构造函数）\n  Point.fromJSON(Map json) &#123;\n    x &#x3D; json[&#39;x&#39;];\n    y &#x3D; json[&#39;y&#39;];\n  &#125;\n\n  &#x2F;&#x2F; 重定向构造函数，使用冒号调用其他构造函数\n  Point.alongXAxis(num x) : this(x, 0); &#x2F;&#x2F; 重定向构造函数\n\n&#125;\n\n超类构造函数\n超类\n\nclass Parent &#123;\n  int x;\n  int y;\n\n  &#x2F;&#x2F;父类命名构造函数不会传递  \n  Parent.fromJson(x, y)\n      : x &#x3D; x, &#x2F;&#x2F; 赋值过程\n        y &#x3D; y &#123;\n    print(&#39;父类命名构造函数&#39;);\n  &#125;\n&#125;\n\n\nclass Child extends Parent &#123;\n  int x;\n  int y;\n  &#x2F;&#x2F;若超类没有默认构造函数， 需要手动调用超类其他构造函数\n  Child(x, y) : super.fromJson(x, y) &#123;\n    &#x2F;&#x2F;调用父类构造函数的参数无法访问 this\n    print(&#39;子类构造函数&#39;);\n  &#125;\n\n  &#x2F;&#x2F;在构造函数的初始化列表中使用super()，需要把它放到最后\n  Child.fromJson(x, y) \n    : x &#x3D; x, &#x2F;&#x2F; 赋值操作\n          y &#x3D; y, &#x2F;&#x2F; 赋值操作\n        &#x2F;&#x2F; 调用命名构造函数\n       super.fromJson(x, y) &#123;\n    print(&#39;子类命名构造函数&#39;);\n  &#125;\n&#125;\n\n常量构造函数\n通过const 关键字\n\nclass Point2 &#123;\n  &#x2F;&#x2F;定义const构造函数要确保所有实例变量都是final\n  final num x;\n  final num y;\n  &#x2F;&#x2F; 初始化构造函数\n  static final Point2 origin &#x3D; const Point2(0, 0);\n\n  &#x2F;&#x2F;const关键字放在构造函数名称之前，且不能有函数体\n  const Point2(this.x, this.y);\n&#125;\n\nPoint2 point2 &#x3D; const Point2(1, 2);\nPoint2 p3 &#x3D; const Point2(1, 2);\n\n工厂构造函数\n通过命名构造函数，然后使用 factory 关键字\n如果对象存在，不生成新对象，如果不存在，生成新对象\n\nclass Singleton &#123;\n  String name;\n  &#x2F;&#x2F;工厂构造函数无法访问this，所以这里要用static\n  static Singleton _cache; \n\n  &#x2F;&#x2F;定义一个命名构造函数用来生产实例\n  Singleton._newObject(this.name);\n\n  &#x2F;&#x2F;工厂方法构造函数，关键字factory\n  factory Singleton([String name &#x3D; &#39;singleton&#39;]) &#x3D;&gt;\n      Singleton._cache ??&#x3D; Singleton._newObject(name);\n&#125;\n\nSet 和 get 方法\n通过 set 和 get 关键字来进行操作\n\nclass Rectangle &#123;\n  num left;\n  num top;\n  num width;\n  num height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  num get right => left + width;\n  set right(num value) => left = value - width;\n  num get bottom => top + height;\n  set bottom(num value) => top = value - height;\n&#125;\n","slug":"DartClass","date":"2021-06-01T01:28:38.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"1117fb54e92a8351488adf129028b2a6","title":"DartException","content":"Dart 异常处理操作![截屏2021-05-31 下午5.06.39](DartException/截屏2021-05-31 下午5.06.39.png)\n延迟加载异常\nDeferredLoadException 延迟加载异常\n\nthrow new FormateException(\"\")\n\n类型异常\nFormateException(“”)\n\nFormateException(\"格式化异常\")\n\ntry catch 捕获异常\n捕获异常\n\ntry &#123;\n  throw new NullThrownError();\n&#125; catch(e, s) &#123; // 第一个异常对象， StackTrack 对象\n  print(e)\n&#125;\n\n\n制定捕获的异常\n\ntry &#123;\n  throw new NullThrownError();\n&#125; on Error &#123;\n  print('error 类型捕获异常')\n&#125; catch(e, s) &#123; // 第一个异常对象， StackTrack 对象\n  print(e)\n&#125;\n","slug":"DartException","date":"2021-05-31T09:06:01.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"5c608ba3383f27b31f8830b3a9b5f6d6","title":"应用性能分析方法","content":"应用性能分析方法1. 采样顾名思义，采样(或基于探测点的性能分析)是指以一定的周期间隔采集状态，这通常需要借助工具。由于不会干扰应用的执行，因此采样可以很好地提供应用的全景图。采样的不足之处在于它不能返回 100% 精确的细节。如果采样的频率是 10 毫秒，那么你就无法得知在探测点之间的 9.999 毫秒内发生了什么。\n\n\n\n\n\n\n\n\n\n采样可以作为初始的性能调研手段，并可用于跟踪 CPU 和内存的使用情况\n2. 埋点通过修改代码，记录细节信息的埋点能够提供比采样更加精确的结果。你既可以在关键部分主动埋点，也可以在性能分析或处理用户反馈时有针对性地埋点因为埋点需要注入额外代码，所以它一定会影响应用的性能，对内存或速度(或同时对二者)造成损害。\n1.4 测量现在，我们已经确定了需要测量的参数，并且研究了测量所需要的不同类型的分析。我们先简单了解一下如何实现测量。\n通过测量性能并找出真正存在问题的地方，你可以避免掉入过早优化的陷阱.\n\n\n\n\n\n\n\n\n\n真正的问题在于,程序开发人员为提升程序效率在错误的方向和时间点浪费了太多时间;过早优化是编程领域的万恶(至少是绝大多数的恶)之源。\n1.4.1 设置工程与代码接下来，我们将建立一个工程，以便在开发和生产阶段测量已经定义好的参数。针对工程配置、安装和代码实现共有三类任务。\n\n构建与发布 : 确保能够轻松地构建和发布应用。\n\n可测试性 确保你的代码能够同时在模拟数据和真实数据之上工作，其中包括能够模拟真实场景的隔离环境\n\n可跟踪性 确保你能够通过明确问题发生的位置和代码行为来处理错误。\n\n\n1. 构建与发布由于对灵活和敏捷的强烈需求，系统和工具得到了改进。改进后的系统和工具现在可以加速拉取依赖信息，加速构建和发布用于测试或企业分发的产品，也可以为公众发布而提高提交文件到 iTunes Connect 的速度。\n基于 Ruby 语言实现的 CocoaPods(https://cocoapods.org)实际上是 Objective-C 和 Swift 工程的依赖管理器。CocoaPods 与 Xcode 命令行工具相集成，可用于构建与发布。\n2. 可测试性每个应用都包含多个协同工作的组件。一个设计良好的系统应该遵循低耦合和高内聚，并允许替换任意或全部组件的依赖。\n可以通过模拟依赖项目对每个组件进行隔离测试。一般来说，测试有两种类型。\n• 单元测试 验证每个代码单元在隔离环境下的操作。常见的做法是，在特定的环境中用不同的输入数据反复地调用一些方法，以评估代码的表现。\n• 功能测试 验证组件在最终集成的安装包中的操作。可以在软件的最终发布版本中验证，也可以在某个为测试而构建的参考应用中验证。\n3. 可跟踪性在开发阶段，埋点可以帮助我们确定性能优化的优先级、提高对问题现场的还原能力，并提供更多的调试信息。崩溃报告专注于从软件的产品版本中收集调试信息。\n4. 设置崩溃报告崩溃报告系统收集用于分析应用的调试日志。市面上有数十种崩溃报告系统.\n5. 对应用埋点对应用进行埋点是了解用户行为的一个重要步骤，但更重要的目的是识别应用的关键路径。注入特定的代码以记录关键指标是提升应用性能的重要步骤。\n日志日志是无价之宝，可以用于了解应用发生了什么事。日志和埋点之间存在着细微的差别。埋点可以看作日志的子集。被埋点的任何数据都应该 记录在日志中。埋点承担了为聚合分析发布关键性能数据的职责，日志则提供了用于在不同级别跟踪应用的细节信息，比如 debug、``Verbose、``info、``warning 和 Error。日志的记录会贯穿应用的整个生命周期，而埋点只应该用在开发的特定阶段。\n埋点数据会发送到服务器，日志是记录在设备本地。 就日志而言，我们可以通过 CocoaPods 引入 CocoaLumberjack 来使用。\nCocoaLumberjack 是一个扩展性很强的框架，捆绑了一系列内置的日志记录器，这些记录器 可以向不同的目标发送信息。例如，使用 DDASLLogger 可以向 Apple System Log(ASL， NSLog 方法的默认位置)记录日志。类似地，使用 DDFileLogger 可以向文件记录日志。可 以在应用运行期间配置记录器。\nDDLog 宏指令可以用于记录某个特定层级的日志。层级越高，信息越重要。最高级 别是 Error，最低级别是 Verbose。实际记录消息的最低层级可以配置在每个文件层级、每 个 Xcode 配置层级、每个日志器层级或全局。以下的宏指令可供使用。\n\nDDLogError 表示不可恢复的错误。\nDDLogWarn 表示可恢复的错误。\nDDLogInfo 表示非错误的信息。\nDDLogDebug 表示数据主要用于调试。\nDDLogVerbose 几乎提供了所有的细节，主要用于跟踪执行过程中的控制流。这些宏指令有着与 NSLog 相同的签名。这意味着你可以直接用适合的 DDLog 调用来 取代 NSLog。\n\n","slug":"应用性能分析方法","date":"2021-05-22T07:06:49.000Z","categories_index":"","tags_index":"iOS性能优化","author_index":"LittleStart"},{"id":"d6599ba5117b38d8d4d285c032bd712d","title":"iOS性能优化指标","content":"性能指标\n\n\n\n\n\n\n\n\n性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。\n1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保没有泄漏内存。随时间流逝而持续增长的内存消耗意味着，应用很可能会因 为内存不足的异常而崩溃。\n1.2.2 电量消耗在编写高性能代码时，电量消耗是一个需要重点处理的重要因素。就执行时间和 CPU 资源的利用而言，我们不仅要实现高效的数据结构和算法，还需要考虑其他的因素。如果某个应用是个电池黑洞，那么一定不会有人喜欢它。\n电量消耗不仅仅与计算 CPU 周期有关，还包括高效地使用硬件。除了要实现电量消耗最 小化，还要确保不会影响用户体验。\n1.2.3 初始化时间应用在启动时应执行刚好够用的任务以完成初始化，从而满足用户的使用需求。执行这些 任务消耗的时间就是应用的初始化时间。刚好够用是一个开放式用语——正确的平衡点取 决于应用的需要。\n在首次使用应用时创建对象并进行初始化是一个合理的选择，例如，直到需要使用对象时 才创建对象。这种方式被称为惰性初始化。这是一种很好的策略，但也要考虑不能让用户 总是在执行后续任务时等待。\n下面列举了你可能想在应用初始化阶段执行的一些动作，排名不分先后。\n\n检查应用是否为首次启动。\n检查用户是否已经登录。\n如果用户已经登录，尽可能地载入之前的状态。\n连接服务器以拉取最新的变更。\n检查应用是否由某个深层链接唤起。如果是，还需要载入深层链接相应的 UI 和状态。\n检查是否存在应用上次启动时挂起的任务，需要时恢复它们。\n初始化后续需要使用的对象和线程池。\n初始化依赖项(如对象关系映射、崩溃报告系统和缓存)。\n\n这个列表可能会迅速变长，并且很难决定哪些条目一定要在启动时执行，哪些可以延后几 毫秒再执行。\n1.2.4 执行速度一旦启动应用，用户总是希望它可以尽可能快地工作。一切必要的处理都应该在尽可能短 的时间内完成。\n例如，在照片应用中，用户通常希望看到调整亮度或对比度等简单效果的实时预览效果。 因此，相应的处理需要在几毫秒内完成。\n这可能需要本地计算的并行处理技术或能够将复杂任务分发到服务器。\n1.2.5 响应速度每个应用都应该快速地响应用户交互。在应用中所做的一切优化和权衡最终都应该体现在 响应速度上。\nApp Store 中有许多应用可以完成相似或相关的任务。这为用户提供了很大的选择空间，而用户基本都会选择响应最快的应用。\n1.2.6 本地存储针对任何在服务器上存储数据或通过外部来源刷新数据的应用，开发人员应该对本地存储 的使用有所规划，以便应用具备离线浏览的能力。\n例如，用户都希望邮件应用能够在无网络或设备离线的情况下浏览历史邮件。 同样，新闻应用也应该可以在离线模式下显示最近更新的新闻，并标记出每条新闻是否已读。\n然而，从本地存储中载入和同步数据应该迅速、便捷。这不仅需要选择要在本地缓存的数 据和要优化的数据结构，还需要提供一系列的配置选项并确定数据同步的频率。\n如果你的应用使用了本地存储，那么请提供一个清除数据的选项。遗憾的是，市场上的大 部分应用都没有提供此选项。更让人烦恼的是，一些应用竟然会消耗数百兆的存储空间。 用户会频繁地卸载这些应用来回收本地存储。这会导致糟糕的用户体验，从而威胁应用的 成功。\n1.2.7 互操作性用户可能会使用多个应用来完成某个任务，这就需要这些应用直接提供互操作的能力。例 如，一个相册可能需要一个幻灯片应用来实现最佳的浏览体验，但需要另一个应用来编辑 照片。其中浏览照片的应用要能够将照片发送到编辑器，并接收编辑后的图片。\niOS 为实现应用间的互操作和数据共享提供了多种机制，其中包括 UIActivityViewController、 深层链接、MultipeerConnectivity 框架，等等。\n为深层链接定义良好的 URL 结构与编写优异的代码来解析 URL 同样重要。类似地，使用 共享对话框共享数据时，精确识别用于分享的数据非常重要，同时，在处理不同数据源传 入的数据时还要注意安全隐患。\n如果某个应用向附近设备共享数据时需要花费很长时间准备数据，那么用户体验就会非常 糟糕。\n1.2.8 网络环境移动设备会在不同网络环境下使用。为了确保能够提供最好的用户体验，你的应用应当适 应各种网络条件:\n\n高带宽稳定网络\n低带宽稳定网络\n高带宽不稳定网络\n低带宽不稳定网络\n无网络\n\n1.2.9 带宽人们会在不同的网络条件下使用自己的移动设备，网速从每秒数千字节到每秒数十兆字节。 因此，带宽的优化使用是定义应用质量的另一个关键参数。此外，在高带宽网络下运行一 个基于低带宽网络开发的应用可能会产生完全不同的结果。\n2010 年左右，我和我的团队正在印度开发一款应用。由于处于低带宽网络，应用的本地初始化速度要比从服务器端载入资源快得多，于是我们针对这种情况进行了优化。\n然而，当这款应用投入韩国市场时，我们对它进行了测试，结果却让人大跌眼镜。之前所 进行的所有优化几乎毫无意义，我们不得不重写了大部分可能导致资源和数据冲突的相关 代码。\n为提高性能所做的设计并非每次都能如愿，也可能会导致相反的效果。\n1.2.10 数据刷新即使没有提供离线浏览能力，你仍然可以从服务器端周期性地刷新数据。刷新的频率和每 次传输的数据量将决定数据传输的总量。如果传输的字节数过大，那用户必然会快速耗尽 自己的流量计划。当流量消耗大到一定程度时，你的应用很可能会流失用户。\n在 iOS 6.x 或更低版本中，在后台运行的应用不能刷新数据。从 iOS 7 开始，应用可以在后台周期性地刷新数据。对于在线聊天类应用，持久的 HTTP 连接或原生 TCP 连接可能会非常有用。\n1.2.11 多用户支持家庭成员间可能会共享移动设备，或者一个用户可能会拥有同一应用的多个账号。例如， 兄弟姐妹间可能会共享一个 iPad 来玩游戏。再比如，家庭成员可能会在旅游时配置一个设备来查收全家人的电子邮件，以减少漫游费用，尤其是在境外旅游时。类似地，一个人也 可能会配置多个电子邮件账号。\n是否支持多个并发用户取决于产品的需要。一旦决定提供此类功能，请参考以下准则。\n\n添加新用户应尽可能高效。\n在不同用户之间更新应尽可能高效。\n在不同用户之间切换应尽可能高效。\n用户数据的界限应该简洁且没有 bug。\n\n1.2.12 单点登录如果你已经创建了多个允许或需要登录的应用，那么支持单点登录(single sign-on，SSO) 是非常棒的选择。如果用户登录了一个应用，只需要点击一次，就可以登录到其他的应用中。\n这个过程不仅需要支持跨应用的数据共享，还需要分享状态、跨应用同步等。例如，如果 用户注销了其中某个应用，则通过 SSO 登录的所有其他应用也应能注销掉。 此外，应用之间的同步应该是安全的。\n1.2.13 安全安全对移动应用来说是最重要的，因为敏感信息可能会在应用间共享。因此，对所有通信 以及本地数据和共享数据进行加密就显得尤为重要了。\n实现安全需要更多的计算、内存和存储，但这与最大化运行速度、最小化内存和存储使用 的目标相冲突。\n因此，你需要在安全和其他因素之间进行权衡。\n引入多个安全层会影响性能，并对用户体验造成可感知的负面影响。如何设定安全的基线 需要参考对用户群体的统计分析。此外，硬件在其中扮演了重要的角色:选择会因为不同 设备的计算能力而有所不同。\n1.2.14 崩溃应用可能会而且确实会崩溃。过度优化会导致崩溃。同样，使用原始 C 代码也可能会导致 崩溃。 高性能的应用不仅应尽可能地避免崩溃，还应该在崩溃发生时优雅地恢复，尤其是在进行 某个操作的过程中发生崩溃时。\n综上所述\n\n\n\n\n\n\n\n\n性能主要从以上所有面向用户的基本属性指标分析\n\n\n","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","categories_index":"","tags_index":"iOS性能优化","author_index":"LittleStart"},{"id":"eafabc105702abbd3d554d5c51e703dd","title":"iOS内存对齐","content":"iOS中内存对齐数据对齐规则\n结构体和联合体（union）的数据成员，第一个数据成员放到offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员子成员大小（只要该成员有子成员，比如说数组，结构体等）的整数倍开始（比如int为4自己接，则要从4的整数倍地址开始存储）\n\n结构体作为成员，则结构体成员要从其内部最大元素大小的整数倍开始存储( 那么b应该从8的整数倍开始存储)\nstruct GLStruct1 &#123;\n  char a; &#x2F;&#x2F; 1 + 7（不全七个）\n  double b; &#x2F;&#x2F; 8 字节\n  int c; &#x2F;&#x2F; 4 字节\n  short d; &#x2F;&#x2F; 2 字节\n&#125; GLStruct1;\n\nstruct GLStruct2 {\n  double b; // 8字节\n  char a; // 1 字节\n   int c; // 4 字节\n  short d; //  2字节\n} GLStruct2;\nNSLog(@”%lu - %lu”, sizeof(GLStruct1), sizeof(GLStruct1));\n\n\n\n\n\n#### 关于分配内存8字节对齐\n\n&#96;&#96;&#96;objc\n#import &lt;Foundation&#x2F;Foundation.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface GLPerson : NSObject\n\n@Property (nonatomic, copy) NSString *name;\n@Property (nonatomic, assign) int age;\n@Property (nonatomic, assign) long height;\n@Property (nonatomic, copy) NSString *hobby;\n\n\n\n&#x2F;&#x2F; @Property (nonatomic, assign) int sex;\n&#x2F;&#x2F; @Property (nonatomic) char ch1;\n&#x2F;&#x2F; @Property (nonatomic) char ch2;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\nGLPerson *person &#x3D; [GLPerson alloc];\nperson.name &#x3D; @&quot;张三&quot;；\nperson.age &#x3D; 18;\nperson.height &#x3D; 180;\nperson.hobby &#x3D; @&quot;nv&quot;\n\n总共分配对象实例的内存大小： \n  isa 8个字节\n  name 8个字节\n  age  4个字节\n  height 8个字节\n  hobby  8个字节\n\nNSLog(@&quot;%lu - %lu&quot;, class_getInstancesClass([person class]))\n\n注意：对象申请的内存大小  VS  系统开辟的大小 不一致\nvoid *\ncalloc(size_t num_items, size_t size)\n&#123;\n    void *retval;\n    retval &#x3D; malloc_zone_calloc(default_zone, num_items, size);\n    if (retval &#x3D;&#x3D; NULL) &#123;\n        errno &#x3D; ENOMEM;\n    &#125;\n    return retval;\n&#125;\n\nvoid *\nmalloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n    MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);\n\n    void *ptr;\n    if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;&#x3D; malloc_check_start)) &#123;\n        internal_check();\n    &#125;\n\n    ptr &#x3D; zone-&gt;calloc(zone, num_items, size);\n\n    if (malloc_logger) &#123;\n        malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,\n                (uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);\n    &#125;\n\n    MALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);\n    return ptr;\n&#125;\n\n\n\n\n\n\n\n\n\n\n找到对应下方方法\np zone-&gt;calloc\n\nstatic void *\ndefault_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n    zone &#x3D; runtime_default_zone();\n\n    return zone-&gt;calloc(zone, num_items, size);\n&#125;\n\nstatic void *\nnano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)\n&#123;\n    size_t total_bytes;\n\n    if (calloc_get_size(num_items, size, 0, &amp;total_bytes)) &#123;\n        return NULL;\n    &#125;\n\n    if (total_bytes &lt;&#x3D; NANO_MAX_SIZE) &#123;\n        void *p &#x3D; _nano_malloc_check_clear(nanozone, total_bytes, 1);\n        if (p) &#123;\n            return p;\n        &#125; else &#123;\n            &#x2F;* FALLTHROUGH to helper zone *&#x2F;\n        &#125;\n    &#125;\n    malloc_zone_t *zone &#x3D; (malloc_zone_t *)(nanozone-&gt;helper_zone);\n    return zone-&gt;calloc(zone, 1, total_bytes);\n&#125;\n\nstatic void *\n_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)\n&#123;\n    MALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, 0);\n\n    void *ptr;\n    size_t slot_key;\n    size_t slot_bytes &#x3D; segregated_size_to_fit(nanozone, size, &amp;slot_key); &#x2F;&#x2F; Note slot_key is set here\n    mag_index_t mag_index &#x3D; nano_mag_index(nanozone);\n\n    nano_meta_admin_t pMeta &#x3D; &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);\n\n    ptr &#x3D; OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));\n    if (ptr) &#123;\n        unsigned debug_flags &#x3D; nanozone-&gt;debug_flags;\n#if NANO_FREE_DEQUEUE_DILIGENCE\n        size_t gotSize;\n        nano_blk_addr_t p; &#x2F;&#x2F; the compiler holds this in a register\n\n        p.addr &#x3D; (uint64_t)ptr; &#x2F;&#x2F; Begin the dissection of ptr\n        if (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n            malloc_zone_error(debug_flags, true,\n                    &quot;Invalid signature for pointer %p dequeued from free list\\n&quot;,\n                    ptr);\n        &#125;\n\n        if (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n            malloc_zone_error(debug_flags, true,\n                    &quot;Mismatched magazine for pointer %p dequeued from free list\\n&quot;,\n                    ptr);\n        &#125;\n\n        gotSize &#x3D; _nano_vet_and_size_of_free(nanozone, ptr);\n        if (0 &#x3D;&#x3D; gotSize) &#123;\n            malloc_zone_error(debug_flags, true,\n                    &quot;Invalid pointer %p dequeued from free list\\n&quot;, ptr);\n        &#125;\n        if (gotSize !&#x3D; slot_bytes) &#123;\n            malloc_zone_error(debug_flags, true,\n                    &quot;Mismatched size for pointer %p dequeued from free list\\n&quot;,\n                    ptr);\n        &#125;\n\n        if (!_nano_block_has_canary_value(nanozone, ptr)) &#123;\n            malloc_zone_error(debug_flags, true,\n                    &quot;Heap corruption detected, free list canary is damaged for %p\\n&quot;\n                    &quot;*** Incorrect guard value: %lu\\n&quot;, ptr,\n                    ((chained_block_t)ptr)-&gt;double_free_guard);\n        &#125;\n\n#if defined(DEBUG)\n        void *next &#x3D; (void *)(((chained_block_t)ptr)-&gt;next);\n        if (next) &#123;\n            p.addr &#x3D; (uint64_t)next; &#x2F;&#x2F; Begin the dissection of next\n            if (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n                malloc_zone_error(debug_flags, true,\n                        &quot;Invalid next signature for pointer %p dequeued from free &quot;\n                        &quot;list, next &#x3D; %p\\n&quot;, ptr, &quot;next&quot;);\n            &#125;\n\n            if (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n                malloc_zone_error(debug_flags, true,\n                        &quot;Mismatched next magazine for pointer %p dequeued from &quot;\n                        &quot;free list, next &#x3D; %p\\n&quot;, ptr, next);\n            &#125;\n\n            gotSize &#x3D; _nano_vet_and_size_of_free(nanozone, next);\n            if (0 &#x3D;&#x3D; gotSize) &#123;\n                malloc_zone_error(debug_flags, true,\n                        &quot;Invalid next for pointer %p dequeued from free list, &quot;\n                        &quot;next &#x3D; %p\\n&quot;, ptr, next);\n            &#125;\n            if (gotSize !&#x3D; slot_bytes) &#123;\n                malloc_zone_error(debug_flags, true,\n                        &quot;Mismatched next size for pointer %p dequeued from free &quot;\n                        &quot;list, next &#x3D; %p\\n&quot;, ptr, next);\n            &#125;\n        &#125;\n#endif &#x2F;* DEBUG *&#x2F;\n#endif &#x2F;* NANO_FREE_DEQUEUE_DILIGENCE *&#x2F;\n\n        ((chained_block_t)ptr)-&gt;double_free_guard &#x3D; 0;\n        ((chained_block_t)ptr)-&gt;next &#x3D; NULL; &#x2F;&#x2F; clear out next pointer to protect free list\n    &#125; else &#123;\n        ptr &#x3D; segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);\n    &#125;\n\n    if (cleared_requested &amp;&amp; ptr) &#123;\n        memset(ptr, 0, slot_bytes); &#x2F;&#x2F; TODO: Needs a memory barrier after memset to ensure zeroes land first?\n    &#125;\n    return ptr;\n&#125;\n\nstatic MALLOC_INLINE size_t\nsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)\n&#123;\n    &#x2F;&#x2F; size &#x3D; 40\n    size_t k, slot_bytes;\n\n    if (0 &#x3D;&#x3D; size) &#123;\n        size &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior\n    &#125;\n    &#x2F;&#x2F; 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4\n    &#x2F;&#x2F; 40 - 16*3 &#x3D; 48\n\n    &#x2F;&#x2F;\n    &#x2F;&#x2F; 16 字节对齐\n    k &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta\n    slot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;                            &#x2F;&#x2F; multiply by power of two quanta size\n    *pKey &#x3D; k - 1;                                                    &#x2F;&#x2F; Zero-based!\n\n    return slot_bytes;\n&#125;\n","slug":"Memory-alignment","date":"2021-05-03T00:55:06.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"a519dcebcf7b75aa7909ffb897e4913c","title":"Spring基础了解","content":"Spring 简介​        Spring 是分层的 full-stack（全栈） 轻量级开源框架，以IoC和 AOP 为内核，提供了展现层Spring MVC和业务层事务管理等众多的企业级应⽤技术，还能整合开源世界众多著名的第三⽅框架和类库，已 经成为使⽤最多的Java EE企业应⽤开源框架。\nSpring Framework\n\n\n\n\n\n\n\n\n\n提供依赖注入的核心支持，事务管理，web apps 、数据访问、消息以及其他更多\n\n\nSpring 的优势整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀ 天，就能体会到它的⼀些优势。 \n\n**⽅便解耦，简化开发 **\n\n通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的 过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更 专注于上层的应⽤。 \n\n**AOP编程的⽀持 **\n\n通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过 AOP轻松应付。 \n\n**声明式事务的⽀持 **\n\n@Transactional 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼ 开发效率和质量。\n\n**⽅便程序的测试 **\n\n可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的 事情。 \n\n⽅便集成各种优秀框架 \n\nSpring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接⽀持。 降低JavaEE API的使⽤难度 Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤ 难度⼤为降低。\n\n**源码是经典的 Java 学习范例 **\n\nSpring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对 Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。\nSpring 的核⼼结构Spring是⼀个分层⾮常清晰并且依赖关系、职责定位⾮常明确的轻量级框架，主要包括⼏个⼤模块：数 据处理模块、Web模块、AOP（Aspect Oriented Programming）/Aspects模块、Core Container模块 和 Test 模块，如下图所示，Spring依靠这些基本模块，实现了⼀个令⼈愉悦的融合了现有解决⽅案的零 侵⼊的轻量级框架。\n\n\nSpring核⼼容器（Core Container） 容器是Spring框架最核⼼的部分，它管理着Spring应⽤中 bean的创建、配置和管理。在该模块中，包括了Spring bean⼯⼚，它为Spring提供了DI的功能。 基于bean⼯⼚，我们还会发现有多种Spring应⽤上下⽂的实现。所有的Spring模块都构建于核⼼ 容器之上。 \n⾯向切⾯编程（AOP）/Aspects Spring对⾯向切⾯编程提供了丰富的⽀持。这个模块是Spring应 ⽤系统中开发切⾯的基础，与DI⼀样，AOP可以帮助应⽤对象解耦。\n数据访问与集成（Data Access/Integration）\nSpring的JDBC和DAO模块封装了⼤量样板代码，这样可以使得数据库代码变得简洁，也可以更专 注于我们的业务，还可以避免数据库资源释放失败⽽引起的问题。 另外，Spring AOP为数据访问 提供了事务管理服务，同时Spring还对ORM进⾏了集成，如Hibernate、MyBatis等。该模块由 JDBC、Transactions、ORM、OXM 和 JMS 等模块组成。\nWeb 该模块提供了SpringMVC框架给Web应⽤，还提供了多种构建和其它应⽤交互的远程调⽤⽅ 案。 SpringMVC框架在Web层提升了应⽤的松耦合⽔平。\nTest 为了使得开发者能够很⽅便的进⾏测试，Spring提供了测试模块以致⼒于Spring应⽤的测 试。 通过该模块，Spring为使⽤Servlet、JNDI等编写单元测试提供了⼀系列的mock对象实现\n核⼼思想1.1 什么是IoC？IoC Inversion of Control (控制反转/反转控制)，注意它是⼀个技术思想，不是⼀个技术实现 描述的事情：Java开发领域对象的创建，管理的问题 传统开发⽅式：⽐如类A依赖于类B，往往会在类A中new⼀个B的对象\nIoC思想下开发⽅式：我们不⽤⾃⼰去new对象了，⽽是由IoC容器（Spring框架）去帮助我们实例化对 象并且管理它，我们需要使⽤哪个对象，去问IoC容器要即可 我们丧失了⼀个权利（创建、管理对象的权利）,得到了⼀个福利（不⽤考虑对象的创建、管理等⼀系列 事情）\n为什么叫做控制反转？ 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器)\n没有IoC容器\n\n\n使用IoC容器\n\n\nIoC 解决什么问题\n\n\n\n\n\n\n\n\n主要解决对象之间的耦合问题\n IoC和DI的区别 DI：\n\n\n\n\n\n\n\n\n\n Dependancy Injection（依赖注⼊）  IOC和DI描述的是同⼀件事情，只不过⻆度不⼀样罢了\n\nIOC 和 DI 描述的是同一件事情，对象实例化以及依赖关系的维护这件事情，只不过角度不同\nIOC是从对象的角度，对象实例化以及管理权交给IoC容器\nDI是在容器角度，容器会把对象依赖其他对象注入（送进去）比如A对象实例化过程因为声明啦一个B类型的属性，那么就要把对象B注入到A中\n\nAOP什么是AOP AOP\n\n\n\n\n\n\n\n\n Aspect oriented Programming ⾯向切⾯编程/⾯向⽅⾯编程 AOP是OOP的延续，从OOP说起\nOOP三⼤特征\n\n\n\n\n\n\n\n\n 封装、继承和多态 oop是⼀种垂直继承体系\nOOP编程思想可以解决⼤多数的代码重复问题，但是有⼀些情况是处理不了的，⽐如下⾯的在顶级⽗类 Animal中的多个⽅法中相同位置出现了重复代码，OOP就解决不了\n","slug":"Spring-base","date":"2021-05-02T06:22:41.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"83f1863d7d241c1d5ddb943bddf231fd","title":"动态SQL","content":"动态sql语句**动态sql语句概述 **\n\n\n\n\n\n\n\n\n\n Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动 态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n","slug":"dynamicSQL","date":"2021-05-01T23:43:13.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"20c5d0afd79142c4ce377e5e3d6eadea","title":"alloc&init探究","content":"alloc 和 init 基本原理LGPerson *p &#x3D; [[LGPerson alloc] init];\n LGPerson *p1 &#x3D; [p init];\n &#x2F;&#x2F; objc_msgSend （id 消息接收者，sel 发送消息）\n LGPerson *p2 &#x3D; [p init];\n NSLog(@&quot;输出将结果如下： %p-%p-%p&quot;, p, p1, p2);\n NSLog(@&quot;end&quot;); &#x2F;&#x2F;\n\n1. 探究问题\nalloc 探究\nalloc 已经创建了对象init\nalloc 怎么实现创建\nalloc 实现- 原理-源码实现\n\n2. 探究方式\nlibobjc.A.dylib\n\n下断点： control + in - objc_alloc\n\n下符号断点：libobjc.A.dylib`+[NSObjject alloc]\n\n通过汇编方式libobjc.A.dylib\nDebug -&gt; Debug workflow -&gt; Always Show Disassembly\n\n\n![](截屏2021-05-01 下午6.01.02.png)\n\n\n注意：\n\n\n\n\n\n\n\n\n使用真机调试\nlibobjc.A.dylib 库关于 objc_alloc: \n\nalloc 方法实现\n首先申请内存空间，给指针地址\nregister read x0 方法读取寄存器的值\nx0 即是返回对象的地址，以及存储数据的地方\n\nalloc 实现源码执行的过程\n调用alloc方法\n\n+ (id)alloc &#123;\n  return _objc_rootAlloc(self);\n&#125;\n\n\n调用_objc_rootAlloc(Class cls) 方法\n\n_objc_rootAlloc(Class cls)\n&#123;\n    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);\n&#125;\n\n\nstatic ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) \n\nstatic ALWAYS_INLINE id\ncallAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)\n&#123;\n    if (slowpath(checkNil &amp;&amp; !cls)) return nil;\n\n#if __OBJC2__\n    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;\n        &#x2F;&#x2F; No alloc&#x2F;allocWithZone implementation. Go straight to the allocator.\n        &#x2F;&#x2F; fixme store hasCustomAWZ in the non-meta class and \n        &#x2F;&#x2F; add it to canAllocFast&#39;s summary\n        if (fastpath(cls-&gt;canAllocFast())) &#123;\n            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.\n            bool dtor &#x3D; cls-&gt;hasCxxDtor();\n            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            obj-&gt;initInstanceIsa(cls, dtor);\n            return obj;\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.\n            id obj &#x3D; class_createInstance(cls, 0);\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            return obj;\n        &#125;\n    &#125;\n#endif\n\n    &#x2F;&#x2F; No shortcuts available.\n    if (allocWithZone) return [cls allocWithZone:nil];\n    return [cls alloc];\n&#125;\n\n\n通过class_createInstance创建类的实例\n\nid \nclass_createInstance(Class cls, size_t extraBytes)\n&#123;\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n&#125;\n\n\nstatic __attribute__((always_inline))  id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil) 方法\n\nstatic __attribute__((always_inline)) \nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct &#x3D; true, \n                              size_t *outAllocatedSize &#x3D; nil)\n&#123;\n    if (!cls) return nil;\n\n    assert(cls-&gt;isRealized());\n\n    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance\n    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();\n    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();\n    bool fast &#x3D; cls-&gt;canAllocNonpointer();\n\n    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize &#x3D; size;\n\n    id obj;\n    if (!zone  &amp;&amp;  fast) &#123;\n      \t&#x2F;&#x2F; 分配内存空间的方法\n        obj &#x3D; (id)calloc(1, size);\n        if (!obj) return nil;\n        &#x2F;&#x2F; 关联内存空间\n        &#x2F;&#x2F; obj 指向实例对象\n        obj-&gt;initInstanceIsa(cls, hasCxxDtor);\n    &#125; \n    else &#123;\n        if (zone) &#123;\n          &#x2F;&#x2F;  分配内存空间\n            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);\n        &#125; else &#123;\n          &#x2F;&#x2F; 分配内存空间\n            obj &#x3D; (id)calloc(1, size);\n        &#125;\n        if (!obj) return nil;\n\n        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be \n        &#x2F;&#x2F; doing something weird with the zone or RR.\n        obj-&gt;initIsa(cls);\n    &#125;\n\n    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;\n        obj &#x3D; _objc_constructOrFree(obj, cls);\n    &#125;\n\n    return obj;\n&#125;\n\n\n\n\n\n读取寄存器方法register read\n\n\n\n\n\n内存对齐size_t instanceSize(size_t extraBytes) &#123;\n        size_t size &#x3D; alignedInstanceSize() + extraBytes;\n        &#x2F;&#x2F; CF requires all objects be at least 16 bytes.\n        if (size &lt; 16) size &#x3D; 16;\n        return size;\n&#125;\n\n内存对齐\nuint32_t alignedInstanceSize() &#123;\n        return word_align(unalignedInstanceSize());\n    &#125;\n\n内存查看地址\n\n\n\n\n\n\n\n\n通过下面LLDB命令读取内从地址\nx p (倒着读取相应的数据)\n\n\n\nx&#x2F;4xg p （4xg 可以 5xg 6xg）\n\n","slug":"alloc","date":"2021-05-01T09:45:39.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"9d874e909a3a7a396d1451469b922294","title":"Mybatis对象关系映射","content":"对象/关系数据库映射(ORM)\n\n\n\n\n\n\n\n\nORM全称Object/Relation Mapping:表示对象-关系映射的缩写\nORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向 对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对 象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架 后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这 些面向对象的操作转换成底层SQL操作。ORM框架实现的效果:把对持久化对象的保存、修改、删除 等操作，转换为对数据库的操作\nMybatis简介MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映 射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML或注解来配置和映射原生类型、接口和Java的POJO (Plain Old Java Objects,普通老式Java对 象) 为数据库中的记录。\nMybatis优势Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n        &lt;transactionManager type=\"JDBC\"/>\n    &lt;!--Mybatis使用的连接池-->\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"password\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;!--引入映射文件件-->\n    &lt;mappers>\n        &lt;mapper resource=\"UserMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n\n配置文件解析其中，事务管理器(transactionManager)类型有两种:\n\nJDBC:这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作\n\n用域。\n\nMANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生 命周期(比如 JEE 应用服务器的上下文)。 默认情况下它会关闭连接，然而一些容器并不希望这样，因 此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。\n\n其中，数据源(dataSource)类型有三种:\n\n**UNPOOLED:**这个数据源的实现只是每次被请求时打开和关闭连接。\n\n**POOLED:**这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。\n\n**JNDI:**这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置 数据源，然后放置一个 JNDI 上下文的引用。\n\n\n@Test\n    public void demoTest() throws IOException &#123;\n\n        //加载核心配置文件\n        InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //获得sqlSession工厂对象\n        // 见解析配置文件，并创建建sqlSessionFactory 工厂\n        SqlSessionFactory sqlSessionFactory = new\n                SqlSessionFactoryBuilder().build(resourceAsStream);\n            //获得sqlSession对象，默认开启一个事务，但是不会自动提交事务，需要shou\n        SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句\n        List&lt;User> userList = sqlSession.selectList(\"userMapper.findAll\"); //打印结果\n        System.out.println(userList);\n        // sqlSession.insert(\"userMapper.saveUser\");\n//释放资源\n        sqlSession.close();\n    &#125;\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"userMapper\">\n    &lt;select id=\"findAll\" resultType=\"com.lagou.pojo.User\">\n    select * from User\n  &lt;/select>\n\n    &lt;insert id=\"saveUser\" parameterType=\"com.lagou.pojo.User\">\n        insert into user values(#&#123;id&#125;,#&#123;username&#125;)\n    &lt;/insert>\n\n    &lt;update id=\"updateUser\" parameterType=\"com.lagou.pojo.User\">\n        update user set username = #&#123;username&#125; where id = #&#123;id&#125;\n    &lt;/update>\n&lt;!--删除操作，都是随便写的-->\n    &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #&#123;id&#125;\n    &lt;/delete>\n\n&lt;/mapper>\n\nSqlSession会话对象\n\n\n\n\n\n\n\n\n SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和 获取映射器实例的方法。 执行语句的方法主要有：\n主要使用方法\n&lt;T> T selectOne(String statement, Object parameter)\n&lt;E> List&lt;E> selectList(String statement, Object parameter)\nint insert(String statement, Object parameter)\nint update(String statement, Object parameter)\nint delete(String statement, Object parameter)\n\n操作事务的方法\nvoid commit()\nvoid rollback()\n\n代理开发模式 代理开发方式介绍 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 \nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口 定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\nMapper 接口开发需要遵循以下规范：**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 **\n**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 **\n**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 **\n4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n","slug":"Mybatis对象关系映射","date":"2021-04-29T12:12:40.000Z","categories_index":"","tags_index":"Mybatis","author_index":"LittleStart"},{"id":"8d5bb184f1a8d1302f056982173a3dd0","title":"如何Category中增加属性","content":"如何在Category中增加属性（关联对象）在实际开发中，如果为Category添加一个属性，那么系统将不会为这个属性设置访问器方法，也就是setter和getter方法。这时候可以使用runtime提供的关联对象方法，动态地为该属性实现访问器方法。\n开发者可以将关联对象想象成一个Objective-C对象，这个对象通过一个预先设置好的key连接到类的一个实例上。runtime提供了如下方法让一个对象连接到其他对象。\nvoid objc_setAssociatedObject(id  _Nonnull NSObject, const void * _Nonnull key_, id  _Nullable value, objc_AssociationPolicy policy)\n\n参数object是将要被关联的对象。参数key是一个void指针。\n参数value是关联对象，它是id类型。\n参数policy是指定一个内存管理策略来处理关联对象如下：\n指定的策略 \n\nOBJC_ASSOCIATION_ASSIGN，那么被关联对象释放时，关联对象不会被释放，\n\n\nOBJC_ASSOCIATION_RETAIN或OBJC_ASSOCIATION_COPY，那么关联对象就会被释放。\n\nOBJC_ASSOCIATION_RETAIN_NONATOMIC和OBJC_ASSOCIATION_COPY_NONATOMIC两种策略，当需要在多个线程中处理访问关联对象的多线程代码时，就会变得非常有用。\n\n\nruntime还提供了移除关联对象的方法：\nobjc_removeAssociatedObjects(id  _Nonnull object)\n\n\n可以使用这个方法移除所有和参数object关联的对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。\n例子：\n给Person类别添加一个属性 address\n#import &quot;Person.h&quot;\n#import &lt;objc&#x2F;runtime.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface Person (Cate)\n\n@property (nonatomic, strong) NSString *address;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n\nPerson+Cate.m 文件\n#import &quot;Person+Cate.h&quot;\n\n@implementation Person (Cate)\n\n- (id)address &#123;\n    id value &#x3D; objc_getAssociatedObject(self, &quot;address&quot;);\n    return value;\n&#125;\n\n- (void)setAddress:(NSString *)address &#123;\n    objc_setAssociatedObject(self, &quot;address&quot;, address, OBJC_ASSOCIATION_RETAIN);\n&#125;\n\n@end\n\n\n结果说明已经成功地在Category中为类添加了一个新的属性，并且能够正常地使用这个属性。事实上，关联对象是使用哈希表实现的，将一个类映射到一张哈希表上，然后根据key找到关联对象，所以严格来说，关联对象和被关联对象没有任何关系，它不是存储在对象的内部。\n","slug":"如何Category中增加属性","date":"2021-04-29T11:17:24.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"afb2b07e802409f4fec5da7128301e15","title":"如何提高面试率.md","content":"\n“成功者讲方法，失败者讲理由！”虽然是一句老掉牙的话，但却饱含人生哲理。面对越来越激烈的竞争局面，以及后续大批新人的涌入，我们不仅要埋头苦干，提升自己的专业技能，更需要学会一些面试技巧，因为这些技巧会让你的求职之路事半功倍，为你赢得更多可能性。\n我的这些面试技巧分为，面试前准备、面试中展现，以及面试后复盘这三部分，有了这些技巧再加上你的专业技能，相信一定可以“披荆斩棘”斩获更多的 Offer，为自己的未来赢得更多可能。\n首先，是面试前准备凡事预则立不预则废，在正式“打仗”之前，我们一定要仔细研究“对手”，对于面试也是这样，只有预先准备才有可能获得成功，面试前或者是投简历前我们要先研究两个问题，第一，这个公司的主营业务是什么？第二，这个公司使用的技术栈是什么？研究了公司的主营业务后，你自然就会知道在简历中应体现哪些重点内容了。比如这家公司是做电商的，你之前既做过教育，又做过电商，也做过医疗，那么你应该重点将电商的项目经验和从业经历体现在简历上，这样你获得面试的概率和成功的概率就会大很多，毕竟公司都希望招聘到“更合适”的人。这里并不是鼓励你造假，只是提醒你可以从众多项目中，提取并展示和这个公司业务相匹配的项目。\n研究公司的技术栈也是同样的道理，技术经理也希望招来的人能直接上手，所以在写简历时或者面试时就可以重点向目标公司的技术栈靠拢。但有一点要特别注意，你说的这些技术点也是应聘单位擅长的技术栈，如果你真的懂，可以引导面试官往这个技术点上靠拢。但如果你对这些技术不是很擅长，切记千万不要这么做，这样只会适得其反，所以你应在简历和面试中重点突出你擅长的技术栈，并尽量向应聘公司的技术栈靠拢。除以上内容外，你还要准备一些常见的面试问题，比如你是如何看待加班的？你可以这样回答：你个人不认同无效加班，更倾向于以事情为导向，高效地处理完成工作，但如果公司赶项目或者有偶尔有加班的情况，自己也并不排斥，愿意跟着公司步伐走。又比如面试结尾，你还有什么问题要问我吗？等等类似的问题，都需要提前准备一下。\n在写简历时，还需要注意以下几点：• 第一，扬长避短，将优势点放在核心位置。比如你是大专文凭，那么就应该把教育背景写在简历的最下方也就是最不起眼的地方，而在最重要的位置优先展示自己的特长信息；• 第二，信息清晰，写清必要的内容。比如你要应聘的岗位以及期望薪资，而不是“面议”，因为有些 HR 看到信息模糊的简历会将其直接将其丢弃，因为她不确认你的能力和你期望的薪资是否匹配，如果应聘者很多的情况下，应聘单位就没必要“冒险”给一个不确定的人面试的机会了；• 第三，准确地描述项目经验。项目经验一般 3 个左右即可，需要描述的内容大致有：这个项目是什么？你负责什么模块？项目中使用了什么技术栈？项目的上线地址是什么？项目中有没有遇到什么问题？你是如何解决？等等内容。面试中展现在面试中你首先应该展示的是你的专业技术技能，让面试官充分了解你对某项技术的掌握情况，你可以深入讲解某个项目中的细节技术处理方案，或者通过一个深入的技术点展示你对这项技术的熟练掌握程度。如果你是学生的话，可以用成果证明，比如你的竞赛成绩或者获奖证书等。除了专业技能外，你还应在面试中展示你良好的沟通能力和理解能力，通过你的言行举止和沟通交流的内容，面试官便能对此有所察觉和判断，你需要注意的就是不要有抵抗或者是消极的情绪，正常发挥就行。面试中另一个需要注意的点就是要尽量展现你坦诚的一面。不会的知识点，回答不会就好，不要滥竽充数，也不要顾左右而言他，因为面试官一般都不傻，并且在面试的过程中，有不会的知识点和面试题也很正常，每个人不可能知道所有的答案，坦诚回答就好。\n另一个是和你的专业技能同样重要，在面试中你应该尽量展现你对技术的热爱，因为只有热爱的东西你才可能把它做好，它决定了你以后技术发展的速度和深度，因此面试官对此会特别在意，能展现你对技术的热爱的点有以下几个：• 写技术博客• 创作技术视频，比如在 B 站分享你的技术视频• 在 GitHub 上有参与开源项目或者自己的开源项目• 有自己的个人博客或者是其他个人工具网站• 出书或者是技术专栏\n以上这些方面，都是你对技术热爱的一些具体体现。最后在面试中你也要尽量展现你的求知欲，比如爱好看书、参加技术沙龙等，这些都能体现你对技术的孜孜追求，有追求的人进步一般都很快，因此也更受用人企业的欣赏和认同。\n","slug":"如何提高面试率","date":"2021-04-24T02:06:35.000Z","categories_index":"","tags_index":"iOS","author_index":"LittleStart"}]