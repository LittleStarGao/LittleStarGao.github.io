[{"id":"20c5d0afd79142c4ce377e5e3d6eadea","title":"alloc&init探究","content":"alloc 和 init 基本原理LGPerson *p &#x3D; [[LGPerson alloc] init];\n LGPerson *p1 &#x3D; [p init];\n &#x2F;&#x2F; objc_msgSend （id 消息接收者，sel 发送消息）\n LGPerson *p2 &#x3D; [p init];\n NSLog(@&quot;输出将结果如下： %p-%p-%p&quot;, p, p1, p2);\n NSLog(@&quot;end&quot;); &#x2F;&#x2F;\n\n1. 探究问题\nalloc 探究\nalloc 已经创建了对象init\nalloc 怎么实现创建\nalloc 实现- 原理-源码实现\n\n2. 探究方式\nlibobjc.A.dylib\n\n下断点： control + in - objc_alloc\n\n下符号断点：libobjc.A.dylib`+[NSObjject alloc]\n\n通过汇编方式libobjc.A.dylib\nDebug -&gt; Debug workflow -&gt; Always Show Disassembly\n\n\n![](alloc/截屏2021-05-01 下午6.01.02.png)\n\n\n注意：\n使用真机调试\n\nlibobjc.A.dylib 库关于 objc_alloc: \n\nalloc 方法实现\n首先申请内存空间，给指针地址\nregister read x0 方法读取寄存器的值\nx0 即是返回对象的地址，以及存储数据的地方\n\nalloc 实现源码执行的过程\n调用alloc方法\n\n+ (id)alloc &#123;\n  return _objc_rootAlloc(self);\n&#125;\n\n\n调用_objc_rootAlloc(Class cls) 方法\n\n_objc_rootAlloc(Class cls)\n&#123;\n    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);\n&#125;\n\n\nstatic ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) \n\nstatic ALWAYS_INLINE id\ncallAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)\n&#123;\n    if (slowpath(checkNil &amp;&amp; !cls)) return nil;\n\n#if __OBJC2__\n    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;\n        &#x2F;&#x2F; No alloc&#x2F;allocWithZone implementation. Go straight to the allocator.\n        &#x2F;&#x2F; fixme store hasCustomAWZ in the non-meta class and \n        &#x2F;&#x2F; add it to canAllocFast&#39;s summary\n        if (fastpath(cls-&gt;canAllocFast())) &#123;\n            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.\n            bool dtor &#x3D; cls-&gt;hasCxxDtor();\n            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            obj-&gt;initInstanceIsa(cls, dtor);\n            return obj;\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.\n            id obj &#x3D; class_createInstance(cls, 0);\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            return obj;\n        &#125;\n    &#125;\n#endif\n\n    &#x2F;&#x2F; No shortcuts available.\n    if (allocWithZone) return [cls allocWithZone:nil];\n    return [cls alloc];\n&#125;\n\n\n通过class_createInstance创建类的实例\n\nid \nclass_createInstance(Class cls, size_t extraBytes)\n&#123;\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n&#125;\n\n\nstatic __attribute__((always_inline))  id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil) 方法\n\nstatic __attribute__((always_inline)) \nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct &#x3D; true, \n                              size_t *outAllocatedSize &#x3D; nil)\n&#123;\n    if (!cls) return nil;\n\n    assert(cls-&gt;isRealized());\n\n    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance\n    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();\n    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();\n    bool fast &#x3D; cls-&gt;canAllocNonpointer();\n\n    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize &#x3D; size;\n\n    id obj;\n    if (!zone  &amp;&amp;  fast) &#123;\n      \t&#x2F;&#x2F; 分配内存空间的方法\n        obj &#x3D; (id)calloc(1, size);\n        if (!obj) return nil;\n        &#x2F;&#x2F; 关联内存空间\n        &#x2F;&#x2F; obj 指向实例对象\n        obj-&gt;initInstanceIsa(cls, hasCxxDtor);\n    &#125; \n    else &#123;\n        if (zone) &#123;\n          &#x2F;&#x2F;  分配内存空间\n            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);\n        &#125; else &#123;\n          &#x2F;&#x2F; 分配内存空间\n            obj &#x3D; (id)calloc(1, size);\n        &#125;\n        if (!obj) return nil;\n\n        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be \n        &#x2F;&#x2F; doing something weird with the zone or RR.\n        obj-&gt;initIsa(cls);\n    &#125;\n\n    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;\n        obj &#x3D; _objc_constructOrFree(obj, cls);\n    &#125;\n\n    return obj;\n&#125;\n\n\n\n\n\n读取寄存器方法register read\n\n![](alloc/截屏2021-05-01 下午6.53.54.png)\n","slug":"alloc","date":"2021-05-01T09:45:39.000Z","categories_index":"","tags_index":"","author_index":"LittleLight"},{"id":"9d874e909a3a7a396d1451469b922294","title":"Mybatis对象关系映射","content":"对象**/**关系数据库映射(ORM)\nORM全称Object/Relation Mapping:表示对象-关系映射的缩写\n\nORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向 对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对 象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架 后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这 些面向对象的操作转换成底层SQL操作。ORM框架实现的效果:把对持久化对象的保存、修改、删除 等操作，转换为对数据库的操作\nMybatis简介MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映 射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML或注解来配置和映射原生类型、接口和Java的POJO (Plain Old Java Objects,普通老式Java对 象) 为数据库中的记录。\nMybatis优势Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n        &lt;transactionManager type=\"JDBC\"/>\n    &lt;!--Mybatis使用的连接池-->\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"password\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;!--引入映射文件件-->\n    &lt;mappers>\n        &lt;mapper resource=\"UserMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n\n配置文件解析其中，事务管理器(transactionManager)类型有两种:\n\nJDBC:这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作\n\n用域。\n\nMANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生 命周期(比如 JEE 应用服务器的上下文)。 默认情况下它会关闭连接，然而一些容器并不希望这样，因 此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。\n\n其中，数据源(dataSource)类型有三种:\n\n**UNPOOLED:**这个数据源的实现只是每次被请求时打开和关闭连接。\n\n**POOLED:**这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。\n\n**JNDI:**这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置 数据源，然后放置一个 JNDI 上下文的引用。\n\n\n@Test\n    public void demoTest() throws IOException &#123;\n\n        //加载核心配置文件\n        InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //获得sqlSession工厂对象\n        // 见解析配置文件，并创建建sqlSessionFactory 工厂\n        SqlSessionFactory sqlSessionFactory = new\n                SqlSessionFactoryBuilder().build(resourceAsStream);\n            //获得sqlSession对象，默认开启一个事务，但是不会自动提交事务，需要shou\n        SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句\n        List&lt;User> userList = sqlSession.selectList(\"userMapper.findAll\"); //打印结果\n        System.out.println(userList);\n        // sqlSession.insert(\"userMapper.saveUser\");\n//释放资源\n        sqlSession.close();\n    &#125;\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"userMapper\">\n    &lt;select id=\"findAll\" resultType=\"com.lagou.pojo.User\">\n    select * from User\n  &lt;/select>\n\n    &lt;insert id=\"saveUser\" parameterType=\"com.lagou.pojo.User\">\n        insert into user values(#&#123;id&#125;,#&#123;username&#125;)\n    &lt;/insert>\n\n    &lt;update id=\"updateUser\" parameterType=\"com.lagou.pojo.User\">\n        update user set username = #&#123;username&#125; where id = #&#123;id&#125;\n    &lt;/update>\n&lt;!--删除操作，都是随便写的-->\n    &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #&#123;id&#125;\n    &lt;/delete>\n\n&lt;/mapper>\n\n\n\nSqlSession会话对象\n SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和 获取映射器实例的方法。 执行语句的方法主要有：\n\n主要使用方法\n&lt;T> T selectOne(String statement, Object parameter)\n&lt;E> List&lt;E> selectList(String statement, Object parameter)\nint insert(String statement, Object parameter)\nint update(String statement, Object parameter)\nint delete(String statement, Object parameter)\n\n操作事务的方法\nvoid commit()\nvoid rollback()\n\n\n\n代理开发模式 代理开发方式介绍 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 \nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口 定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\nMapper 接口开发需要遵循以下规范：**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 **\n**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 **\n**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 **\n4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n","slug":"Mybatis对象关系映射","date":"2021-04-29T12:12:40.000Z","categories_index":"","tags_index":"Mybatis","author_index":"LittleLight"},{"id":"8d5bb184f1a8d1302f056982173a3dd0","title":"如何Category中增加属性","content":"如何在Category中增加属性（关联对象）在实际开发中，如果为Category添加一个属性，那么系统将不会为这个属性设置访问器方法，也就是setter和getter方法。这时候可以使用runtime提供的关联对象方法，动态地为该属性实现访问器方法。\n开发者可以将关联对象想象成一个Objective-C对象，这个对象通过一个预先设置好的key连接到类的一个实例上。runtime提供了如下方法让一个对象连接到其他对象。\nvoid objc_setAssociatedObject(id  _Nonnull NSObject, const void * _Nonnull key_, id  _Nullable value, objc_AssociationPolicy policy)\n\n参数object是将要被关联的对象。参数key是一个void指针。\n参数value是关联对象，它是id类型。\n参数policy是指定一个内存管理策略来处理关联对象如下：\n指定的策略 \n\nOBJC_ASSOCIATION_ASSIGN，那么被关联对象释放时，关联对象不会被释放，\n\n\nOBJC_ASSOCIATION_RETAIN或OBJC_ASSOCIATION_COPY，那么关联对象就会被释放。\n\nOBJC_ASSOCIATION_RETAIN_NONATOMIC和OBJC_ASSOCIATION_COPY_NONATOMIC两种策略，当需要在多个线程中处理访问关联对象的多线程代码时，就会变得非常有用。\n\n\nruntime还提供了移除关联对象的方法：\nobjc_removeAssociatedObjects(id  _Nonnull object)\n\n\n可以使用这个方法移除所有和参数object关联的对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。\n例子：\n给Person类别添加一个属性 address\n#import &quot;Person.h&quot;\n#import &lt;objc&#x2F;runtime.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface Person (Cate)\n\n@property (nonatomic, strong) NSString *address;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n\nPerson+Cate.m 文件\n#import &quot;Person+Cate.h&quot;\n\n@implementation Person (Cate)\n\n- (id)address &#123;\n    id value &#x3D; objc_getAssociatedObject(self, &quot;address&quot;);\n    return value;\n&#125;\n\n- (void)setAddress:(NSString *)address &#123;\n    objc_setAssociatedObject(self, &quot;address&quot;, address, OBJC_ASSOCIATION_RETAIN);\n&#125;\n\n@end\n\n\n结果说明已经成功地在Category中为类添加了一个新的属性，并且能够正常地使用这个属性。事实上，关联对象是使用哈希表实现的，将一个类映射到一张哈希表上，然后根据key找到关联对象，所以严格来说，关联对象和被关联对象没有任何关系，它不是存储在对象的内部。\n","slug":"如何Category中增加属性","date":"2021-04-29T11:17:24.000Z","categories_index":"","tags_index":"","author_index":"LittleLight"},{"id":"afb2b07e802409f4fec5da7128301e15","title":"如何提高面试率.md","content":"\n“成功者讲方法，失败者讲理由！”虽然是一句老掉牙的话，但却饱含人生哲理。面对越来越激烈的竞争局面，以及后续大批新人的涌入，我们不仅要埋头苦干，提升自己的专业技能，更需要学会一些面试技巧，因为这些技巧会让你的求职之路事半功倍，为你赢得更多可能性。\n我的这些面试技巧分为，面试前准备、面试中展现，以及面试后复盘这三部分，有了这些技巧再加上你的专业技能，相信一定可以“披荆斩棘”斩获更多的 Offer，为自己的未来赢得更多可能。\n首先，是面试前准备凡事预则立不预则废，在正式“打仗”之前，我们一定要仔细研究“对手”，对于面试也是这样，只有预先准备才有可能获得成功，面试前或者是投简历前我们要先研究两个问题，第一，这个公司的主营业务是什么？第二，这个公司使用的技术栈是什么？研究了公司的主营业务后，你自然就会知道在简历中应体现哪些重点内容了。比如这家公司是做电商的，你之前既做过教育，又做过电商，也做过医疗，那么你应该重点将电商的项目经验和从业经历体现在简历上，这样你获得面试的概率和成功的概率就会大很多，毕竟公司都希望招聘到“更合适”的人。这里并不是鼓励你造假，只是提醒你可以从众多项目中，提取并展示和这个公司业务相匹配的项目。\n研究公司的技术栈也是同样的道理，技术经理也希望招来的人能直接上手，所以在写简历时或者面试时就可以重点向目标公司的技术栈靠拢。但有一点要特别注意，你说的这些技术点也是应聘单位擅长的技术栈，如果你真的懂，可以引导面试官往这个技术点上靠拢。但如果你对这些技术不是很擅长，切记千万不要这么做，这样只会适得其反，所以你应在简历和面试中重点突出你擅长的技术栈，并尽量向应聘公司的技术栈靠拢。除以上内容外，你还要准备一些常见的面试问题，比如你是如何看待加班的？你可以这样回答：你个人不认同无效加班，更倾向于以事情为导向，高效地处理完成工作，但如果公司赶项目或者有偶尔有加班的情况，自己也并不排斥，愿意跟着公司步伐走。又比如面试结尾，你还有什么问题要问我吗？等等类似的问题，都需要提前准备一下。\n在写简历时，还需要注意以下几点：• 第一，扬长避短，将优势点放在核心位置。比如你是大专文凭，那么就应该把教育背景写在简历的最下方也就是最不起眼的地方，而在最重要的位置优先展示自己的特长信息；• 第二，信息清晰，写清必要的内容。比如你要应聘的岗位以及期望薪资，而不是“面议”，因为有些 HR 看到信息模糊的简历会将其直接将其丢弃，因为她不确认你的能力和你期望的薪资是否匹配，如果应聘者很多的情况下，应聘单位就没必要“冒险”给一个不确定的人面试的机会了；• 第三，准确地描述项目经验。项目经验一般 3 个左右即可，需要描述的内容大致有：这个项目是什么？你负责什么模块？项目中使用了什么技术栈？项目的上线地址是什么？项目中有没有遇到什么问题？你是如何解决？等等内容。面试中展现在面试中你首先应该展示的是你的专业技术技能，让面试官充分了解你对某项技术的掌握情况，你可以深入讲解某个项目中的细节技术处理方案，或者通过一个深入的技术点展示你对这项技术的熟练掌握程度。如果你是学生的话，可以用成果证明，比如你的竞赛成绩或者获奖证书等。除了专业技能外，你还应在面试中展示你良好的沟通能力和理解能力，通过你的言行举止和沟通交流的内容，面试官便能对此有所察觉和判断，你需要注意的就是不要有抵抗或者是消极的情绪，正常发挥就行。面试中另一个需要注意的点就是要尽量展现你坦诚的一面。不会的知识点，回答不会就好，不要滥竽充数，也不要顾左右而言他，因为面试官一般都不傻，并且在面试的过程中，有不会的知识点和面试题也很正常，每个人不可能知道所有的答案，坦诚回答就好。\n另一个是和你的专业技能同样重要，在面试中你应该尽量展现你对技术的热爱，因为只有热爱的东西你才可能把它做好，它决定了你以后技术发展的速度和深度，因此面试官对此会特别在意，能展现你对技术的热爱的点有以下几个：• 写技术博客• 创作技术视频，比如在 B 站分享你的技术视频• 在 GitHub 上有参与开源项目或者自己的开源项目• 有自己的个人博客或者是其他个人工具网站• 出书或者是技术专栏\n以上这些方面，都是你对技术热爱的一些具体体现。最后在面试中你也要尽量展现你的求知欲，比如爱好看书、参加技术沙龙等，这些都能体现你对技术的孜孜追求，有追求的人进步一般都很快，因此也更受用人企业的欣赏和认同。\n","slug":"如何提高面试率","date":"2021-04-24T02:06:35.000Z","categories_index":"","tags_index":"iOS","author_index":"LittleLight"}]