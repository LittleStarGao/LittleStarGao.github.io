[{"id":"72c9fa0d926f81572e4b5de9847c1152","title":"《腾讯iOS测试实践》学习（一）","content":"\n\n工程效率\n\n\n\n\n\n\n\n\n 需求评审：需求评审机制以及更新通知，避免需求有改动而没有及时同步到相关角色。\n\n代码质量：静态代码扫描，千行代码缺陷率等。\n架构评审：代码架构的讨论以及评审。\nBug流程：Bug生命周期，避免随便修改Bug状态以及备注缺失。\nCode Review：代码评审，如果有代码评审委员会就更好了。\nDogfood：自己做的产品自己（项目各成员）先体验。\nShowcase：完成某个特性，可以通过会议针对某个特性进行展示，一般由产品经理主持。\n\n测试工程师最主要的工作内容\n测试周期：\n\n测试与研发周期是密切关联的，包括迭代测试、集成测试、回归测试、上线测试等，每个阶段都要把握好测试效率和测试资源分配。\n\n\n测试设计：\n\n包括需求覆盖度、用例覆盖度、用例执行效率等。\n\n\n自动化测试：\n\n使用自动化执行的方式进行测试，可以快速得出测试结果，节省人力成本。\n\n\n静态代码分析：\n\n使用一定的工具来对代码进行静态扫描，提前发现代码隐藏的问题。\n\n\n\n","slug":"《腾讯iOS测试实践》学习（一）","date":"2021-10-01T03:47:01.990Z","categories_index":"","tags_index":"iOS测试","author_index":"LittleStart"},{"id":"69226c43fa619d7df7756bf099da8b7a","title":"iOS设计模式（一）","content":"类继承和对象组合\n类继承简单直接、硬卧关系在编译静态定义\n被复用的实现易于修改\n\n缺点：\n\n因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现\n子类描述在父类、\n子类直接面对父类的封装、因此破坏了封装\n父类实现的任何变更都会强制爱子类到的变更\n因为在新的问题场景下京城实现过时或者不使用，所以必须重写父类或继承来实现\n\n只从协议或者抽象的基类继承、应为他们只有很少的实现，而协议没有\n对象组合让我们同时使用多个对象，而每个对象都假定其他对象接口正常运行，\n优点：\n不会破坏封装，只能通过接口来访问对象\n大大减少实现的依存关系、因为对象实现是通过接口定义的\n可以运行时任意对象替换为其他同类型对象\n有助于保持类的封装、以专注单一任务\n类及其层次结构能保持简洁，不至于过度膨胀而无法管理\n\n\n缺点：\n设计中涉及较多对象\n系统的行为将依赖于不同对象间的关系、而不是定义在单个类中\n\n\n\n\n\n\n\n\n\n\n\n\n优先使用对象组合而不是类继承、类继承与对象可以配合，找出冗余设计，此处应该使用类继承。\n\n圆角 ： 类实体\n抽象斜体\n抽象\n\n\n","slug":"iOS设计模式（一）","date":"2021-09-30T12:30:53.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"78bacd8b33e55bbfb6a2cbf684cbf20b","title":"单元测试","content":"别测试代码，而应该验证程序的行为测试应该只在程序的行为和预期的不一样时，才不通过。测试应该测试程序的代码做了什么，而不是测试程序如何实现。\n\n验证应用程序做了什么的，叫做行为测试。\n即使应用程序的行为不发生变化，只要应用程序的代码发生了变化，测试就不通过的，叫做脆性测试。\n\n假设我们有一个香蕉数据库，叫做 GorillaDB。GorillaDB 是一个以键－值对来储存香蕉的数据库。我们可以用这样的方式储存香蕉：\nlet database = GorillaDB()\nlet banana = Banana()\ndatabase.save(banana: banana, key: \"my-banana\")\n\n之后可以从数据库里取回香蕉：\nlet banana = database.load(key: \"my-banana\")\n\n行为测试编写行为测试的关键，就是准确的定位你想让你的程序代码做什么。\n在我们的 testSave_savesTheBananaToTheDatabase 的测试中：当我们在数据库中储存一根香蕉时，我们所希望程序完成的是一个怎样的行为呢？应该是保存香蕉，即之后可以取回香蕉。因此，我们不该测试数据库大小的增加，而应该测试我们能不能从数据库里取回香蕉。\n编写行为测试的关键，就在于思考这些问题：\n\n这段程序代码是用来做什么的？\n我的测试只验证了程序的行为吗？它可能因为代码运行的其他原因而不通过吗？\n\nNimber 断言expect(1 + 1).to(equal(2))\nexpect(1.2).to(beCloseTo(1.1, within: 0.1))\nexpect(3) > 2\nexpect(\"seahorse\").to(contain(\"sea\"))\nexpect([\"Atlantic\", \"Pacific\"]).toNot(contain(\"Mississippi\"))\nexpect(ocean.isClean).toEventually(beTruthy())\n\n\n\n用 Quick 例子和例子群组织测试Quick 使用特殊的语法定义例子（examples）和例子群（example groups）。\n在*编写高效的 XCTest 测试: Arrange，Act 和 Assert*，我们了解了一个好的测试方法名称是至关重要的，尤其是当测试失败时。它能够帮助我们判断是修改程序代码或者是更新测试内容。\nQuick 的例子和例子群主要有两个目的：\n\n它们促使你使用具有描述性的测试名称。\n它们极大地简化了 Arrange 步骤的测试代码。\n\n例子：使用 it定义了 it 函数的例子，使用断言代码指明了程序应有的行为。这些就像 XCTest 中的测试方法一样。\nit 函数有两个参数：例子的名称和闭包。下面这个例子具体说明了 Sea.Dolphin 类应有的行为。 一只新的海豚（dolphin）应该是聪明（smart）且友好（friendly）的：\n// Swift\n\nimport Quick\nimport Nimble\nimport Sea\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    it(\"is friendly\") &#123;\n      expect(Dolphin().isFriendly).to(beTruthy())\n    &#125;\n\n    it(\"is smart\") &#123;\n      expect(Dolphin().isSmart).to(beTruthy())\n    &#125;\n  &#125;\n&#125;\n// Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\nit(@\"is friendly\", ^&#123;\n  expect(@([[Dolphin new] isFriendly])).to(beTruthy());\n&#125;);\n\nit(@\"is smart\", ^&#123;\n  expect(@([[Dolphin new] isSmart])).to(beTruthy());\n&#125;);\n\nQuickSpecEnd\n\n\n\n用描述性的语言使例子所测试的内容清晰明了。 描述性的语言可以是任意长度、任意字符的，涵盖了英语以及其他语言的字符，甚至可以是表情符号！✌️ 😎\n例子群：使用 describe 和 context例子群是按一定逻辑关系组织的例子。例子群里可以共享配置（setup）和卸载（teardown）代码。\n使用 describe 描述类和方法为了具体说明 Dolphin 类中 click 方法的行为 —— 换句话说，为了验证这个方法可用 —— 我们可以把多个 it 例子用 describe 函数组织成为一个群。把相同的例子组织在一起能更方便阅读：\n// Swift\n\nimport Quick\nimport Nimble\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    describe(\"a dolphin\") &#123;\n      describe(\"its click\") &#123;\n        it(\"is loud\") &#123;\n          let click = Dolphin().click()\n          expect(click.isLoud).to(beTruthy())\n        &#125;\n\n        it(\"has a high frequency\") &#123;\n          let click = Dolphin().click()\n          expect(click.hasHighFrequency).to(beTruthy())\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n// Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\ndescribe(@\"a dolphin\", ^&#123;\n  describe(@\"its click\", ^&#123;\n    it(@\"is loud\", ^&#123;\n      Click *click = [[Dolphin new] click];\n      expect(@(click.isLoud)).to(beTruthy());\n    &#125;);\n\n    it(@\"has a high frequency\", ^&#123;\n      Click *click = [[Dolphin new] click];\n      expect(@(click.hasHighFrequency)).to(beTruthy());\n    &#125;);\n  &#125;);\n&#125;);\n\nQuickSpecEnd\n\n当这两个例子在 Xcode 中运行的时候，它们会从 describe 和 it 函数中输出一些描述性的语言：\n\nDolphinSpec.a_dolphin_its_click_is_loud\nDolphinSpec.a_dolphin_its_click_has_a_high_frequency\n\n显然，这两个测试各自测试的内容都很清晰明了。\n使用 beforeEach 和 afterEach 共享配置／卸载代码例子群不仅使它包含的例子更清晰易懂，还有助于在群里共享配置和卸载的代码。\n在下面的这个示例里，例子群中的每一个例子前面，都用 beforeEach 这个函数创建一种新类型的海豚以及它特定的叫声。 这就保证了对每个例子进行了初始化：\n&#x2F;&#x2F; Swift\n\nimport Quick\nimport Nimble\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    describe(&quot;a dolphin&quot;) &#123;\n      var dolphin: Dolphin!\n      beforeEach &#123;\n        dolphin &#x3D; Dolphin()\n      &#125;\n\n      describe(&quot;its click&quot;) &#123;\n        var click: Click!\n        beforeEach &#123;\n          click &#x3D; dolphin.click()\n        &#125;\n\n        it(&quot;is loud&quot;) &#123;\n          expect(click.isLoud).to(beTruthy())\n        &#125;\n\n        it(&quot;has a high frequency&quot;) &#123;\n          expect(click.hasHighFrequency).to(beTruthy())\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\ndescribe(@&quot;a dolphin&quot;, ^&#123;\n  __block Dolphin *dolphin &#x3D; nil;\n  beforeEach(^&#123;\n      dolphin &#x3D; [Dolphin new];\n  &#125;);\n\n  describe(@&quot;its click&quot;, ^&#123;\n    __block Click *click &#x3D; nil;\n    beforeEach(^&#123;\n      click &#x3D; [dolphin click];\n    &#125;);\n\n    it(@&quot;is loud&quot;, ^&#123;\n      expect(@(click.isLoud)).to(beTruthy());\n    &#125;);\n\n    it(@&quot;has a high frequency&quot;, ^&#123;\n      expect(@(click.hasHighFrequency)).to(beTruthy());\n    &#125;);\n  &#125;);\n&#125;);\n\nQuickSpecEnd\n\n对于海豚这个例子来说，像这样共享配置代码并不是一个很大的工程。但是对于更复杂的对象，共享代码能够省去大量写代码的时间！\n如果想在每个例子后面执行特定的代码，可以使用 afterEach。\n使用 context 指定条件的行为海豚使用叫声进行回声定位。当接近了它们感兴趣的东西时，海豚会发出一系列的超声波对其进行更准确的探测。\n这个测试需要展示在不同环境下，click 方法的不同行为。通常，海豚只叫（click）一声。但是当海豚接近它们感兴趣的东西时，它会发出很多次叫声。\n这种情况可以用 context 函数来表示：一个 context 代表正常情况，另一个 context 代表海豚接近感兴趣的东西：\n&#x2F;&#x2F; Swift\n\nimport Quick\nimport Nimble\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    describe(&quot;a dolphin&quot;) &#123;\n      var dolphin: Dolphin!\n      beforeEach &#123; dolphin &#x3D; Dolphin() &#125;\n\n      describe(&quot;its click&quot;) &#123;\n        context(&quot;when the dolphin is not near anything interesting&quot;) &#123;\n          it(&quot;is only emitted once&quot;) &#123;\n            expect(dolphin.click().count).to(equal(1))\n          &#125;\n        &#125;\n\n        context(&quot;when the dolphin is near something interesting&quot;) &#123;\n          beforeEach &#123;\n            let ship &#x3D; SunkenShip()\n            Jamaica.dolphinCove.add(ship)\n            Jamaica.dolphinCove.add(dolphin)\n          &#125;\n\n          it(&quot;is emitted three times&quot;) &#123;\n            expect(dolphin.click().count).to(equal(3))\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; Objective-C\n\n@import Quick;\n@import Nimble;\n\nQuickSpecBegin(DolphinSpec)\n\ndescribe(@&quot;a dolphin&quot;, ^&#123;\n  __block Dolphin *dolphin &#x3D; nil;\n  beforeEach(^&#123; dolphin &#x3D; [Dolphin new]; &#125;);\n\n  describe(@&quot;its click&quot;, ^&#123;\n    context(@&quot;when the dolphin is not near anything interesting&quot;, ^&#123;\n      it(@&quot;is only emitted once&quot;, ^&#123;\n        expect(@([[dolphin click] count])).to(equal(@1));\n      &#125;);\n    &#125;);\n\n    context(@&quot;when the dolphin is near something interesting&quot;, ^&#123;\n      beforeEach(^&#123;\n        [[Jamaica dolphinCove] add:[SunkenShip new]];\n        [[Jamaica dolphinCove] add:dolphin];\n      &#125;);\n\n      it(@&quot;is emitted three times&quot;, ^&#123;\n        expect(@([[dolphin click] count])).to(equal(@3));\n      &#125;);\n    &#125;);\n  &#125;);\n&#125;);\n\nQuickSpecEnd\n\n严格地说，context 是 describe 的一种同义的表达，但是像这样有目的地使用能够让你的代码更容易理解。\n测试的可读性：Quick 和 XCTest在*编写高效的 XCTest 测试: Arrange，Act 和 Assert*里，我们知道了对每种情况进行一个测试能够很方便地组织测试代码。 在 XCTest 里，这样做会导致出现冗长的测试方法名称：\nfunc testDolphin_click_whenTheDolphinIsNearSomethingInteresting_isEmittedThreeTimes() &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\n使用 Quick ，每种情况会更容易阅读，并且我们能够为每一个例子群进行配置：\ndescribe(\"a dolphin\") &#123;\n  describe(\"its click\") &#123;\n    context(\"when the dolphin is near something interesting\") &#123;\n      it(\"is emitted three times\") &#123;\n        // ...\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n临时禁用例子或例子群你可以临时禁用那些测试不通过的例子和例子群。 这些例子的名称会随着测试结果一起打印在控制台里，但它们并不运行。\n通过添加前缀 x 就能禁用例子或例子群：\n&#x2F;&#x2F; Swift\n\nxdescribe(&quot;its click&quot;) &#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;\n\nxcontext(&quot;when the dolphin is not near anything interesting&quot;) &#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;\n\nxit(&quot;is only emitted once&quot;) &#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;\n&#x2F;&#x2F; Objective-C\n\nxdescribe(@&quot;its click&quot;, ^&#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;);\n\nxcontext(@&quot;when the dolphin is not near anything interesting&quot;, ^&#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;);\n\nxit(@&quot;is only emitted once&quot;, ^&#123;\n  &#x2F;&#x2F; ...none of the code in this closure will be run.\n&#125;);\n\n临时运行一部分例子在某些情况下，只关注一个或几个例子有助于测试。毕竟只运行一两个例子比运行整个测试快多了。通过使用 fit 函数，你可以只运行一两个例子。你还可以使用 fdescribe 或 fcontext 把测试重点放在一个例子群：\nfit(&quot;is loud&quot;) &#123;\n  &#x2F;&#x2F; ...only this focused example will be run.\n&#125;\n\nit(&quot;has a high frequency&quot;) &#123;\n  &#x2F;&#x2F; ...this example is not focused, and will not be run.\n&#125;\n\nfcontext(&quot;when the dolphin is near something interesting&quot;) &#123;\n  &#x2F;&#x2F; ...examples in this group are also focused, so they&#39;ll be run.\n&#125;\nfit(@&quot;is loud&quot;, &#123;\n  &#x2F;&#x2F; ...only this focused example will be run.\n&#125;);\n\nit(@&quot;has a high frequency&quot;, ^&#123;\n  &#x2F;&#x2F; ...this example is not focused, and will not be run.\n&#125;);\n\nfcontext(@&quot;when the dolphin is near something interesting&quot;, ^&#123;\n  &#x2F;&#x2F; ...examples in this group are also focused, so they&#39;ll be run.\n&#125;);\n\n\n\n使用 beforeSuite 和 afterSuite 进行全局配置／卸载有一些测试的配置需要在所有例子运行之前进行。对于这种情况，可以使用 beforeSuite 和 afterSuite 。\n下面的示例展示了在所有其他例子运行之前，创建一个包含了海洋中所有生物的数据库。当所有例子运行结束的时候，这个数据库就被卸载：\n&#x2F;&#x2F; Swift\n\nimport Quick\n\nclass DolphinSpec: QuickSpec &#123;\n  override func spec() &#123;\n    beforeSuite &#123;\n      OceanDatabase.createDatabase(name: &quot;test.db&quot;)\n      OceanDatabase.connectToDatabase(name: &quot;test.db&quot;)\n    &#125;\n\n    afterSuite &#123;\n      OceanDatabase.teardownDatabase(name: &quot;test.db&quot;)\n    &#125;\n\n    describe(&quot;a dolphin&quot;) &#123;\n      &#x2F;&#x2F; ...\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F; Objective-C\n\n@import Quick;\n\nQuickSpecBegin(DolphinSpec)\n\nbeforeSuite(^&#123;\n  [OceanDatabase createDatabase:@&quot;test.db&quot;];\n  [OceanDatabase connectToDatabase:@&quot;test.db&quot;];\n&#125;);\n\nafterSuite(^&#123;\n  [OceanDatabase teardownDatabase:@&quot;test.db&quot;];\n&#125;);\n\ndescribe(@&quot;a dolphin&quot;, ^&#123;\n  &#x2F;&#x2F; ...\n&#125;);\n\nQuickSpecEnd\n\n你可以添加多个 beforeSuite 和 afterSuite 。所有的 beforeSuite 闭包都会在其它测试运行前执行，同样，所有的 afterSuite 闭包都会在其它测试运行结束后执行。 但是这些闭包并不一定按先后顺序执行。\n访问当前例子的元数据在某些情况下，你会想知道当前运行的例子的名称，或者目前已经运行了多少例子。Quick 提供了闭包 beforeEach 和 afterEach ，通过这些闭包，可以访问元数据。\nbeforeEach &#123; exampleMetadata in\n  println(&quot;Example number \\(exampleMetadata.exampleIndex) is about to be run.&quot;)\n&#125;\n\nafterEach &#123; exampleMetadata in\n  println(&quot;Example number \\(exampleMetadata.exampleIndex) has run.&quot;)\n&#125;\nbeforeEachWithMetadata(^(ExampleMetadata *exampleMetadata)&#123;\n  NSLog(@&quot;Example number %l is about to be run.&quot;, (long)exampleMetadata.exampleIndex);\n&#125;);\n\nafterEachWithMetadata(^(ExampleMetadata *exampleMetadata)&#123;\n  NSLog(@&quot;Example number %l has run.&quot;, (long)exampleMetadata.exampleIndex);\n&#125;);\n\n\n\nNimber 断言函数列举Nimble中的匹配函数\n用途    函数等值判断使用equal函数\nexpect(actual).to(equal(expected))\nexpect(actual) == expected\nexpect(actual) != expected\n是否是同一个对象\n使用beIdenticalTo函数\nexpect(actual).to(beIdenticalTo(expected))\nexpect(actual) === expected\nexpect(actual) !== expected\n比较expect(actual).to(beLessThan(expected))\nexpect(actual) &lt; expected\nexpect(actual).to(beLessThanOrEqualTo(expected))\nexpect(actual) &lt;= expected\nexpect(actual).to(beGreaterThan(expected))\nexpect(actual) &gt; expected\nexpect(actual).to(beGreaterThanOrEqualTo(expected)) expect(actual) &gt;= expected\n比较浮点数expect(10.01).to(beCloseTo(10, within: 0.1))\n类型检查\nexpect(instance).to(beAnInstanceOf(aClass)) expect(instance).to(beAKindOf(aClass))\n是否为真\n// Passes if actual is not nil, true, or an object with a boolean value of true:\nexpect(actual).to(beTruthy())\n// Passes if actual is only true (not nil or an object conforming to BooleanType true):\nexpect(actual).to(beTrue())\n// Passes if actual is nil, false, or an object with a boolean value of false:\nexpect(actual).to(beFalsy())\n// Passes if actual is only false (not nil or an object conforming to BooleanType false):\nexpect(actual).to(beFalse())\n// Passes if actual is nil:\nexpect(actual).to(beNil())\n是否有异常\n// Passes if actual, when evaluated, raises an exception: expect(actual).to(raiseException())\n// Passes if actual raises an exception with the given name:\nexpect(actual).to(raiseException(named: name))\n// Passes if actual raises an exception with the given name and reason:\nexpect(actual).to(raiseException(named: name, reason: reason))\n// Passes if actual raises an exception and it passes expectations in the block\n// (in this case, if name begins with ‘a r’)\nexpect { exception.raise() }.to(raiseException { (exception: NSException) in\n expect(exception.name).to(beginWith(&quot;a r&quot;))\n\n})\n集合关系\n// Passes if all of the expected values are members of actual:\nexpect(actual).to(contain(expected…))\nexpect([“whale”, “dolphin”, “starfish”]).to(contain(“dolphin”, “starfish”))\n// Passes if actual is an empty collection (it contains no elements):\nexpect(actual).to(beEmpty())\n字符串\n// Passes if actual contains substring expected: expect(actual).to(contain(expected))\n// Passes if actual begins with substring: expect(actual).to(beginWith(expected))\n// Passes if actual ends with substring: expect(actual).to(endWith(expected))\n// Passes if actual is an empty string, “”: expect(actual).to(beEmpty())\n// Passes if actual matches the regular expression defined in expected:\nexpect(actual).to(match(expected))\n检查集合中的所有元素是否符合条件\n// with a custom function:\nexpect([1,2,3,4]).to(allPass({$0 &lt; 5}))\n// with another matcher: expect([1,2,3,4]).to(allPass(beLessThan(5)))\n检查集合个数\nexpect(actual).to(haveCount(expected))\n匹配任意一种检查\n// passes if actual is either less than 10 or greater than 20 expect(actual).to(satisfyAnyOf(beLessThan(10), beGreaterThan(20)))\n// can include any number of matchers – the following will pass\nexpect(6).to(satisfyAnyOf(equal(2), equal(3), equal(4), equal(5), equal(6), equal(7)))\n// in Swift you also have the option to use the || operator to achieve a similar function expect(82).to(beLessThan(50) || beGreaterThan(80))\n————————————————\n","slug":"unit-test","date":"2021-07-13T03:32:17.000Z","categories_index":"","tags_index":"单元测试","author_index":"LittleStart"},{"id":"08c633a5de2fe3edfdf41cfdec1b1bae","title":"iOS 组件化拆分总结","content":"组件化一、为何要组件化?\n\n\n\n\n\n\n\n\n这是我们在做组件化的时候要思考的，它的优点和缺点是什么，这样我们对组件化有个基本认识\n1. 组件化定义\n组件是由一个或多个类构成，能完整描述一个业务场景，并能被其他业务场景复用的功能单位。\n比如内存，硬盘，CPU，显示器等，拿出其中任何一个部件都能被其他的PC所使用。\n日志服务，VOIP服务，内存管理服务等等。说白了我们目标是站在更高的维度去封装功能单元。对这些功能单元进行进一步的分类，才能在具体的业务场景下做更合理的设计。\n\n2. 组件化实施条件\n前期项目比较小，可以按照原有传统的方式进行开发\n随着项目的功能变的复杂，团队扩大，会发现传统的开发方式导致代码管理混乱，发布、集成、测试越来越麻烦，被迫走向组件化的道路\n如果你的团队在不断发展，产品线也越来越多的时候，预计后期可能会更多的时候，那么最好尽早把组件化拆分\n把一些业务、基础功能剥离，划分为一个个的模块，然后通过pods的方式管理而已，同时要搭配一套后台的自动集成、发布、测试流程\n\n3. 普通模式存在问题\n代码冲突多，编译慢。\n迭代速度慢，耦合比较严重，无法单独测试。\n\n4. 组件化优点\n\n\n\n\n\n\n\n\n组件化就是把整个项目进行拆分，分成一个个单独的可独立运行的组件，分开管理，减少依赖。\n\n加快编译速度，可以把不会经常变动的组件做成静态库，同时每个组件可以独立编译，不依赖于主工程或者其他组件\n\n每个组件都可以选择自己擅长的开发模式（MVC / MVVM / MVP）\n\n可以单独测试每个组件\n\n多条业务线可以并行开发，提高开发效率\n\n\n\n\n\n\n\n\n\n\n\n组件化方案在App业务稳定，且规模（业务规模和开发团队规模）增长初期去实施非常重要，它助于将复杂App分而治之，也有助于多人大型团队的协同开发。但组件化方案不适合在业务不稳定的情况下过早实施，至少要等产品已经经过MVP阶段时才适合实施组件化。因为业务不稳定意味着链路不稳定，在不稳定的链路上实施组件化会导致将来主业务产生变化时，全局性模块调度和重构会变得相对复杂。\n总结：\n业务稳定的模块先进行组件化，业务在变化的随着业务稳定之后再做抽离组件化\n\n组件化方案\n\n\n\n\n\n\n\n\n 看上去各家都是各显神通，都有自己的技术方案，但是实际上都可以归类到如下两种方案：\n\n利用runtime实现的target-action方法\n利用url-scheme方案\n\nURL-Scheme库：\n\nJLRoutes\nroutable-ios\nHHRouter\nMGJRouter\nFRDIntent/Intent\n\nTarget-Action库：\n\nCTMediator\n\n路由的设计思路\nURL-Sheme方案一般都是各个组件把自己可以提供的服务通过url的形式注册到一个中心管理器，然后调用发就可以通过openURL的方式来打开这个url，然后中心管理器解析这个url，把请求转发到相应的组件去执行\nTarget-Action方案利用了OC的runtime特性，无需注册，直接在原有的组件之外加一层wrapper，把对外提供的服务都抽离到该层。然后通过runtime的TARGET performSelector:ACTION withObject:PARAMS找到对应的组件，执行方法和传递参数。\n\n实施步骤\n模块化是一个浩大的工程，对于项目有着重大影响。我们在确定目标之后，接着制定了有一个详细的计划。然后按计划一步步实施。\n第一个要解决的问题就是如何拆分组件。这是一个见仁见智的问题，没有太明确的划分边界，大致做到每个组件只包含一个功能即可，具体实施还是要根据实际情况权衡。\n站在更高的维度去封装功能单元，把多个功能单元组合在一起形成一个更大的功能单元，也就是组件。对这些功能单元进行进一步的分类，才能在具体的业务场景下做更合理的设计。\n\n1. 文件夹隔离\n\n\n\n\n\n\n\n\n\n 我们首先需要改变项目的文件组织结构\n\n项目简单地以 View / Controller / Model 划分各类文件。\n\n现在改为每个功能模块都有自己如下模块文件夹，从而先实现文件夹隔离\n\nView \nController\nViewModel\nModel\nNetwork \n\n\n虽然改为按模块组织项目的文件结构，但此时，所有模块仍然还在一个仓库里。这其实只是做到了文件夹隔离，代码并没有被真正隔离\n\n我们会查看各个文件的 #import 部分，减少业务模块间的相互依赖。几个业务模块都用到的文件，则会沉入到公共层\n\n文件夹隔离也为团队提供了一个转变开发方式的缓冲期\n\n文件夹隔离使得组员逐步适应模块化的思维，后续的产品功能也被归入到对应的模块之中\n\n\n2. 抽象出业务无关的库\n我们同时也鼓励将一些业务无关的代码抽象成一个个独立的库。这类库应该是与产品无关，与业务无关的。\n\n拆分出去的模块，必须先处理好它的依赖，它将只能依赖已经拆分出去的组件和第三方库。\n拆分独立的库使得复用成为了可能，我们可以在新项目中使用\n\n3.  拆分公共模块\n\n包括了业务模块所需要的一些公共代码，但是要么是和业务关系较大，要么就是还没到可以抽象成一个库的程度\n我们开始按由容易到困难的顺序拆分各个业务模块\n\n4.  页面跳转解耦\n\n豆瓣开源方案： FRDIntent/Intent  https://github.com/douban/FRDIntent\n 我们开始按由容易到困难的顺序拆分各个业务模块\n\n5.  FRDIntent/Intent 有如下优势：\n\n充分解耦。调用者和被调用者完全隔离，调用者只需要依赖协议：FRDIntentReceivable。一个 UIViewControlller 符合该协议即可被启动。\n对于“启动一个页面，并从该页面获取结果”这种较普遍的需求提供了一个通用的解决方案。具体查看方法：startControllerForResult。这是对 Android 中 startActivityForResult 的模仿和简化。\n支持自定义转场动画。\n支持传递复杂数据对象。\n\n\n组件化方案主要是基于Mediator模式和Target-Action模式，中间采用了runtime来完成调用。这套组件化方案将远程应用调用和本地应用调用做了拆分，而且是由本地应用调用为远程应用调用提供服务，与蘑菇街方案正好相反。\n本地调用\n[[CTMediator sharedInstance] performTarget:targetName action:actionName params:@&#123;...&#125;]向CTMediator发起跨组件调用，CTMediator根据获得的target和action信息，通过objective-C的runtime转化生成target实例以及对应的action选择子，然后最终调用到目标业务提供的逻辑，完成需求。\n\n远程调用\nAppDelegate接收到URL之后，调用CTMediator的openUrl:方法将接收到的URL信息传入。当然，CTMediator也可以用openUrl:options:的方式顺便把随之而来的option也接收，这取决于你本地业务执行逻辑时的充要条件是否包含option数据。传入URL之后，CTMediator通过解析URL，将请求路由到对应的target和action\n\n组件间调用方式所有组件都通过组件自带的Target-Action来响应，也就是说，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。\n组件参数传递\n非常规参数是包含非常规类型的参数。\n非常规类型的定义就是不能被json解析的类型都叫非常规类型。\n\n本地组件间调用来支持远程应用调用\n通过performTarget:action:params:是能够提供非常规参数的，于是我们可以知道，远程App调用时的上下文环境以及功能是本地组件间调用时上下文环境以及功能的子集。\n远程App调用只能走CTMediator提供的专用远程的方法，本地组件间调用只能走CTMediator提供的专用本地的方法，两者不能通过同一个接口来调用。\n\n组件化去Model\n组件间调用时，是需要针对参数做去model化的。如果组件间调用不对参数做去model化的设计，就会导致业务形式上被组件化了，实质上依然没有被独立。\n\n假设模块A和模块B之间采用model化的方案去调用，那么调用方法时传递的参数就会是一个对象。\n\n\n使用对象化的参数无论是否面向接口，带来的结果就是业务模块形式上是被组件化了，但实质上依然没有被独立。\n跨模块调用\n以字典的方式去传递。这样就能够做到只有调用方依赖mediator，而响应方不需要依赖mediator\n在去model的组件化方案中，影响效率的点有两个：调用方如何知道接收方需要哪些key的参数？调用方如何知道有哪些target可以被调用？其实后面的那个问题不管是不是去model的方案，都会遇到。\n为什么放在一起说，因为我接下来要说的解决方案可以把这两个问题一起解决。\n\n解决方案\n\n\n\n\n\n\n\n\n通mediator这个repo维护了若干个针对mediator的category，每一个对应一个target，每个category里的方法对应了这个target下所有可能的调用场景，这样调用者在包含mediator的时候，自动获得了所有可用的target-action，无论是调用还是参数传递，都非常方便。接下来我要解释一下为什么是category而不是其他：\n\ncategory本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用category封装是很合理的。\n在category的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category就提供了补救的入口。\ncategory可以很轻松地做请求转发，如果不采用category，请求转发逻辑就非常难做了。\ncategory统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。\n由于category统一了所有的调用入口，使得在跨模块调用时，对于param的hardcode在整个App中的作用域仅存在于category中，在这种场景下的hardcode就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。\n\n\n\n\n\n项目组件化拆分传统项目结构\n\n\n\n![截屏2021-06-18 下午2.46.07](iOS-component/截屏2021-06-18 下午2.46.07.png)\n![截屏2021-06-18 上午10.40.36](iOS-component/截屏2021-06-18 上午10.40.36.png)\n\n\n\n@interface A_VC : UIViewController\n  \n  -(void)action_A:(NSString*)para1;\n\n@end\n       \nimport &quot;A_VC.h&quot;\n@implementation A_VC\n\n-(void)action_A:(NSString*)para1 &#123;\n  NSLog(@&quot;call action_A %@&quot;,para1);\n&#125;\n       \n@end\n       \n \n@interface B_VC : UIViewController\n       \n  -(void)action_B:(NSString*)para1 para2:(NSInteger)para2;\n       \n@end\n       \n            \nimport &quot;B_VC.h&quot;     \n@implementation B_VC\n\n-(void)action_B:(NSString*)para1 para2:(NSInteger)para2&#123;\n        NSLog(@&quot;call action_B %@---%zd&quot;,para1,para2);\n&#125;\n@end\n\n@interface Mediator : NSObject\n-(void)A_VC_Action:(NSString*)para1;\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2;\n+ (instancetype)sharedInstance;\n\n@end\n\nimport &quot;Mediator.h&quot;\n\n@implementation Mediator\n\n+ (instancetype)sharedInstance &#123;\n\tstatic Mediator *mediator;\n  static dispatch_once_t onceToken;\n  dispatch_once(&amp;onceToken, ^&#123;\n    mediator &#x3D; [[Mediator alloc] init];\n  &#125;);\n  return mediator;\n&#125;\n\n-(void)A_VC_Action:(NSString*)para1 &#123;\n  Class cls &#x3D; NSClassFromString(@&quot;A_VC&quot;);\n  NSObject *target &#x3D; [[cls alloc] init];\n  [target performSelector: NSSelectorFromString(@&quot;action_A:&quot;) withObject:para1];\n&#125;\n\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2&#123;\n  Class cls &#x3D; NSClassFromString(@&quot;B_VC&quot;);\n  NSObject *target &#x3D; [[cls alloc] init];\n  [target performSelector: NSSelectorFromString(@&quot;action_B:para2:&quot;) withObject: para1 withObject: para2];\n&#125;\n\n@end\n       \n\n组件之间调用&gt; B 调用 A \n[[Mediator sharedInstance] A_VC_Action:@&quot;参数1&quot; ];\n&gt;  A 调用 B\n[[Mediator sharedInstance] B_VC_Action:@&quot;参数1&quot; para2: 123];\n\n反思\n看到这里，大概有人会问，既然用runtime就可以解耦取消依赖，那还要Mediator做什么？我直接在每个组件里面用runtime调用其他组件不就完了吗，干嘛还要多一个mediator？\n但是这样做会存在如下问题：\n\n调用者写起来很恶心，代码提示都没有， 参数传递非常恶心，每次调用者都要查看文档搞清楚每个参数的key是什么，然后自己去组装成一个 NSDictionary。维护这个文档和每次都要组装参数字典很麻烦。\n当调用的组件不存在的时候，没法进行统一处理\n\n那么加一个mediator的话，就可以做到：\n\n调用者写起来不恶心，代码提示也有了, 参数类型明确。\nMediator可以做统一处理，调用某个组件方法时如果某个组件不存在，可以做相应操作，让调用者与组件间没有耦合。\n\n改进\n聪明的读者可能已经发现上面的mediator方案还是存在一个小瑕疵，受限于performselector方法，最多只能传递两个参数，如果我想传递多个参数怎么办呢？\n答案是使用字典进行传递，此时我们还需要个组件增加一层wrapper，把对外提供的业务全部包装一次，并且接口的参数全部改成字典。 假设我们现在的B组件需要接受多个参数，如下所示：\n-(void)action_B:(NSString*)para para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    NSLog(@&quot;call action_B %@---%zd---%zd----%zd&quot;,para1,para2,para3,para4);\n&#125;\n\n那么此时需要对B组件增加一层wrapper，如下：#import @interface target_B : NSObject\n-(void)B_Action:(NSDictionary*)para;\n\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n#import &quot;target_B.h&quot;\n#import &quot;B_VC.h&quot;\n\n@implementation target_B\n\n-(void)B_Action:(NSDictionary*)para&#123;\n    NSString *para1 &#x3D; para[@&quot;para1&quot;];\n    NSInteger para2 &#x3D; [para[@&quot;para2&quot;]integerValue];\n    NSInteger para3 &#x3D; [para[@&quot;para3&quot;]integerValue];\n    NSInteger para4 &#x3D; [para[@&quot;para4&quot;]integerValue];\n    B_VC *VC &#x3D; [B_VC new];\n    [VC action_B:para1 para2:para2 para3:para3 para4:para4];\n&#125;\n@end\n\n此时mediator也需要做相应的更改，由原来直接调用组件B，改成了调用B的wrapper层：-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    Class cls &#x3D; NSClassFromString(@&quot;target_B&quot;);\n    NSObject *target &#x3D; [[cls alloc]init];\n    [target performSelector:NSSelectorFromString(@&quot;B_Action:&quot;) withObject:@&#123;@&quot;para1&quot;:para1, @&quot;para2&quot;:@(para2),@&quot;para3&quot;:@(para3),@&quot;para4&quot;:@(para4)&#125; ];\n&#125;\n\n\n\n\n\n继续改进\n做到这里，看似比较接近我的要求了，但是还有有点小瑕疵：\n\nMediator 每一个方法里都要写 runtime 方法，格式是确定的，这是可以抽取出来的。\n每个组件对外方法都要在 Mediator 写一遍，组件一多 Mediator 类的长度是恐怖的。\n\n接着优化就是casa的方案了，我们来看看如何改进，直接看代码：\n针对第一点，我们可以抽出公共代码，当做mediator：\n#import &quot;CTMediator.h&quot;\n#import @interface CTMediator ()\n\n@property (nonatomic, strong) NSMutableDictionary *cachedTarget;\n\n@end\n\n@implementation CTMediator\n\n#pragma mark - public methods\n+ (instancetype)sharedInstance\n&#123;\n    static CTMediator *mediator;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        mediator &#x3D; [[CTMediator alloc] init];\n    &#125;);\n    return mediator;\n&#125;\n\n&#x2F;*\n scheme:&#x2F;&#x2F;[target]&#x2F;[action]?[params]\n\n url sample:\n aaa:&#x2F;&#x2F;targetA&#x2F;actionB?id&#x3D;1234\n *&#x2F;\n\n- (id)performActionWithUrl:(NSURL *)url completion:(void (^)(NSDictionary *))completion\n&#123;\n    NSMutableDictionary *params &#x3D; [[NSMutableDictionary alloc] init];\n    NSString *urlString &#x3D; [url query];\n    for (NSString *param in [urlString componentsSeparatedByString:@&quot;&amp;&quot;]) &#123;\n        NSArray *elts &#x3D; [param componentsSeparatedByString:@&quot;&#x3D;&quot;];\n        if([elts count] &lt; 2) continue;\n        [params setObject:[elts lastObject] forKey:[elts firstObject]];\n    &#125;\n\n    &#x2F;&#x2F; 这里这么写主要是出于安全考虑，防止黑客通过远程方式调用本地模块。这里的做法足以应对绝大多数场景，如果要求更加严苛，也可以做更加复杂的安全逻辑。\n    NSString *actionName &#x3D; [url.path stringByReplacingOccurrencesOfString:@&quot;&#x2F;&quot; withString:@&quot;&quot;];\n    if ([actionName hasPrefix:@&quot;native&quot;]) &#123;\n        return @(NO);\n    &#125;\n\n    &#x2F;&#x2F; 这个demo针对URL的路由处理非常简单，就只是取对应的target名字和method名字，但这已经足以应对绝大部份需求。如果需要拓展，可以在这个方法调用之前加入完整的路由逻辑\n    id result &#x3D; [self performTarget:url.host action:actionName params:params shouldCacheTarget:NO];\n    if (completion) &#123;\n        if (result) &#123;\n            completion(@&#123;@&quot;result&quot;:result&#125;);\n        &#125; else &#123;\n            completion(nil);\n        &#125;\n    &#125;\n    return result;\n&#125;\n\n- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget\n&#123;\n\n    NSString *targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];\n    NSString *actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];\n    Class targetClass;\n\n    NSObject *target &#x3D; self.cachedTarget[targetClassString];\n    if (target &#x3D;&#x3D; nil) &#123;\n        targetClass &#x3D; NSClassFromString(targetClassString);\n        target &#x3D; [[targetClass alloc] init];\n    &#125;\n\n    SEL action &#x3D; NSSelectorFromString(actionString);\n\n    if (target &#x3D;&#x3D; nil) &#123;\n        &#x2F;&#x2F; 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的\n        return nil;\n    &#125;\n\n    if (shouldCacheTarget) &#123;\n        self.cachedTarget[targetClassString] &#x3D; target;\n    &#125;\n\n    if ([target respondsToSelector:action]) &#123;\n        return [self safePerformAction:action target:target params:params];\n    &#125; else &#123;\n        &#x2F;&#x2F; 有可能target是Swift对象\n        actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName];\n        action &#x3D; NSSelectorFromString(actionString);\n        if ([target respondsToSelector:action]) &#123;\n            return [self safePerformAction:action target:target params:params];\n        &#125; else &#123;\n            &#x2F;&#x2F; 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理\n            SEL action &#x3D; NSSelectorFromString(@&quot;notFound:&quot;);\n            if ([target respondsToSelector:action]) &#123;\n                return [self safePerformAction:action target:target params:params];\n            &#125; else &#123;\n                &#x2F;&#x2F; 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。\n                [self.cachedTarget removeObjectForKey:targetClassString];\n                return nil;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n- (void)releaseCachedTargetWithTargetName:(NSString *)targetName\n&#123;\n    NSString *targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];\n    [self.cachedTarget removeObjectForKey:targetClassString];\n&#125;\n\n#pragma mark - private methods\n- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params\n&#123;\n    NSMethodSignature* methodSig &#x3D; [target methodSignatureForSelector:action];\n    if(methodSig &#x3D;&#x3D; nil) &#123;\n        return nil;\n    &#125;\n    const char* retType &#x3D; [methodSig methodReturnType];\n\n    if (strcmp(retType, @encode(void)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        return nil;\n    &#125;\n\n    if (strcmp(retType, @encode(NSInteger)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        NSInteger result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(BOOL)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        BOOL result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(CGFloat)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        CGFloat result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(NSUInteger)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        NSUInteger result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;\n    return [target performSelector:action withObject:params];\n#pragma clang diagnostic pop\n&#125;\n\n#pragma mark - getters and setters\n- (NSMutableDictionary *)cachedTarget\n&#123;\n    if (_cachedTarget &#x3D;&#x3D; nil) &#123;\n        _cachedTarget &#x3D; [[NSMutableDictionary alloc] init];\n    &#125;\n    return _cachedTarget;\n&#125;\n\n@end\n\n针对第二点，我们通过把每个组件的对外接口进行分离，剥离到多个mediator的category里面，感官上把本来在一个mediator里面实现的对外接口分离到多个category里面，方便管理\n下面展示的是个组件B添加的category，组件A类似\n#import &quot;CTMediator.h&quot;\n\n@interface CTMediator (B_VC_Action)\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4;\n\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n#import &quot;CTMediator+B_VC_Action.h&quot;\n\n@implementation CTMediator (B_VC_Action)\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    [self performTarget:@&quot;target_B&quot; action:@&quot;B_Action&quot; params:@&#123;@&quot;para1&quot;:para1, @&quot;para2&quot;:@(para2),@&quot;para3&quot;:@(para3),@&quot;para4&quot;:@(para4)&#125; shouldCacheTarget:YES];\n&#125;\n@end\n\n此时调用者只要引入该category，然后调用即可，调用逻辑其实和上面没有拆分出category是一样的。此时的项目结构如下：\n\n\nURL-Scheme方案\n这个方案是流传最广的，也是最多人使用的，因为Apple本身也提供了url-scheme功能，同时web端也是通过URL的方式进行路由跳转，那么很自然的iOS端就借鉴了该方案。\n如何实现\nRouter实现代码\n#import typedef void (^componentBlock) (NSDictionary *param);\n\n@interface URL_Roueter : NSObject\n+ (instancetype)sharedInstance;\n- (void)registerURLPattern:(NSString *)urlPattern toHandler:(componentBlock)blk;\n- (void)openURL:(NSString *)url withParam:(id)param;\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n#import &quot;URL_Roueter.h&quot;\n\n@interface URL_Roueter()\n@property (nonatomic, strong) NSMutableDictionary *cache;\n@end\n\n\n@implementation URL_Roueter\n\n+ (instancetype)sharedInstance\n&#123;\n    static URL_Roueter *router;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        router &#x3D; [[URL_Roueter alloc] init];\n    &#125;);\n    return router;\n&#125;\n\n\n\n-(NSMutableDictionary *)cache&#123;\n    if (!_cache) &#123;\n        _cache &#x3D; [NSMutableDictionary new];\n    &#125;\n    return _cache;\n&#125;\n\n\n- (void)registerURLPattern:(NSString *)urlPattern toHandler:(componentBlock)blk &#123;\n    [self.cache setObject:blk forKey:urlPattern];\n&#125;\n\n- (void)openURL:(NSString *)url withParam:(id)param &#123;\n    componentBlock blk &#x3D; [self.cache objectForKey:url];\n    if (blk) blk(param);\n&#125;\n\n\n@end\n\n组件A#import &quot;A_VC.h&quot;\n#import &quot;URL_Roueter.h&quot;\n\n@implementation A_VC\n\n&#x2F;&#x2F;把自己对外提供的服务(block)用url标记，注册到路由管理中心组件\n+(void)load&#123;\n    [[URL_Roueter sharedInstance]registerURLPattern:@&quot;test:&#x2F;&#x2F;A_Action&quot; toHandler:^(NSDictionary* para) &#123;\n        NSString *para1 &#x3D; para[@&quot;para1&quot;];\n        [[self new] action_A:para1];\n    &#125;];\n&#125;\n\n\n-(void)viewDidLoad&#123;\n    [super viewDidLoad];\n    UIButton *btn &#x3D; [UIButton new];\n    [btn setTitle:@&quot;调用组件B&quot; forState:UIControlStateNormal];\n    btn.frame &#x3D; CGRectMake(100, 100, 100, 50);\n    [btn addTarget:self action:@selector(btn_click) forControlEvents:UIControlEventTouchUpInside];\n    [btn setBackgroundColor:[UIColor redColor]];\n\n    self.view.backgroundColor &#x3D; [UIColor blueColor];\n    [self.view addSubview:btn];\n\n&#125;\n\n&#x2F;&#x2F;调用组件B的功能\n-(void)btn_click&#123;\n    [[URL_Roueter sharedInstance] openURL:@&quot;test:&#x2F;&#x2F;B_Action&quot; withParam:@&#123;@&quot;para1&quot;:@&quot;PARA1&quot;, @&quot;para2&quot;:@(222),@&quot;para3&quot;:@(333),@&quot;para4&quot;:@(444)&#125;];\n&#125;\n\n\n-(void)action_A:(NSString*)para1 &#123;\n    NSLog(@&quot;call action_A: %@&quot;,para1);\n&#125;\n\n@end\n\n从上面的代码可以看出来，实现原理很简单：每个组件在自己的load方面里面，把自己对外提供的服务(回调block)通过url-scheme标记好，然后注册到URL-Router里面。\nURL-Router接受各个组件的注册，用字典保存了每个组件注册过来的url和对应的服务，只要其他组件调用了openURL方法，就会去这个字典里面根据url找到对应的block执行(也就是执行其他组件提供的服务)\n存在的问题\n需要专门的管理后台维护\n\n要提供一个文档专门记录每个url和服务的对应表，每次组件改动了都要即使修改，很麻烦。参数的格式不明确，是个灵活的 dictionary，同样需要维护一份文档去查这些参数。\n\n\n内存问题\n每个组件在初始化的时候都需要要路由管理中心去注册自己提供的服务，内存里需要保存一份表，组件多了会有内存问题。\n\n混淆了本地调用和远程调用\n\nurl-scheme是Apple拿来做app之间跳转的，或者通过url方式打开APP，但是上述的方案去把他拿来做本地组件间的跳转，这会产生问题，大概分为两点：\n\n\n远程调用和本地调用的处理逻辑是不同的，正确的做法应该是把远程调用通过一个中间层转化为本地调用，如果把两者两者混为一谈，后期可能会出现无法区分业务的情况。比如对于组件无法响应的问题，远程调用可能直接显示一个404页面，但是本地调用可能需要做其他处理。如果不加以区分，那么久无法完成这种业务要求。\n\n远程调用只能传能被序列化为json的数据，像 UIImage这样非常规的对象是不行的。所以如果组件接口要考虑远程调用，这里的参数就不能是这类非常规对象，接口的定义就受限了。出现这种情况的原因就是，远程调用是本地调用的子集，这里混在一起导致组件只能提供子集功能(远程调用)，所以这个方案是天生有缺陷的\n\n理论上来讲，组件化是接口层面的东西，应该用语言自身的特性去解决，而url是用于远程通信的，不应该和组件化扯上关系\n\n\n\n\n\n\n链家完整组件化实例","slug":"iOS-component","date":"2021-06-11T08:05:51.000Z","categories_index":"","tags_index":"组件化","author_index":"LittleStart"},{"id":"d68e4e31d1e8b7032dd88c62b8f9b3ca","title":"Xcode Server CI 持续集成","content":"Xcode Server CI 持续集成一、 Xcode Server 基本概念\nXcode Server是配置在Mac端的一个服务器，服务器上我们可以创建Bot自动执行机器人\n软件应用程序在本地（Xcode development Macs）开发过程中，会将代码不断合并到git上(SCM Repository)， \nBot会在指定的时间将git上的代码拉取到Server上，并且执行需要的操作，例如pod install以及创建ipa上传到测试分发平台\n执行完成之后会生成执行报告，如果有自动化测试的话，还会输出测试统计数据。\n\n二、 如何使用 Xcode Server 进行持续集成\n在Mac 电脑上, 安装 Xcode，并启用这个功能，一个持续集成的服务器就搭建好了\n启动Xcode，点击 Xcode 菜单: Xcode-&gt;XcodeServer\n 在Server&amp;Bots界面，将开关由OFF设置为ON, 输入系统账户密码, 选择一个用户作为 Xcode Server用户，然后continue等待完成，即成功启用Xcode Server。\n\n\n\n\n\n\n设置超时时间。超过时间后就会自动取消，如果项目仓库较大并且网速较慢第一次拉取会很耗时，可以先设置长一点时间。\n\n\n\n\n配置创建和查看bot权限的成员\n\n配置邮件通知\n\n\n","slug":"Xcode-Server-CI-持续集成","date":"2021-06-10T07:58:03.000Z","categories_index":"","tags_index":"持续集成","author_index":"LittleStart"},{"id":"549def405a2020c02b3886501c2d84f3","title":"async 和 await 同步等待","content":"Dart\n\n\n\n\n\n\n\n\n获取相应数据操作\n","slug":"async-await","date":"2021-06-01T03:45:18.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"6af98c5762fa00ab05498386038da6c3","title":"抽象构造函数","content":"抽象类\nabstract关键字修饰class\n继承的方式使用\n接口的方式使用\n\nabstract class Message &#123;\n  \n  factory Message(String type) &#123;\n    switch(type) &#123;\n      case 'foot': \n        return new Footmessage();\n      case 'back': \n        return new Footmessage();\n      case 'special': \n        return new Footmessage();\n    &#125;\n  &#125;\n  \n  void doMessage(); // \n&#125;\n\nclass FootMessge implements Message &#123;\n  @override\n   void doMessage() &#123;\n     \n   &#125;\n&#125;\n\nclass BackMessge implements Message &#123;\n  @override\n   void doMessage() &#123;\n     \n   &#125;\n&#125;\n\nclass SpecialMessge implements Message &#123;\n  @override\n   void doMessage() &#123;\n     \n   &#125;\n&#125;\n\n// 函数调用\nvar footMessage = new Message('foot')\nvar backMessage = new Message('back')\nvar specialMessage = new Message('special')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"abstractClass","date":"2021-06-01T02:16:37.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"3b284d7eb9880174f64e9bf09d231aff","title":"DartClass","content":"Dart 类相关的使用命名构造函数\nPoint.fromJSON(Map json)\n\nclass Point &#123;\n  num x;\n  num y;\n  \n  Point(this.x, this.y);\n  \n  &#x2F;&#x2F; 命名构造函数（命名构造函数）\n  Point.fromJSON(Map json) &#123;\n    x &#x3D; json[&#39;x&#39;];\n    y &#x3D; json[&#39;y&#39;];\n  &#125;\n&#125;\n\n\n\n重定向构造函数\n使用冒号:调用其他构造函数\n\nclass Point &#123;\n  num x;\n  num y;\n  \n  Point(this.x, this.y);\n  \n  &#x2F;&#x2F; 命名构造函数（命名构造函数）\n  Point.fromJSON(Map json) &#123;\n    x &#x3D; json[&#39;x&#39;];\n    y &#x3D; json[&#39;y&#39;];\n  &#125;\n  \n  &#x2F;&#x2F; 重定向构造函数，使用冒号调用其他构造函数\n  Point.alongXAxis(num x) : this(x, 0); &#x2F;&#x2F; 重定向构造函数\n  \n&#125;\n\n\n\n超类构造函数\n超类\n\nclass Parent &#123;\n  int x;\n  int y;\n\n  &#x2F;&#x2F;父类命名构造函数不会传递  \n  Parent.fromJson(x, y)\n      : x &#x3D; x, &#x2F;&#x2F; 赋值过程\n        y &#x3D; y &#123;\n    print(&#39;父类命名构造函数&#39;);\n  &#125;\n&#125;\n\n\nclass Child extends Parent &#123;\n  int x;\n  int y;\n  &#x2F;&#x2F;若超类没有默认构造函数， 需要手动调用超类其他构造函数\n  Child(x, y) : super.fromJson(x, y) &#123;\n    &#x2F;&#x2F;调用父类构造函数的参数无法访问 this\n    print(&#39;子类构造函数&#39;);\n  &#125;\n\n  &#x2F;&#x2F;在构造函数的初始化列表中使用super()，需要把它放到最后\n  Child.fromJson(x, y) \n    : x &#x3D; x, &#x2F;&#x2F; 赋值操作\n  \t\ty &#x3D; y, &#x2F;&#x2F; 赋值操作\n\t\t&#x2F;&#x2F; 调用命名构造函数\n\t   super.fromJson(x, y) &#123;\n    print(&#39;子类命名构造函数&#39;);\n  &#125;\n&#125;\n\n\n\n\n常量构造函数\n通过const 关键字\n\nclass Point2 &#123;\n  &#x2F;&#x2F;定义const构造函数要确保所有实例变量都是final\n  final num x;\n  final num y;\n  &#x2F;&#x2F; 初始化构造函数\n  static final Point2 origin &#x3D; const Point2(0, 0);\n\n  &#x2F;&#x2F;const关键字放在构造函数名称之前，且不能有函数体\n  const Point2(this.x, this.y);\n&#125;\n\nPoint2 point2 &#x3D; const Point2(1, 2);\nPoint2 p3 &#x3D; const Point2(1, 2);\n\n\n\n\n工厂构造函数\n通过命名构造函数，然后使用 factory 关键字\n如果对象存在，不生成新对象，如果不存在，生成新对象\n\nclass Singleton &#123;\n  String name;\n  &#x2F;&#x2F;工厂构造函数无法访问this，所以这里要用static\n  static Singleton _cache; \n\n  &#x2F;&#x2F;定义一个命名构造函数用来生产实例\n  Singleton._newObject(this.name);\n  \n  &#x2F;&#x2F;工厂方法构造函数，关键字factory\n  factory Singleton([String name &#x3D; &#39;singleton&#39;]) &#x3D;&gt;\n      Singleton._cache ??&#x3D; Singleton._newObject(name);\n&#125;\n\n\n\nSet 和 get 方法\n通过 set 和 get 关键字来进行操作\n\nclass Rectangle &#123;\n  num left;\n  num top;\n  num width;\n  num height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  num get right => left + width;\n  set right(num value) => left = value - width;\n  num get bottom => top + height;\n  set bottom(num value) => top = value - height;\n&#125;\n\n\n","slug":"DartClass","date":"2021-06-01T01:28:38.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"1117fb54e92a8351488adf129028b2a6","title":"DartException","content":"Dart 异常处理操作![截屏2021-05-31 下午5.06.39](DartException/截屏2021-05-31 下午5.06.39.png)\n延迟加载异常\nDeferredLoadException 延迟加载异常\n\nthrow new FormateException(\"\")\n\n类型异常\nFormateException(“”)\n\nFormateException(\"格式化异常\")\n\ntry catch 捕获异常\n捕获异常\n\ntry &#123;\n  throw new NullThrownError();\n&#125; catch(e, s) &#123; // 第一个异常对象， StackTrack 对象\n  print(e)\n&#125;\n\n\n制定捕获的异常\n\ntry &#123;\n  throw new NullThrownError();\n&#125; on Error &#123;\n  print('error 类型捕获异常')\n&#125; catch(e, s) &#123; // 第一个异常对象， StackTrack 对象\n  print(e)\n&#125;\n","slug":"DartException","date":"2021-05-31T09:06:01.000Z","categories_index":"","tags_index":"Dart","author_index":"LittleStart"},{"id":"5c608ba3383f27b31f8830b3a9b5f6d6","title":"应用性能分析方法","content":"应用性能分析方法1. 采样顾名思义，采样(或基于探测点的性能分析)是指以一定的周期间隔采集状态，这通常需要借助工具。由于不会干扰应用的执行，因此采样可以很好地提供应用的全景图。采样的不足之处在于它不能返回 100% 精确的细节。如果采样的频率是 10 毫秒，那么你就无法得知在探测点之间的 9.999 毫秒内发生了什么。\n\n\n\n\n\n\n\n\n\n采样可以作为初始的性能调研手段，并可用于跟踪 CPU 和内存的使用情况\n2. 埋点通过修改代码，记录细节信息的埋点能够提供比采样更加精确的结果。你既可以在关键部分主动埋点，也可以在性能分析或处理用户反馈时有针对性地埋点因为埋点需要注入额外代码，所以它一定会影响应用的性能，对内存或速度(或同时对二者)造成损害。\n1.4 测量现在，我们已经确定了需要测量的参数，并且研究了测量所需要的不同类型的分析。我们先简单了解一下如何实现测量。\n通过测量性能并找出真正存在问题的地方，你可以避免掉入过早优化的陷阱.\n\n\n\n\n\n\n\n\n\n真正的问题在于,程序开发人员为提升程序效率在错误的方向和时间点浪费了太多时间;过早优化是编程领域的万恶(至少是绝大多数的恶)之源。\n1.4.1 设置工程与代码接下来，我们将建立一个工程，以便在开发和生产阶段测量已经定义好的参数。针对工程配置、安装和代码实现共有三类任务。\n\n构建与发布 : 确保能够轻松地构建和发布应用。\n\n可测试性 确保你的代码能够同时在模拟数据和真实数据之上工作，其中包括能够模拟真实场景的隔离环境\n\n可跟踪性 确保你能够通过明确问题发生的位置和代码行为来处理错误。\n\n\n1. 构建与发布由于对灵活和敏捷的强烈需求，系统和工具得到了改进。改进后的系统和工具现在可以加速拉取依赖信息，加速构建和发布用于测试或企业分发的产品，也可以为公众发布而提高提交文件到 iTunes Connect 的速度。\n基于 Ruby 语言实现的 CocoaPods(https://cocoapods.org)实际上是 Objective-C 和 Swift 工程的依赖管理器。CocoaPods 与 Xcode 命令行工具相集成，可用于构建与发布。\n2. 可测试性每个应用都包含多个协同工作的组件。一个设计良好的系统应该遵循低耦合和高内聚，并允许替换任意或全部组件的依赖。\n可以通过模拟依赖项目对每个组件进行隔离测试。一般来说，测试有两种类型。\n• 单元测试 验证每个代码单元在隔离环境下的操作。常见的做法是，在特定的环境中用不同的输入数据反复地调用一些方法，以评估代码的表现。\n• 功能测试 验证组件在最终集成的安装包中的操作。可以在软件的最终发布版本中验证，也可以在某个为测试而构建的参考应用中验证。\n3. 可跟踪性在开发阶段，埋点可以帮助我们确定性能优化的优先级、提高对问题现场的还原能力，并提供更多的调试信息。崩溃报告专注于从软件的产品版本中收集调试信息。\n4. 设置崩溃报告崩溃报告系统收集用于分析应用的调试日志。市面上有数十种崩溃报告系统.\n5. 对应用埋点对应用进行埋点是了解用户行为的一个重要步骤，但更重要的目的是识别应用的关键路径。注入特定的代码以记录关键指标是提升应用性能的重要步骤。\n日志日志是无价之宝，可以用于了解应用发生了什么事。日志和埋点之间存在着细微的差别。埋点可以看作日志的子集。被埋点的任何数据都应该 记录在日志中。埋点承担了为聚合分析发布关键性能数据的职责，日志则提供了用于在不同级别跟踪应用的细节信息，比如 debug、``Verbose、``info、``warning 和 Error。日志的记录会贯穿应用的整个生命周期，而埋点只应该用在开发的特定阶段。\n埋点数据会发送到服务器，日志是记录在设备本地。 就日志而言，我们可以通过 CocoaPods 引入 CocoaLumberjack 来使用。\nCocoaLumberjack 是一个扩展性很强的框架，捆绑了一系列内置的日志记录器，这些记录器 可以向不同的目标发送信息。例如，使用 DDASLLogger 可以向 Apple System Log(ASL， NSLog 方法的默认位置)记录日志。类似地，使用 DDFileLogger 可以向文件记录日志。可 以在应用运行期间配置记录器。\nDDLog 宏指令可以用于记录某个特定层级的日志。层级越高，信息越重要。最高级 别是 Error，最低级别是 Verbose。实际记录消息的最低层级可以配置在每个文件层级、每 个 Xcode 配置层级、每个日志器层级或全局。以下的宏指令可供使用。\n\nDDLogError 表示不可恢复的错误。\nDDLogWarn 表示可恢复的错误。\nDDLogInfo 表示非错误的信息。\nDDLogDebug 表示数据主要用于调试。\nDDLogVerbose 几乎提供了所有的细节，主要用于跟踪执行过程中的控制流。这些宏指令有着与 NSLog 相同的签名。这意味着你可以直接用适合的 DDLog 调用来 取代 NSLog。\n\n","slug":"应用性能分析方法","date":"2021-05-22T07:06:49.000Z","categories_index":"","tags_index":"iOS性能优化","author_index":"LittleStart"},{"id":"d6599ba5117b38d8d4d285c032bd712d","title":"iOS性能优化指标","content":"性能指标\n\n\n\n\n\n\n\n\n性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。\n1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保没有泄漏内存。随时间流逝而持续增长的内存消耗意味着，应用很可能会因 为内存不足的异常而崩溃。\n1.2.2 电量消耗在编写高性能代码时，电量消耗是一个需要重点处理的重要因素。就执行时间和 CPU 资源的利用而言，我们不仅要实现高效的数据结构和算法，还需要考虑其他的因素。如果某个应用是个电池黑洞，那么一定不会有人喜欢它。\n电量消耗不仅仅与计算 CPU 周期有关，还包括高效地使用硬件。除了要实现电量消耗最 小化，还要确保不会影响用户体验。\n1.2.3 初始化时间应用在启动时应执行刚好够用的任务以完成初始化，从而满足用户的使用需求。执行这些 任务消耗的时间就是应用的初始化时间。刚好够用是一个开放式用语——正确的平衡点取 决于应用的需要。\n在首次使用应用时创建对象并进行初始化是一个合理的选择，例如，直到需要使用对象时 才创建对象。这种方式被称为惰性初始化。这是一种很好的策略，但也要考虑不能让用户 总是在执行后续任务时等待。\n下面列举了你可能想在应用初始化阶段执行的一些动作，排名不分先后。\n\n检查应用是否为首次启动。\n检查用户是否已经登录。\n如果用户已经登录，尽可能地载入之前的状态。\n连接服务器以拉取最新的变更。\n检查应用是否由某个深层链接唤起。如果是，还需要载入深层链接相应的 UI 和状态。\n检查是否存在应用上次启动时挂起的任务，需要时恢复它们。\n初始化后续需要使用的对象和线程池。\n初始化依赖项(如对象关系映射、崩溃报告系统和缓存)。\n\n这个列表可能会迅速变长，并且很难决定哪些条目一定要在启动时执行，哪些可以延后几 毫秒再执行。\n1.2.4 执行速度一旦启动应用，用户总是希望它可以尽可能快地工作。一切必要的处理都应该在尽可能短 的时间内完成。\n例如，在照片应用中，用户通常希望看到调整亮度或对比度等简单效果的实时预览效果。 因此，相应的处理需要在几毫秒内完成。\n这可能需要本地计算的并行处理技术或能够将复杂任务分发到服务器。\n1.2.5 响应速度每个应用都应该快速地响应用户交互。在应用中所做的一切优化和权衡最终都应该体现在 响应速度上。\nApp Store 中有许多应用可以完成相似或相关的任务。这为用户提供了很大的选择空间，而用户基本都会选择响应最快的应用。\n1.2.6 本地存储针对任何在服务器上存储数据或通过外部来源刷新数据的应用，开发人员应该对本地存储 的使用有所规划，以便应用具备离线浏览的能力。\n例如，用户都希望邮件应用能够在无网络或设备离线的情况下浏览历史邮件。 同样，新闻应用也应该可以在离线模式下显示最近更新的新闻，并标记出每条新闻是否已读。\n然而，从本地存储中载入和同步数据应该迅速、便捷。这不仅需要选择要在本地缓存的数 据和要优化的数据结构，还需要提供一系列的配置选项并确定数据同步的频率。\n如果你的应用使用了本地存储，那么请提供一个清除数据的选项。遗憾的是，市场上的大 部分应用都没有提供此选项。更让人烦恼的是，一些应用竟然会消耗数百兆的存储空间。 用户会频繁地卸载这些应用来回收本地存储。这会导致糟糕的用户体验，从而威胁应用的 成功。\n1.2.7 互操作性用户可能会使用多个应用来完成某个任务，这就需要这些应用直接提供互操作的能力。例 如，一个相册可能需要一个幻灯片应用来实现最佳的浏览体验，但需要另一个应用来编辑 照片。其中浏览照片的应用要能够将照片发送到编辑器，并接收编辑后的图片。\niOS 为实现应用间的互操作和数据共享提供了多种机制，其中包括 UIActivityViewController、 深层链接、MultipeerConnectivity 框架，等等。\n为深层链接定义良好的 URL 结构与编写优异的代码来解析 URL 同样重要。类似地，使用 共享对话框共享数据时，精确识别用于分享的数据非常重要，同时，在处理不同数据源传 入的数据时还要注意安全隐患。\n如果某个应用向附近设备共享数据时需要花费很长时间准备数据，那么用户体验就会非常 糟糕。\n1.2.8 网络环境移动设备会在不同网络环境下使用。为了确保能够提供最好的用户体验，你的应用应当适 应各种网络条件:\n\n高带宽稳定网络\n低带宽稳定网络\n高带宽不稳定网络\n低带宽不稳定网络\n无网络\n\n1.2.9 带宽人们会在不同的网络条件下使用自己的移动设备，网速从每秒数千字节到每秒数十兆字节。 因此，带宽的优化使用是定义应用质量的另一个关键参数。此外，在高带宽网络下运行一 个基于低带宽网络开发的应用可能会产生完全不同的结果。\n2010 年左右，我和我的团队正在印度开发一款应用。由于处于低带宽网络，应用的本地初始化速度要比从服务器端载入资源快得多，于是我们针对这种情况进行了优化。\n然而，当这款应用投入韩国市场时，我们对它进行了测试，结果却让人大跌眼镜。之前所 进行的所有优化几乎毫无意义，我们不得不重写了大部分可能导致资源和数据冲突的相关 代码。\n为提高性能所做的设计并非每次都能如愿，也可能会导致相反的效果。\n1.2.10 数据刷新即使没有提供离线浏览能力，你仍然可以从服务器端周期性地刷新数据。刷新的频率和每 次传输的数据量将决定数据传输的总量。如果传输的字节数过大，那用户必然会快速耗尽 自己的流量计划。当流量消耗大到一定程度时，你的应用很可能会流失用户。\n在 iOS 6.x 或更低版本中，在后台运行的应用不能刷新数据。从 iOS 7 开始，应用可以在后台周期性地刷新数据。对于在线聊天类应用，持久的 HTTP 连接或原生 TCP 连接可能会非常有用。\n1.2.11 多用户支持家庭成员间可能会共享移动设备，或者一个用户可能会拥有同一应用的多个账号。例如， 兄弟姐妹间可能会共享一个 iPad 来玩游戏。再比如，家庭成员可能会在旅游时配置一个设备来查收全家人的电子邮件，以减少漫游费用，尤其是在境外旅游时。类似地，一个人也 可能会配置多个电子邮件账号。\n是否支持多个并发用户取决于产品的需要。一旦决定提供此类功能，请参考以下准则。\n\n添加新用户应尽可能高效。\n在不同用户之间更新应尽可能高效。\n在不同用户之间切换应尽可能高效。\n用户数据的界限应该简洁且没有 bug。\n\n1.2.12 单点登录如果你已经创建了多个允许或需要登录的应用，那么支持单点登录(single sign-on，SSO) 是非常棒的选择。如果用户登录了一个应用，只需要点击一次，就可以登录到其他的应用中。\n这个过程不仅需要支持跨应用的数据共享，还需要分享状态、跨应用同步等。例如，如果 用户注销了其中某个应用，则通过 SSO 登录的所有其他应用也应能注销掉。 此外，应用之间的同步应该是安全的。\n1.2.13 安全安全对移动应用来说是最重要的，因为敏感信息可能会在应用间共享。因此，对所有通信 以及本地数据和共享数据进行加密就显得尤为重要了。\n实现安全需要更多的计算、内存和存储，但这与最大化运行速度、最小化内存和存储使用 的目标相冲突。\n因此，你需要在安全和其他因素之间进行权衡。\n引入多个安全层会影响性能，并对用户体验造成可感知的负面影响。如何设定安全的基线 需要参考对用户群体的统计分析。此外，硬件在其中扮演了重要的角色:选择会因为不同 设备的计算能力而有所不同。\n1.2.14 崩溃应用可能会而且确实会崩溃。过度优化会导致崩溃。同样，使用原始 C 代码也可能会导致 崩溃。 高性能的应用不仅应尽可能地避免崩溃，还应该在崩溃发生时优雅地恢复，尤其是在进行 某个操作的过程中发生崩溃时。\n综上所述\n\n\n\n\n\n\n\n\n性能主要从以上所有面向用户的基本属性指标分析\n\n\n","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","categories_index":"","tags_index":"iOS性能优化","author_index":"LittleStart"},{"id":"eafabc105702abbd3d554d5c51e703dd","title":"iOS内存对齐","content":"iOS中内存对齐数据对齐规则\n结构体和联合体（union）的数据成员，第一个数据成员放到offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员子成员大小（只要该成员有子成员，比如说数组，结构体等）的整数倍开始（比如int为4自己接，则要从4的整数倍地址开始存储）\n\n结构体作为成员，则结构体成员要从其内部最大元素大小的整数倍开始存储( 那么b应该从8的整数倍开始存储)\nstruct GLStruct1 &#123;\n  char a; &#x2F;&#x2F; 1 + 7（不全七个）\n  double b; &#x2F;&#x2F; 8 字节\n  int c; &#x2F;&#x2F; 4 字节\n  short d; &#x2F;&#x2F; 2 字节\n&#125; GLStruct1;\n\n\nstruct GLStruct2 &#123;\n  double b; &#x2F;&#x2F; 8字节\n  char a; &#x2F;&#x2F; 1 字节\n   int c; &#x2F;&#x2F; 4 字节\n  short d; &#x2F;&#x2F;  2字节\n&#125; GLStruct2;\n\nNSLog(@&quot;%lu - %lu&quot;, sizeof(GLStruct1), sizeof(GLStruct1));\n\n关于分配内存8字节对齐#import &lt;Foundation&#x2F;Foundation.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface GLPerson : NSObject\n  \n@Property (nonatomic, copy) NSString *name;\n@Property (nonatomic, assign) int age;\n@Property (nonatomic, assign) long height;\n@Property (nonatomic, copy) NSString *hobby;\n\n\n\n&#x2F;&#x2F; @Property (nonatomic, assign) int sex;\n&#x2F;&#x2F; @Property (nonatomic) char ch1;\n&#x2F;&#x2F; @Property (nonatomic) char ch2;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n\n\nGLPerson *person &#x3D; [GLPerson alloc];\nperson.name &#x3D; @&quot;张三&quot;；\nperson.age &#x3D; 18;\nperson.height &#x3D; 180;\nperson.hobby &#x3D; @&quot;nv&quot;\n  \n总共分配对象实例的内存大小： \n  isa 8个字节\n  name 8个字节\n  age  4个字节\n  height 8个字节\n  hobby  8个字节\n  \nNSLog(@&quot;%lu - %lu&quot;, class_getInstancesClass([person class]))\n\n注意：对象申请的内存大小  VS  系统开辟的大小 不一致\nvoid *\ncalloc(size_t num_items, size_t size)\n&#123;\n\tvoid *retval;\n\tretval &#x3D; malloc_zone_calloc(default_zone, num_items, size);\n\tif (retval &#x3D;&#x3D; NULL) &#123;\n\t\terrno &#x3D; ENOMEM;\n\t&#125;\n\treturn retval;\n&#125;\n\n\n\n\nvoid *\nmalloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n\tMALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);\n\n\tvoid *ptr;\n\tif (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;&#x3D; malloc_check_start)) &#123;\n\t\tinternal_check();\n\t&#125;\n\n\tptr &#x3D; zone-&gt;calloc(zone, num_items, size);\n\t\n\tif (malloc_logger) &#123;\n\t\tmalloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,\n\t\t\t\t(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);\n\t&#125;\n\n\tMALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);\n\treturn ptr;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n找到对应下方方法\np zone-&gt;calloc\n\n\n\nstatic void *\ndefault_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n\tzone &#x3D; runtime_default_zone();\n\t\n\treturn zone-&gt;calloc(zone, num_items, size);\n&#125;\n\n\n\nstatic void *\nnano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)\n&#123;\n\tsize_t total_bytes;\n\n\tif (calloc_get_size(num_items, size, 0, &amp;total_bytes)) &#123;\n\t\treturn NULL;\n\t&#125;\n\n\tif (total_bytes &lt;&#x3D; NANO_MAX_SIZE) &#123;\n\t\tvoid *p &#x3D; _nano_malloc_check_clear(nanozone, total_bytes, 1);\n\t\tif (p) &#123;\n\t\t\treturn p;\n\t\t&#125; else &#123;\n\t\t\t&#x2F;* FALLTHROUGH to helper zone *&#x2F;\n\t\t&#125;\n\t&#125;\n\tmalloc_zone_t *zone &#x3D; (malloc_zone_t *)(nanozone-&gt;helper_zone);\n\treturn zone-&gt;calloc(zone, 1, total_bytes);\n&#125;\n\n\n\n\nstatic void *\n_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)\n&#123;\n\tMALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, 0);\n\n\tvoid *ptr;\n\tsize_t slot_key;\n\tsize_t slot_bytes &#x3D; segregated_size_to_fit(nanozone, size, &amp;slot_key); &#x2F;&#x2F; Note slot_key is set here\n\tmag_index_t mag_index &#x3D; nano_mag_index(nanozone);\n\n\tnano_meta_admin_t pMeta &#x3D; &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);\n\n\tptr &#x3D; OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));\n\tif (ptr) &#123;\n\t\tunsigned debug_flags &#x3D; nanozone-&gt;debug_flags;\n#if NANO_FREE_DEQUEUE_DILIGENCE\n\t\tsize_t gotSize;\n\t\tnano_blk_addr_t p; &#x2F;&#x2F; the compiler holds this in a register\n\n\t\tp.addr &#x3D; (uint64_t)ptr; &#x2F;&#x2F; Begin the dissection of ptr\n\t\tif (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Invalid signature for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tif (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Mismatched magazine for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tgotSize &#x3D; _nano_vet_and_size_of_free(nanozone, ptr);\n\t\tif (0 &#x3D;&#x3D; gotSize) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Invalid pointer %p dequeued from free list\\n&quot;, ptr);\n\t\t&#125;\n\t\tif (gotSize !&#x3D; slot_bytes) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Mismatched size for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tif (!_nano_block_has_canary_value(nanozone, ptr)) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Heap corruption detected, free list canary is damaged for %p\\n&quot;\n\t\t\t\t\t&quot;*** Incorrect guard value: %lu\\n&quot;, ptr,\n\t\t\t\t\t((chained_block_t)ptr)-&gt;double_free_guard);\n\t\t&#125;\n\n#if defined(DEBUG)\n\t\tvoid *next &#x3D; (void *)(((chained_block_t)ptr)-&gt;next);\n\t\tif (next) &#123;\n\t\t\tp.addr &#x3D; (uint64_t)next; &#x2F;&#x2F; Begin the dissection of next\n\t\t\tif (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Invalid next signature for pointer %p dequeued from free &quot;\n\t\t\t\t\t\t&quot;list, next &#x3D; %p\\n&quot;, ptr, &quot;next&quot;);\n\t\t\t&#125;\n\n\t\t\tif (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Mismatched next magazine for pointer %p dequeued from &quot;\n\t\t\t\t\t\t&quot;free list, next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\n\t\t\tgotSize &#x3D; _nano_vet_and_size_of_free(nanozone, next);\n\t\t\tif (0 &#x3D;&#x3D; gotSize) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Invalid next for pointer %p dequeued from free list, &quot;\n\t\t\t\t\t\t&quot;next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\t\t\tif (gotSize !&#x3D; slot_bytes) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Mismatched next size for pointer %p dequeued from free &quot;\n\t\t\t\t\t\t&quot;list, next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\t\t&#125;\n#endif &#x2F;* DEBUG *&#x2F;\n#endif &#x2F;* NANO_FREE_DEQUEUE_DILIGENCE *&#x2F;\n\n\t\t((chained_block_t)ptr)-&gt;double_free_guard &#x3D; 0;\n\t\t((chained_block_t)ptr)-&gt;next &#x3D; NULL; &#x2F;&#x2F; clear out next pointer to protect free list\n\t&#125; else &#123;\n\t\tptr &#x3D; segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);\n\t&#125;\n\n\tif (cleared_requested &amp;&amp; ptr) &#123;\n\t\tmemset(ptr, 0, slot_bytes); &#x2F;&#x2F; TODO: Needs a memory barrier after memset to ensure zeroes land first?\n\t&#125;\n\treturn ptr;\n&#125;\n\n\n\nstatic MALLOC_INLINE size_t\nsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)\n&#123;\n\t&#x2F;&#x2F; size &#x3D; 40\n\tsize_t k, slot_bytes;\n\n\tif (0 &#x3D;&#x3D; size) &#123;\n\t\tsize &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior\n\t&#125;\n\t&#x2F;&#x2F; 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4\n\t&#x2F;&#x2F; 40 - 16*3 &#x3D; 48\n\n\t&#x2F;&#x2F;\n\t&#x2F;&#x2F; 16 字节对齐\n\tk &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta\n\tslot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;\t\t\t\t\t\t\t&#x2F;&#x2F; multiply by power of two quanta size\n\t*pKey &#x3D; k - 1;\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; Zero-based!\n\n\treturn slot_bytes;\n&#125;\n\n","slug":"Memory-alignment","date":"2021-05-03T00:55:06.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"a519dcebcf7b75aa7909ffb897e4913c","title":"Spring基础了解","content":"Spring 简介​        Spring 是分层的 full-stack（全栈） 轻量级开源框架，以IoC和 AOP 为内核，提供了展现层Spring MVC和业务层事务管理等众多的企业级应⽤技术，还能整合开源世界众多著名的第三⽅框架和类库，已 经成为使⽤最多的Java EE企业应⽤开源框架。\nSpring Framework\n\n\n\n\n\n\n\n\n\n提供依赖注入的核心支持，事务管理，web apps 、数据访问、消息以及其他更多\n\n\nSpring 的优势整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀ 天，就能体会到它的⼀些优势。 \n\n**⽅便解耦，简化开发 **\n\n通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的 过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更 专注于上层的应⽤。 \n\n**AOP编程的⽀持 **\n\n通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过 AOP轻松应付。 \n\n**声明式事务的⽀持 **\n\n@Transactional 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼ 开发效率和质量。\n\n**⽅便程序的测试 **\n\n可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的 事情。 \n\n⽅便集成各种优秀框架 \n\nSpring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接⽀持。 降低JavaEE API的使⽤难度 Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤ 难度⼤为降低。\n\n**源码是经典的 Java 学习范例 **\n\nSpring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对 Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。\nSpring 的核⼼结构Spring是⼀个分层⾮常清晰并且依赖关系、职责定位⾮常明确的轻量级框架，主要包括⼏个⼤模块：数 据处理模块、Web模块、AOP（Aspect Oriented Programming）/Aspects模块、Core Container模块 和 Test 模块，如下图所示，Spring依靠这些基本模块，实现了⼀个令⼈愉悦的融合了现有解决⽅案的零 侵⼊的轻量级框架。\n\n\nSpring核⼼容器（Core Container） 容器是Spring框架最核⼼的部分，它管理着Spring应⽤中 bean的创建、配置和管理。在该模块中，包括了Spring bean⼯⼚，它为Spring提供了DI的功能。 基于bean⼯⼚，我们还会发现有多种Spring应⽤上下⽂的实现。所有的Spring模块都构建于核⼼ 容器之上。 \n⾯向切⾯编程（AOP）/Aspects Spring对⾯向切⾯编程提供了丰富的⽀持。这个模块是Spring应 ⽤系统中开发切⾯的基础，与DI⼀样，AOP可以帮助应⽤对象解耦。\n数据访问与集成（Data Access/Integration）\nSpring的JDBC和DAO模块封装了⼤量样板代码，这样可以使得数据库代码变得简洁，也可以更专 注于我们的业务，还可以避免数据库资源释放失败⽽引起的问题。 另外，Spring AOP为数据访问 提供了事务管理服务，同时Spring还对ORM进⾏了集成，如Hibernate、MyBatis等。该模块由 JDBC、Transactions、ORM、OXM 和 JMS 等模块组成。\nWeb 该模块提供了SpringMVC框架给Web应⽤，还提供了多种构建和其它应⽤交互的远程调⽤⽅ 案。 SpringMVC框架在Web层提升了应⽤的松耦合⽔平。\nTest 为了使得开发者能够很⽅便的进⾏测试，Spring提供了测试模块以致⼒于Spring应⽤的测 试。 通过该模块，Spring为使⽤Servlet、JNDI等编写单元测试提供了⼀系列的mock对象实现\n核⼼思想1.1 什么是IoC？IoC Inversion of Control (控制反转/反转控制)，注意它是⼀个技术思想，不是⼀个技术实现 描述的事情：Java开发领域对象的创建，管理的问题 传统开发⽅式：⽐如类A依赖于类B，往往会在类A中new⼀个B的对象\nIoC思想下开发⽅式：我们不⽤⾃⼰去new对象了，⽽是由IoC容器（Spring框架）去帮助我们实例化对 象并且管理它，我们需要使⽤哪个对象，去问IoC容器要即可 我们丧失了⼀个权利（创建、管理对象的权利）,得到了⼀个福利（不⽤考虑对象的创建、管理等⼀系列 事情）\n为什么叫做控制反转？ 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器)\n没有IoC容器\n\n\n使用IoC容器\n\n\nIoC 解决什么问题\n\n\n\n\n\n\n\n\n主要解决对象之间的耦合问题\n IoC和DI的区别 DI：\n\n\n\n\n\n\n\n\n\n Dependancy Injection（依赖注⼊）  IOC和DI描述的是同⼀件事情，只不过⻆度不⼀样罢了\n\nIOC 和 DI 描述的是同一件事情，对象实例化以及依赖关系的维护这件事情，只不过角度不同\nIOC是从对象的角度，对象实例化以及管理权交给IoC容器\nDI是在容器角度，容器会把对象依赖其他对象注入（送进去）比如A对象实例化过程因为声明啦一个B类型的属性，那么就要把对象B注入到A中\n\nAOP什么是AOP AOP\n\n\n\n\n\n\n\n\n Aspect oriented Programming ⾯向切⾯编程/⾯向⽅⾯编程 AOP是OOP的延续，从OOP说起\nOOP三⼤特征\n\n\n\n\n\n\n\n\n 封装、继承和多态 oop是⼀种垂直继承体系\nOOP编程思想可以解决⼤多数的代码重复问题，但是有⼀些情况是处理不了的，⽐如下⾯的在顶级⽗类 Animal中的多个⽅法中相同位置出现了重复代码，OOP就解决不了\n","slug":"Spring-base","date":"2021-05-02T06:22:41.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"83f1863d7d241c1d5ddb943bddf231fd","title":"动态SQL","content":"动态sql语句**动态sql语句概述 **\n\n\n\n\n\n\n\n\n\n Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动 态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n","slug":"dynamicSQL","date":"2021-05-01T23:43:13.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"20c5d0afd79142c4ce377e5e3d6eadea","title":"alloc&init探究","content":"alloc 和 init 基本原理LGPerson *p &#x3D; [[LGPerson alloc] init];\n LGPerson *p1 &#x3D; [p init];\n &#x2F;&#x2F; objc_msgSend （id 消息接收者，sel 发送消息）\n LGPerson *p2 &#x3D; [p init];\n NSLog(@&quot;输出将结果如下： %p-%p-%p&quot;, p, p1, p2);\n NSLog(@&quot;end&quot;); &#x2F;&#x2F;\n\n1. 探究问题\nalloc 探究\nalloc 已经创建了对象init\nalloc 怎么实现创建\nalloc 实现- 原理-源码实现\n\n2. 探究方式\nlibobjc.A.dylib\n\n下断点： control + in - objc_alloc\n\n下符号断点：libobjc.A.dylib`+[NSObjject alloc]\n\n通过汇编方式libobjc.A.dylib\nDebug -&gt; Debug workflow -&gt; Always Show Disassembly\n\n\n![](截屏2021-05-01 下午6.01.02.png)\n\n\n注意：\n\n\n\n\n\n\n\n\n使用真机调试\nlibobjc.A.dylib 库关于 objc_alloc: \n\nalloc 方法实现\n首先申请内存空间，给指针地址\nregister read x0 方法读取寄存器的值\nx0 即是返回对象的地址，以及存储数据的地方\n\nalloc 实现源码执行的过程\n调用alloc方法\n\n+ (id)alloc &#123;\n  return _objc_rootAlloc(self);\n&#125;\n\n\n调用_objc_rootAlloc(Class cls) 方法\n\n_objc_rootAlloc(Class cls)\n&#123;\n    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);\n&#125;\n\n\nstatic ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) \n\nstatic ALWAYS_INLINE id\ncallAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)\n&#123;\n    if (slowpath(checkNil &amp;&amp; !cls)) return nil;\n\n#if __OBJC2__\n    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;\n        &#x2F;&#x2F; No alloc&#x2F;allocWithZone implementation. Go straight to the allocator.\n        &#x2F;&#x2F; fixme store hasCustomAWZ in the non-meta class and \n        &#x2F;&#x2F; add it to canAllocFast&#39;s summary\n        if (fastpath(cls-&gt;canAllocFast())) &#123;\n            &#x2F;&#x2F; No ctors, raw isa, etc. Go straight to the metal.\n            bool dtor &#x3D; cls-&gt;hasCxxDtor();\n            id obj &#x3D; (id)calloc(1, cls-&gt;bits.fastInstanceSize());\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            obj-&gt;initInstanceIsa(cls, dtor);\n            return obj;\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; Has ctor or raw isa or something. Use the slower path.\n            id obj &#x3D; class_createInstance(cls, 0);\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\n            return obj;\n        &#125;\n    &#125;\n#endif\n\n    &#x2F;&#x2F; No shortcuts available.\n    if (allocWithZone) return [cls allocWithZone:nil];\n    return [cls alloc];\n&#125;\n\n\n通过class_createInstance创建类的实例\n\nid \nclass_createInstance(Class cls, size_t extraBytes)\n&#123;\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n&#125;\n\n\nstatic __attribute__((always_inline))  id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil) 方法\n\nstatic __attribute__((always_inline)) \nid\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct &#x3D; true, \n                              size_t *outAllocatedSize &#x3D; nil)\n&#123;\n    if (!cls) return nil;\n\n    assert(cls-&gt;isRealized());\n\n    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance\n    bool hasCxxCtor &#x3D; cls-&gt;hasCxxCtor();\n    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();\n    bool fast &#x3D; cls-&gt;canAllocNonpointer();\n\n    size_t size &#x3D; cls-&gt;instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize &#x3D; size;\n\n    id obj;\n    if (!zone  &amp;&amp;  fast) &#123;\n      \t&#x2F;&#x2F; 分配内存空间的方法\n        obj &#x3D; (id)calloc(1, size);\n        if (!obj) return nil;\n        &#x2F;&#x2F; 关联内存空间\n        &#x2F;&#x2F; obj 指向实例对象\n        obj-&gt;initInstanceIsa(cls, hasCxxDtor);\n    &#125; \n    else &#123;\n        if (zone) &#123;\n          &#x2F;&#x2F;  分配内存空间\n            obj &#x3D; (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);\n        &#125; else &#123;\n          &#x2F;&#x2F; 分配内存空间\n            obj &#x3D; (id)calloc(1, size);\n        &#125;\n        if (!obj) return nil;\n\n        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be \n        &#x2F;&#x2F; doing something weird with the zone or RR.\n        obj-&gt;initIsa(cls);\n    &#125;\n\n    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;\n        obj &#x3D; _objc_constructOrFree(obj, cls);\n    &#125;\n\n    return obj;\n&#125;\n\n\n\n\n\n读取寄存器方法register read\n\n\n\n\n\n内存对齐size_t instanceSize(size_t extraBytes) &#123;\n        size_t size &#x3D; alignedInstanceSize() + extraBytes;\n        &#x2F;&#x2F; CF requires all objects be at least 16 bytes.\n        if (size &lt; 16) size &#x3D; 16;\n        return size;\n&#125;\n\n内存对齐\nuint32_t alignedInstanceSize() &#123;\n        return word_align(unalignedInstanceSize());\n    &#125;\n\n内存查看地址\n\n\n\n\n\n\n\n\n通过下面LLDB命令读取内从地址\nx p (倒着读取相应的数据)\n\n\n\nx&#x2F;4xg p （4xg 可以 5xg 6xg）\n\n","slug":"alloc","date":"2021-05-01T09:45:39.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"9d874e909a3a7a396d1451469b922294","title":"Mybatis对象关系映射","content":"对象/关系数据库映射(ORM)\n\n\n\n\n\n\n\n\nORM全称Object/Relation Mapping:表示对象-关系映射的缩写\nORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向 对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把关系数据库包装成面向对 象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架 后，应用程序不再直接访问底层数据库，而是以面向对象的放松来操作持久化对象，而ORM框架则将这 些面向对象的操作转换成底层SQL操作。ORM框架实现的效果:把对持久化对象的保存、修改、删除 等操作，转换为对数据库的操作\nMybatis简介MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映 射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的 XML或注解来配置和映射原生类型、接口和Java的POJO (Plain Old Java Objects,普通老式Java对 象) 为数据库中的记录。\nMybatis优势Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n        &lt;transactionManager type=\"JDBC\"/>\n    &lt;!--Mybatis使用的连接池-->\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///zdy_mybatis\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"password\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;!--引入映射文件件-->\n    &lt;mappers>\n        &lt;mapper resource=\"UserMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n\n配置文件解析其中，事务管理器(transactionManager)类型有两种:\n\nJDBC:这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作\n\n用域。\n\nMANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生 命周期(比如 JEE 应用服务器的上下文)。 默认情况下它会关闭连接，然而一些容器并不希望这样，因 此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。\n\n其中，数据源(dataSource)类型有三种:\n\n**UNPOOLED:**这个数据源的实现只是每次被请求时打开和关闭连接。\n\n**POOLED:**这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。\n\n**JNDI:**这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置 数据源，然后放置一个 JNDI 上下文的引用。\n\n\n@Test\n    public void demoTest() throws IOException &#123;\n\n        //加载核心配置文件\n        InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //获得sqlSession工厂对象\n        // 见解析配置文件，并创建建sqlSessionFactory 工厂\n        SqlSessionFactory sqlSessionFactory = new\n                SqlSessionFactoryBuilder().build(resourceAsStream);\n            //获得sqlSession对象，默认开启一个事务，但是不会自动提交事务，需要shou\n        SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句\n        List&lt;User> userList = sqlSession.selectList(\"userMapper.findAll\"); //打印结果\n        System.out.println(userList);\n        // sqlSession.insert(\"userMapper.saveUser\");\n//释放资源\n        sqlSession.close();\n    &#125;\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"userMapper\">\n    &lt;select id=\"findAll\" resultType=\"com.lagou.pojo.User\">\n    select * from User\n  &lt;/select>\n\n    &lt;insert id=\"saveUser\" parameterType=\"com.lagou.pojo.User\">\n        insert into user values(#&#123;id&#125;,#&#123;username&#125;)\n    &lt;/insert>\n\n    &lt;update id=\"updateUser\" parameterType=\"com.lagou.pojo.User\">\n        update user set username = #&#123;username&#125; where id = #&#123;id&#125;\n    &lt;/update>\n&lt;!--删除操作，都是随便写的-->\n    &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\n        delete from user where id = #&#123;id&#125;\n    &lt;/delete>\n\n&lt;/mapper>\n\n\n\nSqlSession会话对象\n\n\n\n\n\n\n\n\n SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和 获取映射器实例的方法。 执行语句的方法主要有：\n主要使用方法\n&lt;T> T selectOne(String statement, Object parameter)\n&lt;E> List&lt;E> selectList(String statement, Object parameter)\nint insert(String statement, Object parameter)\nint update(String statement, Object parameter)\nint delete(String statement, Object parameter)\n\n操作事务的方法\nvoid commit()\nvoid rollback()\n\n\n\n代理开发模式 代理开发方式介绍 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 \nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口 定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\nMapper 接口开发需要遵循以下规范：**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 **\n**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 **\n**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 **\n4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n","slug":"Mybatis对象关系映射","date":"2021-04-29T12:12:40.000Z","categories_index":"","tags_index":"Mybatis","author_index":"LittleStart"},{"id":"8d5bb184f1a8d1302f056982173a3dd0","title":"如何Category中增加属性","content":"如何在Category中增加属性（关联对象）在实际开发中，如果为Category添加一个属性，那么系统将不会为这个属性设置访问器方法，也就是setter和getter方法。这时候可以使用runtime提供的关联对象方法，动态地为该属性实现访问器方法。\n开发者可以将关联对象想象成一个Objective-C对象，这个对象通过一个预先设置好的key连接到类的一个实例上。runtime提供了如下方法让一个对象连接到其他对象。\nvoid objc_setAssociatedObject(id  _Nonnull NSObject, const void * _Nonnull key_, id  _Nullable value, objc_AssociationPolicy policy)\n\n参数object是将要被关联的对象。参数key是一个void指针。\n参数value是关联对象，它是id类型。\n参数policy是指定一个内存管理策略来处理关联对象如下：\n指定的策略 \n\nOBJC_ASSOCIATION_ASSIGN，那么被关联对象释放时，关联对象不会被释放，\n\n\nOBJC_ASSOCIATION_RETAIN或OBJC_ASSOCIATION_COPY，那么关联对象就会被释放。\n\nOBJC_ASSOCIATION_RETAIN_NONATOMIC和OBJC_ASSOCIATION_COPY_NONATOMIC两种策略，当需要在多个线程中处理访问关联对象的多线程代码时，就会变得非常有用。\n\n\nruntime还提供了移除关联对象的方法：\nobjc_removeAssociatedObjects(id  _Nonnull object)\n\n\n可以使用这个方法移除所有和参数object关联的对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。\n例子：\n给Person类别添加一个属性 address\n#import &quot;Person.h&quot;\n#import &lt;objc&#x2F;runtime.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface Person (Cate)\n\n@property (nonatomic, strong) NSString *address;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n\nPerson+Cate.m 文件\n#import &quot;Person+Cate.h&quot;\n\n@implementation Person (Cate)\n\n- (id)address &#123;\n    id value &#x3D; objc_getAssociatedObject(self, &quot;address&quot;);\n    return value;\n&#125;\n\n- (void)setAddress:(NSString *)address &#123;\n    objc_setAssociatedObject(self, &quot;address&quot;, address, OBJC_ASSOCIATION_RETAIN);\n&#125;\n\n@end\n\n\n结果说明已经成功地在Category中为类添加了一个新的属性，并且能够正常地使用这个属性。事实上，关联对象是使用哈希表实现的，将一个类映射到一张哈希表上，然后根据key找到关联对象，所以严格来说，关联对象和被关联对象没有任何关系，它不是存储在对象的内部。\n","slug":"如何Category中增加属性","date":"2021-04-29T11:17:24.000Z","categories_index":"","tags_index":"","author_index":"LittleStart"},{"id":"afb2b07e802409f4fec5da7128301e15","title":"如何提高面试率.md","content":"\n“成功者讲方法，失败者讲理由！”虽然是一句老掉牙的话，但却饱含人生哲理。面对越来越激烈的竞争局面，以及后续大批新人的涌入，我们不仅要埋头苦干，提升自己的专业技能，更需要学会一些面试技巧，因为这些技巧会让你的求职之路事半功倍，为你赢得更多可能性。\n我的这些面试技巧分为，面试前准备、面试中展现，以及面试后复盘这三部分，有了这些技巧再加上你的专业技能，相信一定可以“披荆斩棘”斩获更多的 Offer，为自己的未来赢得更多可能。\n首先，是面试前准备凡事预则立不预则废，在正式“打仗”之前，我们一定要仔细研究“对手”，对于面试也是这样，只有预先准备才有可能获得成功，面试前或者是投简历前我们要先研究两个问题，第一，这个公司的主营业务是什么？第二，这个公司使用的技术栈是什么？研究了公司的主营业务后，你自然就会知道在简历中应体现哪些重点内容了。比如这家公司是做电商的，你之前既做过教育，又做过电商，也做过医疗，那么你应该重点将电商的项目经验和从业经历体现在简历上，这样你获得面试的概率和成功的概率就会大很多，毕竟公司都希望招聘到“更合适”的人。这里并不是鼓励你造假，只是提醒你可以从众多项目中，提取并展示和这个公司业务相匹配的项目。\n研究公司的技术栈也是同样的道理，技术经理也希望招来的人能直接上手，所以在写简历时或者面试时就可以重点向目标公司的技术栈靠拢。但有一点要特别注意，你说的这些技术点也是应聘单位擅长的技术栈，如果你真的懂，可以引导面试官往这个技术点上靠拢。但如果你对这些技术不是很擅长，切记千万不要这么做，这样只会适得其反，所以你应在简历和面试中重点突出你擅长的技术栈，并尽量向应聘公司的技术栈靠拢。除以上内容外，你还要准备一些常见的面试问题，比如你是如何看待加班的？你可以这样回答：你个人不认同无效加班，更倾向于以事情为导向，高效地处理完成工作，但如果公司赶项目或者有偶尔有加班的情况，自己也并不排斥，愿意跟着公司步伐走。又比如面试结尾，你还有什么问题要问我吗？等等类似的问题，都需要提前准备一下。\n在写简历时，还需要注意以下几点：• 第一，扬长避短，将优势点放在核心位置。比如你是大专文凭，那么就应该把教育背景写在简历的最下方也就是最不起眼的地方，而在最重要的位置优先展示自己的特长信息；• 第二，信息清晰，写清必要的内容。比如你要应聘的岗位以及期望薪资，而不是“面议”，因为有些 HR 看到信息模糊的简历会将其直接将其丢弃，因为她不确认你的能力和你期望的薪资是否匹配，如果应聘者很多的情况下，应聘单位就没必要“冒险”给一个不确定的人面试的机会了；• 第三，准确地描述项目经验。项目经验一般 3 个左右即可，需要描述的内容大致有：这个项目是什么？你负责什么模块？项目中使用了什么技术栈？项目的上线地址是什么？项目中有没有遇到什么问题？你是如何解决？等等内容。面试中展现在面试中你首先应该展示的是你的专业技术技能，让面试官充分了解你对某项技术的掌握情况，你可以深入讲解某个项目中的细节技术处理方案，或者通过一个深入的技术点展示你对这项技术的熟练掌握程度。如果你是学生的话，可以用成果证明，比如你的竞赛成绩或者获奖证书等。除了专业技能外，你还应在面试中展示你良好的沟通能力和理解能力，通过你的言行举止和沟通交流的内容，面试官便能对此有所察觉和判断，你需要注意的就是不要有抵抗或者是消极的情绪，正常发挥就行。面试中另一个需要注意的点就是要尽量展现你坦诚的一面。不会的知识点，回答不会就好，不要滥竽充数，也不要顾左右而言他，因为面试官一般都不傻，并且在面试的过程中，有不会的知识点和面试题也很正常，每个人不可能知道所有的答案，坦诚回答就好。\n另一个是和你的专业技能同样重要，在面试中你应该尽量展现你对技术的热爱，因为只有热爱的东西你才可能把它做好，它决定了你以后技术发展的速度和深度，因此面试官对此会特别在意，能展现你对技术的热爱的点有以下几个：• 写技术博客• 创作技术视频，比如在 B 站分享你的技术视频• 在 GitHub 上有参与开源项目或者自己的开源项目• 有自己的个人博客或者是其他个人工具网站• 出书或者是技术专栏\n以上这些方面，都是你对技术热爱的一些具体体现。最后在面试中你也要尽量展现你的求知欲，比如爱好看书、参加技术沙龙等，这些都能体现你对技术的孜孜追求，有追求的人进步一般都很快，因此也更受用人企业的欣赏和认同。\n","slug":"如何提高面试率","date":"2021-04-24T02:06:35.000Z","categories_index":"","tags_index":"iOS","author_index":"LittleStart"}]