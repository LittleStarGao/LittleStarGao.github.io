{"total":19,"pageSize":12,"pageCount":2,"data":[{"title":"iOS设计模式（一）","uid":"69226c43fa619d7df7756bf099da8b7a","slug":"iOS设计模式（一）","date":"2021-09-30T12:30:53.000Z","updated":"2021-10-01T01:00:07.655Z","comments":true,"path":"api/articles/iOS设计模式（一）.json","cover":[],"text":"类继承和对象组合 类继承简单直接、硬卧关系在编译静态定义 被复用的实现易于修改 缺点： 因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现 子类描述在父类、 子类直接面对父类的封装、因此破坏了封装 父类实现的任何变更都会强制爱子类到的变更 因为在新的问题场景下京城...","link":"","photos":[],"count_time":{"symbolsCount":471,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"单元测试","uid":"78bacd8b33e55bbfb6a2cbf684cbf20b","slug":"unit-test","date":"2021-07-13T03:32:17.000Z","updated":"2021-07-14T07:45:20.214Z","comments":true,"path":"api/articles/unit-test.json","cover":null,"text":"别测试代码，而应该验证程序的行为测试应该只在程序的行为和预期的不一样时，才不通过。测试应该测试程序的代码做了什么，而不是测试程序如何实现。 验证应用程序做了什么的，叫做行为测试。 即使应用程序的行为不发生变化，只要应用程序的代码发生了变化，测试就不通过的，叫做脆性测试。 假设我们...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"单元测试","slug":"单元测试","count":1,"path":"api/tags/单元测试.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"iOS 组件化拆分总结","uid":"08c633a5de2fe3edfdf41cfdec1b1bae","slug":"iOS-component","date":"2021-06-11T08:05:51.000Z","updated":"2021-06-18T07:36:33.579Z","comments":true,"path":"api/articles/iOS-component.json","cover":[],"text":"组件化一、为何要组件化? 这是我们在做组件化的时候要思考的，它的优点和缺点是什么，这样我们对组件化有个基本认识 1. 组件化定义 组件是由一个或多个类构成，能完整描述一个业务场景，并能被其他业务场景复用的功能单位。 比如内存，硬盘，CPU，显示器等，拿出其中任何一个部件都能被其他...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"组件化","slug":"组件化","count":1,"path":"api/tags/组件化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"Xcode Server CI 持续集成","uid":"d68e4e31d1e8b7032dd88c62b8f9b3ca","slug":"Xcode-Server-CI-持续集成","date":"2021-06-10T07:58:03.000Z","updated":"2021-06-10T10:09:07.497Z","comments":true,"path":"api/articles/Xcode-Server-CI-持续集成.json","cover":[],"text":"Xcode Server CI 持续集成一、 Xcode Server 基本概念 Xcode Server是配置在Mac端的一个服务器，服务器上我们可以创建Bot自动执行机器人 软件应用程序在本地（Xcode development Macs）开发过程中，会将代码不断合并到git...","link":"","photos":[],"count_time":{"symbolsCount":574,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"持续集成","slug":"持续集成","count":1,"path":"api/tags/持续集成.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"async 和 await 同步等待","uid":"549def405a2020c02b3886501c2d84f3","slug":"async-await","date":"2021-06-01T03:45:18.000Z","updated":"2021-06-03T08:20:01.522Z","comments":true,"path":"api/articles/async-await.json","cover":null,"text":"Dart 获取相应数据操作 ","link":"","photos":[],"count_time":{"symbolsCount":22,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"抽象构造函数","uid":"6af98c5762fa00ab05498386038da6c3","slug":"abstractClass","date":"2021-06-01T02:16:37.000Z","updated":"2021-06-01T02:36:46.235Z","comments":true,"path":"api/articles/abstractClass.json","cover":null,"text":"抽象类 abstract关键字修饰class 继承的方式使用 接口的方式使用 abstract class Message &#123; factory Message(String type) &#123; switch(type) &#123; case 'foot': re...","link":"","photos":[],"count_time":{"symbolsCount":825,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DartClass","uid":"3b284d7eb9880174f64e9bf09d231aff","slug":"DartClass","date":"2021-06-01T01:28:38.000Z","updated":"2021-06-01T02:15:46.774Z","comments":true,"path":"api/articles/DartClass.json","cover":null,"text":"Dart 类相关的使用命名构造函数 Point.fromJSON(Map json) class Point &#123; num x; num y; Point(this.x, this.y); &#x2F;&#x2F; 命名构造函数（命名构造函数） Point.fromJSO...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DartException","uid":"1117fb54e92a8351488adf129028b2a6","slug":"DartException","date":"2021-05-31T09:06:01.000Z","updated":"2021-06-01T01:10:00.563Z","comments":true,"path":"api/articles/DartException.json","cover":null,"text":"Dart 异常处理操作![截屏2021-05-31 下午5.06.39](DartException/截屏2021-05-31 下午5.06.39.png) 延迟加载异常 DeferredLoadException 延迟加载异常 throw new FormateExceptio...","link":"","photos":[],"count_time":{"symbolsCount":505,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"应用性能分析方法","uid":"5c608ba3383f27b31f8830b3a9b5f6d6","slug":"应用性能分析方法","date":"2021-05-22T07:06:49.000Z","updated":"2021-05-22T07:08:32.663Z","comments":true,"path":"api/articles/应用性能分析方法.json","cover":null,"text":"应用性能分析方法1. 采样顾名思义，采样(或基于探测点的性能分析)是指以一定的周期间隔采集状态，这通常需要借助工具。由于不会干扰应用的执行，因此采样可以很好地提供应用的全景图。采样的不足之处在于它不能返回 100% 精确的细节。如果采样的频率是 10 毫秒，那么你就无法得知在探测...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":2,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"《腾讯iOS测试实践》学习（一）","uid":"72c9fa0d926f81572e4b5de9847c1152","slug":"《腾讯iOS测试实践》学习（一）","date":"2021-05-22T07:06:49.000Z","updated":"2021-10-01T09:40:20.073Z","comments":true,"path":"api/articles/《腾讯iOS测试实践》学习（一）.json","cover":[],"text":" 工程效率 需求评审：需求评审机制以及更新通知，避免需求有改动而没有及时同步到相关角色。 代码质量：静态代码扫描，千行代码缺陷率等。 架构评审：代码架构的讨论以及评审。 Bug流程：Bug生命周期，避免随便修改Bug状态以及备注缺失。 Code Review：代码评审，如果有代码...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"测试","slug":"测试","count":1,"path":"api/tags/测试.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"block基本结构（一）","uid":"837320c05a767825bb487e2f2edb4766","slug":"Block底层实现原理","date":"2021-05-22T07:06:49.000Z","updated":"2021-10-01T12:16:04.684Z","comments":true,"path":"api/articles/Block底层实现原理.json","cover":"https://static01.imgkr.com/temp/623564c792a84bd587a73355356d11f6.png","text":"block基本结构 block 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成 在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类 impl 是实际的指针函数、本例中，它指向 _main_block_fun...","link":"","photos":[],"count_time":{"symbolsCount":848,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"block","slug":"block","count":1,"path":"api/tags/block.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS性能优化指标","uid":"d6599ba5117b38d8d4d285c032bd712d","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","updated":"2021-05-22T06:09:06.209Z","comments":true,"path":"api/articles/iOS性能优化指标.json","cover":[],"text":"性能指标 性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。 1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":2,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}