{"total":40,"pageSize":12,"pageCount":4,"data":[{"title":"iOS中关于锁总结","uid":"5aeaa1caf03061ebea03dd5070710347","slug":"iOS中关于锁总结","date":"2021-10-03T09:58:28.000Z","updated":"2021-10-03T10:17:24.242Z","comments":true,"path":"api/articles/iOS中关于锁总结.json","cover":null,"text":"7、自旋锁 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类对象具体操作方法","uid":"cf0e611562c137ce26a0fd876069298a","slug":"类对象具体操作方法","date":"2021-10-03T09:52:41.000Z","updated":"2021-10-03T09:53:22.429Z","comments":true,"path":"api/articles/类对象具体操作方法.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"类与对象操作函数runtime提供了大量的函数来直接操作类与对象数据结构，类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。 类相关操作函数我们可以回过头去看看objc_cla...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"类对象","slug":"类对象","count":1,"path":"api/tags/类对象.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"OC消息发送","uid":"7d5af61f6682832ceaf909aad79a5565","slug":"OC消息发送","date":"2021-10-03T03:48:29.000Z","updated":"2021-10-03T04:02:14.462Z","comments":true,"path":"api/articles/OC消息发送.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"消息的发送ObjC中使用[Receiver message]方式来进行方法调用,本质其实就是向Receiver发送message消息.而message告诉这个Receiver要做什么 给nil发送消息 在ObjC中，给nil发送消息是合法的，但在运行时什么都不做，而发送给nil的...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"OC中的类","uid":"07b3470a92b5218af5f032e4b7c9894f","slug":"OC中的类","date":"2021-10-03T01:07:27.000Z","updated":"2021-10-03T03:45:15.921Z","comments":true,"path":"api/articles/OC中的类.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"OC中的类 编译器为每个类定义一个类对象(Class_object)。Class_object 是Class的编译版本，而它所构建的对象被称为类的实例 程序中真正做工作的是类在运行时对象创建的那些实例 一个类的所有实例有同一套方法，而且有相同一套实例变量 每个对象都有自己的实例变...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"OC类","slug":"OC类","count":1,"path":"api/tags/OC类.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Runloop探究总结（一）","uid":"024b1a5a8576bdfa18efbc793fd20736","slug":"Runloop探究总结（一）","date":"2021-10-03T00:34:38.000Z","updated":"2021-10-03T10:12:35.137Z","comments":true,"path":"api/articles/Runloop探究总结（一）.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"RunLoop 是什么？ Runloop是通过内部维护一个事件循环来对事件、消息进行管理的一个对象。是的，它是一个对象。 大家用C语言过main函数的都知道，main函数运行完成后程序就结束退出了。但是为什么iOS的App的main函数运行完之后APP还能一直运行呢？这就是Run...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Runloop","slug":"Runloop","count":1,"path":"api/tags/Runloop.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"OC 对象的本质","uid":"888e58a89b2f989fb3e2e1a0413d4445","slug":"OC-对象的本质","date":"2021-10-02T11:30:44.000Z","updated":"2021-10-03T09:52:16.337Z","comments":true,"path":"api/articles/OC-对象的本质.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"OC对象的本质 OC中类和对象都是基于C和C++的结构体实现的; OC中的对象分为三种：实例对象、类对象、元类对象 实例对象内存分批 OC 基类为NSObject，实例对象只有一个成员变量 isa typedef struct objc_class *Class; struct ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS总结（UIViewController）相关","uid":"723aff21bbff3d47a1a80bce7952c340","slug":"iOS面试总结（UIViewController）","date":"2021-10-02T10:21:11.000Z","updated":"2021-10-02T11:21:16.629Z","comments":true,"path":"api/articles/iOS面试总结（UIViewController）.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"UIViewController 在iOS应用运行中，屏幕中显示的内容是一组一组的视图对象，他们负责显示屏幕中的内容，而在视图的后面是UIViewController视图控制器，它的作用是管理哪些视图中显示的内容，并协调他们和应用其他部分的关系。 UIViewController...","link":"","photos":[],"count_time":{"symbolsCount":904,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIViewController","slug":"UIViewController","count":1,"path":"api/tags/UIViewController.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS面试问题总结（架构设计模式）","uid":"14b08975a30eb8616d67d5a52db5f251","slug":"iOS面试问题总结（架构设计模式）","date":"2021-10-02T02:57:55.000Z","updated":"2021-10-02T09:58:48.627Z","comments":true,"path":"api/articles/iOS面试问题总结（架构设计模式）.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"设计模式 设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。 设计模式是什么？ 你知道哪些设计模式，并简要叙述？ 1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。 2). MVVM模式：Model View Vi...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"设计模式、架构、MVVM","slug":"设计模式、架构、MVVM","count":1,"path":"api/tags/设计模式、架构、MVVM.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS UIView和CALayer关系","uid":"386fc4bc5a18ec12e9fe740e6fc9c9ef","slug":"iOS-UIView和CALayer关系","date":"2021-10-01T12:27:26.000Z","updated":"2021-10-03T09:56:06.433Z","comments":true,"path":"api/articles/iOS-UIView和CALayer关系.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"一、UIView 和 CALayer 探究 所有的UIView都有CALayer 驱动、view 和 Layer 紧密关系，view从layer 中获取所需要所有数据、layer 侧重图形表示，view 相当于layer管理者 UIView 继承自 UIResponder NS_...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"UIView","slug":"UIView","count":3,"path":"api/tags/UIView.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"《腾讯iOS测试实践》学习（一）","uid":"72c9fa0d926f81572e4b5de9847c1152","slug":"《腾讯iOS测试实践》学习（一）","date":"2021-10-01T07:06:49.000Z","updated":"2021-10-02T01:13:36.513Z","comments":true,"path":"api/articles/《腾讯iOS测试实践》学习（一）.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":" 工程效率 需求评审：需求评审机制以及更新通知，避免需求有改动而没有及时同步到相关角色。 代码质量：静态代码扫描，千行代码缺陷率等。 架构评审：代码架构的讨论以及评审。 Bug流程：Bug生命周期，避免随便修改Bug状态以及备注缺失。 Code Review：代码评审，如果有代码...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"测试","slug":"测试","count":1,"path":"api/tags/测试.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"block基本结构（一）","uid":"837320c05a767825bb487e2f2edb4766","slug":"Block底层实现原理","date":"2021-10-01T02:06:49.000Z","updated":"2021-10-01T12:38:32.094Z","comments":true,"path":"api/articles/Block底层实现原理.json","cover":"https://static01.imgkr.com/temp/623564c792a84bd587a73355356d11f6.png","text":"block基本结构 block 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成 在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类 impl 是实际的指针函数、本例中，它指向 _main_block_fun...","link":"","photos":[],"count_time":{"symbolsCount":848,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"block","slug":"block","count":1,"path":"api/tags/block.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS设计模式（一）","uid":"69226c43fa619d7df7756bf099da8b7a","slug":"iOS设计模式（一）","date":"2021-09-30T12:30:53.000Z","updated":"2021-10-02T01:12:40.559Z","comments":true,"path":"api/articles/iOS设计模式（一）.json","cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"类继承和对象组合 类继承简单直接、关系在编译时静态定义 被复用的实现易于修改 缺点： 因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现 子类描述在父类、 子类直接面对父类的封装、因此破坏了封装 父类实现的任何变更都会强制爱子类到的变更 因为在新的问题场景下京城实...","link":"","photos":[],"count_time":{"symbolsCount":470,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}