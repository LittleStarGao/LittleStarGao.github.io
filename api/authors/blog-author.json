{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"Flutter的Function函数对象","uid":"39ade3484174d56b659a76daf70210b1","slug":"Flutter的Function函数对象","date":"2021-12-17T01:07:57.000Z","updated":"2021-12-17T01:07:57.858Z","comments":true,"path":"api/articles/Flutter的Function函数对象.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"Flutter参数","uid":"ef5aa7e92bb61e597e24d0ade2427469","slug":"Flutter参数","date":"2021-12-17T01:01:05.000Z","updated":"2021-12-17T01:01:05.181Z","comments":true,"path":"api/articles/Flutter参数.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"Runtime总结","uid":"92ebd029be42f71fd12661e2724b68c4","slug":"Runtime总结","date":"2021-12-09T08:41:58.000Z","updated":"2021-12-09T08:41:58.997Z","comments":true,"path":"api/articles/Runtime总结.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"Dart函数","uid":"1e44f5b3bd24c99dd3f8c314188c1ad6","slug":"Dart函数","date":"2021-12-08T07:42:51.000Z","updated":"2021-12-08T07:42:51.179Z","comments":true,"path":"api/articles/Dart函数.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Dart运算符","uid":"a18a0021d0e3774e23afd0f4a2e611d8","slug":"Dart运算符","date":"2021-12-08T07:14:50.000Z","updated":"2021-12-08T07:43:09.854Z","comments":true,"path":"api/articles/Dart运算符.json","keywords":null,"cover":null,"text":"Dart 基础语法（运算符）本篇文章上接初探 Dart 语法上篇，主要涉及一些 Dart 中的运算符、异常、函数、面向对象等。 1. 运算符1.1 算术运算符 名称 运算符 例子 加 + var result = 1 + 1; 减 - var result = 5 - 1; 乘 ...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Dart基础语法总结","uid":"b31cd86eb2d45436159ffec7e16dc297","slug":"Dart基础语法总结","date":"2021-12-08T05:36:37.000Z","updated":"2021-12-08T07:43:02.842Z","comments":true,"path":"api/articles/Dart基础语法总结.json","keywords":null,"cover":null,"text":"Dart 基本输出操作void main() &#123; print('Hello World!');//注意：Dart 和 Java 一样表达式以分号结尾，写习惯 Kotlin 的小伙伴需要注意了，这可能是你从 Kotlin 转 Dart 最大不适之一。 &#125; //D...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Flutter","slug":"Flutter","count":1,"path":"api/tags/Flutter.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"NSDictionary实现原理","uid":"859f0b706fef61b48159b2531ea13be9","slug":"NSDictionary实现原理","date":"2021-12-08T05:04:53.000Z","updated":"2021-12-08T05:16:49.849Z","comments":true,"path":"api/articles/NSDictionary实现原理.json","keywords":null,"cover":null,"text":"/Users/jiajiagao/Desktop/截屏2021-11-26 下午2.39.43.png ","link":"","photos":[],"count_time":{"symbolsCount":52,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Mybatis环境搭建","uid":"84c46e71d38f152fbededa209add7e56","slug":"Mybatis环境搭建","date":"2021-10-30T11:49:03.000Z","updated":"2021-10-30T12:19:16.086Z","comments":true,"path":"api/articles/Mybatis环境搭建.json","keywords":null,"cover":[],"text":"MyBatis 环境搭建 mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。mybatis 通过 xml 或注解的方式将要执行...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"mybatis","slug":"mybatis","count":1,"path":"api/tags/mybatis.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"内存管理","uid":"5c41202f364c38ccdbd34c8ae458f2bb","slug":"内存管理","date":"2021-10-03T11:47:40.000Z","updated":"2021-10-03T11:57:17.487Z","comments":true,"path":"api/articles/内存管理.json","keywords":null,"cover":"https://images.xiaozhuanlan.com/photo/2019/0156fea8cc60760bdf6d2bd4229514d1.png","text":"内存布局栈(stack):方法调用，局部变量等，是连续的，高地址往低地址扩展 堆(heap):通过alloc等分配的对象，是离散的，低地址往高地址扩展，需要我们手动控制 未初始化数据(bss):未初始化的全局变量等 已初始化数据(data):已初始化的全局变量等 代码段(text...","link":"","photos":[],"count_time":{"symbolsCount":149,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"内存管理","slug":"内存管理","count":1,"path":"api/tags/内存管理.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"UIView图像卡顿掉帧原因","uid":"1f36431921db0064bd4a7d93ff9bda02","slug":"UIView图像卡顿掉帧原因","date":"2021-10-03T11:08:04.000Z","updated":"2021-10-03T11:46:26.139Z","comments":true,"path":"api/articles/UIView图像卡顿掉帧原因.json","keywords":null,"cover":"https://images.xiaozhuanlan.com/photo/2019/0156fea8cc60760bdf6d2bd4229514d1.png","text":"UI卡顿掉帧原因 iOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GP...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIView","slug":"UIView","count":3,"path":"api/tags/UIView.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"UIView图像显示原理","uid":"150d0752192ea36adfb8f6a2036d586d","slug":"UIView图像显示原理","date":"2021-10-03T11:05:50.000Z","updated":"2021-10-03T11:07:46.358Z","comments":true,"path":"api/articles/UIView图像显示原理.json","keywords":null,"cover":[],"text":"图像显示原理 image 1.CPU:输出位图 2.GPU :图层渲染，纹理合成 3.把结果放到帧缓冲区(frame buffer)中 4.再由视频控制器根据vsync信号在指定时间之前去提取帧缓冲区的屏幕显示内容 5.显示到屏幕上 CPU工作 1.Layout: UI布局，文本...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"UIView事件传递机制","uid":"e9b46794781d0a34e4fb025b5a7d50ca","slug":"UIView事件传递机制","date":"2021-10-03T10:54:58.000Z","updated":"2021-10-03T11:07:08.956Z","comments":true,"path":"api/articles/UIView事件传递机制.json","keywords":null,"cover":"https://images.xiaozhuanlan.com/photo/2019/0156fea8cc60760bdf6d2bd4229514d1.png","text":"事件传递与视图响应链 : - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event; - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; i...","link":"","photos":[],"count_time":{"symbolsCount":189,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIView","slug":"UIView","count":3,"path":"api/tags/UIView.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS中关于锁总结","uid":"5aeaa1caf03061ebea03dd5070710347","slug":"iOS中关于锁总结","date":"2021-10-03T09:58:28.000Z","updated":"2021-10-03T10:17:24.242Z","comments":true,"path":"api/articles/iOS中关于锁总结.json","keywords":null,"cover":null,"text":"7、自旋锁 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类对象具体操作方法","uid":"cf0e611562c137ce26a0fd876069298a","slug":"类对象具体操作方法","date":"2021-10-03T09:52:41.000Z","updated":"2021-10-03T09:53:22.429Z","comments":true,"path":"api/articles/类对象具体操作方法.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"类与对象操作函数runtime提供了大量的函数来直接操作类与对象数据结构，类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。 类相关操作函数我们可以回过头去看看objc_cla...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"类对象","slug":"类对象","count":1,"path":"api/tags/类对象.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"OC消息发送","uid":"7d5af61f6682832ceaf909aad79a5565","slug":"OC消息发送","date":"2021-10-03T03:48:29.000Z","updated":"2021-10-03T04:02:14.462Z","comments":true,"path":"api/articles/OC消息发送.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"消息的发送ObjC中使用[Receiver message]方式来进行方法调用,本质其实就是向Receiver发送message消息.而message告诉这个Receiver要做什么 给nil发送消息 在ObjC中，给nil发送消息是合法的，但在运行时什么都不做，而发送给nil的...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"OC中的类","uid":"07b3470a92b5218af5f032e4b7c9894f","slug":"OC中的类","date":"2021-10-03T01:07:27.000Z","updated":"2021-10-03T03:45:15.921Z","comments":true,"path":"api/articles/OC中的类.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"OC中的类 编译器为每个类定义一个类对象(Class_object)。Class_object 是Class的编译版本，而它所构建的对象被称为类的实例 程序中真正做工作的是类在运行时对象创建的那些实例 一个类的所有实例有同一套方法，而且有相同一套实例变量 每个对象都有自己的实例变...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"OC类","slug":"OC类","count":1,"path":"api/tags/OC类.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Runloop探究总结（一）","uid":"024b1a5a8576bdfa18efbc793fd20736","slug":"Runloop探究总结（一）","date":"2021-10-03T00:34:38.000Z","updated":"2021-10-03T10:12:35.137Z","comments":true,"path":"api/articles/Runloop探究总结（一）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"RunLoop 是什么？ Runloop是通过内部维护一个事件循环来对事件、消息进行管理的一个对象。是的，它是一个对象。 大家用C语言过main函数的都知道，main函数运行完成后程序就结束退出了。但是为什么iOS的App的main函数运行完之后APP还能一直运行呢？这就是Run...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Runloop","slug":"Runloop","count":1,"path":"api/tags/Runloop.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"OC 对象的本质","uid":"888e58a89b2f989fb3e2e1a0413d4445","slug":"OC-对象的本质","date":"2021-10-02T11:30:44.000Z","updated":"2021-10-03T09:52:16.337Z","comments":true,"path":"api/articles/OC-对象的本质.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"OC对象的本质 OC中类和对象都是基于C和C++的结构体实现的; OC中的对象分为三种：实例对象、类对象、元类对象 实例对象内存分批 OC 基类为NSObject，实例对象只有一个成员变量 isa typedef struct objc_class *Class; struct ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS总结（UIViewController）相关","uid":"723aff21bbff3d47a1a80bce7952c340","slug":"iOS面试总结（UIViewController）","date":"2021-10-02T10:21:11.000Z","updated":"2021-10-02T11:21:16.629Z","comments":true,"path":"api/articles/iOS面试总结（UIViewController）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"UIViewController 在iOS应用运行中，屏幕中显示的内容是一组一组的视图对象，他们负责显示屏幕中的内容，而在视图的后面是UIViewController视图控制器，它的作用是管理哪些视图中显示的内容，并协调他们和应用其他部分的关系。 UIViewController...","link":"","photos":[],"count_time":{"symbolsCount":904,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIViewController","slug":"UIViewController","count":1,"path":"api/tags/UIViewController.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS面试问题总结（架构设计模式）","uid":"14b08975a30eb8616d67d5a52db5f251","slug":"iOS面试问题总结（架构设计模式）","date":"2021-10-02T02:57:55.000Z","updated":"2021-10-02T09:58:48.627Z","comments":true,"path":"api/articles/iOS面试问题总结（架构设计模式）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"设计模式 设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。 设计模式是什么？ 你知道哪些设计模式，并简要叙述？ 1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。 2). MVVM模式：Model View Vi...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"设计模式、架构、MVVM","slug":"设计模式、架构、MVVM","count":1,"path":"api/tags/设计模式、架构、MVVM.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS UIView和CALayer关系","uid":"386fc4bc5a18ec12e9fe740e6fc9c9ef","slug":"iOS-UIView和CALayer关系","date":"2021-10-01T12:27:26.000Z","updated":"2021-10-03T09:56:06.433Z","comments":true,"path":"api/articles/iOS-UIView和CALayer关系.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"一、UIView 和 CALayer 探究 所有的UIView都有CALayer 驱动、view 和 Layer 紧密关系，view从layer 中获取所需要所有数据、layer 侧重图形表示，view 相当于layer管理者 UIView 继承自 UIResponder NS_...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"UIView","slug":"UIView","count":3,"path":"api/tags/UIView.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"《腾讯iOS测试实践》学习（一）","uid":"72c9fa0d926f81572e4b5de9847c1152","slug":"《腾讯iOS测试实践》学习（一）","date":"2021-10-01T07:06:49.000Z","updated":"2021-10-02T01:13:36.513Z","comments":true,"path":"api/articles/《腾讯iOS测试实践》学习（一）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":" 工程效率 需求评审：需求评审机制以及更新通知，避免需求有改动而没有及时同步到相关角色。 代码质量：静态代码扫描，千行代码缺陷率等。 架构评审：代码架构的讨论以及评审。 Bug流程：Bug生命周期，避免随便修改Bug状态以及备注缺失。 Code Review：代码评审，如果有代码...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"测试","slug":"测试","count":1,"path":"api/tags/测试.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"block基本结构（一）","uid":"837320c05a767825bb487e2f2edb4766","slug":"Block底层实现原理","date":"2021-10-01T02:06:49.000Z","updated":"2021-10-01T12:38:32.094Z","comments":true,"path":"api/articles/Block底层实现原理.json","keywords":null,"cover":"https://static01.imgkr.com/temp/623564c792a84bd587a73355356d11f6.png","text":"block基本结构 block 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成 在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类 impl 是实际的指针函数、本例中，它指向 _main_block_fun...","link":"","photos":[],"count_time":{"symbolsCount":848,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"block","slug":"block","count":1,"path":"api/tags/block.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS设计模式（一）","uid":"69226c43fa619d7df7756bf099da8b7a","slug":"iOS设计模式（一）","date":"2021-09-30T12:30:53.000Z","updated":"2021-10-02T01:12:40.559Z","comments":true,"path":"api/articles/iOS设计模式（一）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"类继承和对象组合 类继承简单直接、关系在编译时静态定义 被复用的实现易于修改 缺点： 因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现 子类描述在父类、 子类直接面对父类的封装、因此破坏了封装 父类实现的任何变更都会强制爱子类到的变更 因为在新的问题场景下京城实...","link":"","photos":[],"count_time":{"symbolsCount":470,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"单元测试","uid":"78bacd8b33e55bbfb6a2cbf684cbf20b","slug":"unit-test","date":"2021-07-13T03:32:17.000Z","updated":"2021-12-08T05:19:27.357Z","comments":true,"path":"api/articles/unit-test.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"别测试代码，而应该验证程序的行为测试应该只在程序的行为和预期的不一样时，才不通过。测试应该测试程序的代码做了什么，而不是测试程序如何实现。 验证应用程序做了什么的，叫做行为测试。 即使应用程序的行为不发生变化，只要应用程序的代码发生了变化，测试就不通过的，叫做脆性测试。 假设我们...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"单元测试","slug":"单元测试","count":1,"path":"api/tags/单元测试.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS 组件化拆分总结","uid":"08c633a5de2fe3edfdf41cfdec1b1bae","slug":"iOS-component","date":"2021-06-11T08:05:51.000Z","updated":"2021-10-02T01:12:49.846Z","comments":true,"path":"api/articles/iOS-component.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"组件化一、为何要组件化? 这是我们在做组件化的时候要思考的，它的优点和缺点是什么，这样我们对组件化有个基本认识 1. 组件化定义 组件是由一个或多个类构成，能完整描述一个业务场景，并能被其他业务场景复用的功能单位。 比如内存，硬盘，CPU，显示器等，拿出其中任何一个部件都能被其他...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"组件化","slug":"组件化","count":1,"path":"api/tags/组件化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Xcode Server CI 持续集成","uid":"d68e4e31d1e8b7032dd88c62b8f9b3ca","slug":"Xcode-Server-CI-持续集成","date":"2021-06-10T07:58:03.000Z","updated":"2021-10-02T01:12:09.339Z","comments":true,"path":"api/articles/Xcode-Server-CI-持续集成.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"Xcode Server CI 持续集成一、 Xcode Server 基本概念 Xcode Server是配置在Mac端的一个服务器，服务器上我们可以创建Bot自动执行机器人 软件应用程序在本地（Xcode development Macs）开发过程中，会将代码不断合并到git...","link":"","photos":[],"count_time":{"symbolsCount":574,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"持续集成","slug":"持续集成","count":1,"path":"api/tags/持续集成.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"async 和 await 同步等待","uid":"549def405a2020c02b3886501c2d84f3","slug":"async-await","date":"2021-06-01T03:45:18.000Z","updated":"2021-10-02T01:13:12.765Z","comments":true,"path":"api/articles/async-await.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"Dart 获取相应数据操作 ","link":"","photos":[],"count_time":{"symbolsCount":22,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"抽象构造函数","uid":"6af98c5762fa00ab05498386038da6c3","slug":"abstractClass","date":"2021-06-01T02:16:37.000Z","updated":"2021-10-02T01:13:21.609Z","comments":true,"path":"api/articles/abstractClass.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"抽象类 abstract关键字修饰class 继承的方式使用 接口的方式使用 abstract class Message &#123; factory Message(String type) &#123; switch(type) &#123; case 'foot': re...","link":"","photos":[],"count_time":{"symbolsCount":825,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DartClass","uid":"3b284d7eb9880174f64e9bf09d231aff","slug":"DartClass","date":"2021-06-01T01:28:38.000Z","updated":"2021-12-08T07:43:07.394Z","comments":true,"path":"api/articles/DartClass.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"Dart 类相关的使用命名构造函数 Point.fromJSON(Map json) class Point &#123; num x; num y; Point(this.x, this.y); &#x2F;&#x2F; 命名构造函数（命名构造函数） Point.fromJSO...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"DartException","uid":"1117fb54e92a8351488adf129028b2a6","slug":"DartException","date":"2021-05-31T09:06:01.000Z","updated":"2021-12-08T05:14:32.595Z","comments":true,"path":"api/articles/DartException.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"Dart 异常处理操作![截屏2021-05-31 下午5.06.39](DartException/截屏2021-05-31 下午5.06.39.png) 延迟加载异常 DeferredLoadException 延迟加载异常 throw new FormateExceptio...","link":"","photos":[],"count_time":{"symbolsCount":505,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":4,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"应用性能分析方法","uid":"5c608ba3383f27b31f8830b3a9b5f6d6","slug":"应用性能分析方法","date":"2021-05-22T07:06:49.000Z","updated":"2021-10-02T01:13:27.687Z","comments":true,"path":"api/articles/应用性能分析方法.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"应用性能分析方法1. 采样顾名思义，采样(或基于探测点的性能分析)是指以一定的周期间隔采集状态，这通常需要借助工具。由于不会干扰应用的执行，因此采样可以很好地提供应用的全景图。采样的不足之处在于它不能返回 100% 精确的细节。如果采样的频率是 10 毫秒，那么你就无法得知在探测...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":2,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS性能优化指标","uid":"d6599ba5117b38d8d4d285c032bd712d","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","updated":"2021-10-02T01:12:36.233Z","comments":true,"path":"api/articles/iOS性能优化指标.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"性能指标 性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。 1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":2,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"iOS内存对齐","uid":"eafabc105702abbd3d554d5c51e703dd","slug":"Memory-alignment","date":"2021-05-03T00:55:06.000Z","updated":"2021-12-08T05:14:32.595Z","comments":true,"path":"api/articles/Memory-alignment.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"iOS中内存对齐数据对齐规则 结构体和联合体（union）的数据成员，第一个数据成员放到offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员子成员大小（只要该成员有子成员，比如说数组，结构体等）的整数倍开始（比如int为4自己接，则要从4的整数倍地址开始存...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Spring基础了解","uid":"a519dcebcf7b75aa7909ffb897e4913c","slug":"Spring-base","date":"2021-05-02T06:22:41.000Z","updated":"2021-10-02T01:12:18.857Z","comments":true,"path":"api/articles/Spring-base.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"Spring 简介​ Spring 是分层的 full-stack（全栈） 轻量级开源框架，以IoC和 AOP 为内核，提供了展现层Spring MVC和业务层事务管理等众多的企业级应⽤技术，还能整合开源世界众多著名的第三⽅框架和类库，已 经成为使⽤最多的Java EE企业应⽤开...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"动态SQL","uid":"83f1863d7d241c1d5ddb943bddf231fd","slug":"dynamicSQL","date":"2021-05-01T23:43:13.000Z","updated":"2021-10-02T01:12:55.195Z","comments":true,"path":"api/articles/dynamicSQL.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"动态sql语句**动态sql语句概述 ** Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动 态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 ","link":"","photos":[],"count_time":{"symbolsCount":119,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"alloc&init探究","uid":"20c5d0afd79142c4ce377e5e3d6eadea","slug":"alloc","date":"2021-05-01T09:45:39.000Z","updated":"2021-10-02T01:13:17.929Z","comments":true,"path":"api/articles/alloc.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"alloc 和 init 基本原理LGPerson *p &#x3D; [[LGPerson alloc] init]; LGPerson *p1 &#x3D; [p init]; &#x2F;&#x2F; objc_msgSend （id 消息接收者，sel 发送消息） LGP...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Mybatis对象关系映射","uid":"9d874e909a3a7a396d1451469b922294","slug":"Mybatis对象关系映射","date":"2021-04-29T12:12:40.000Z","updated":"2021-12-08T05:19:23.537Z","comments":true,"path":"api/articles/Mybatis对象关系映射.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"对象/关系数据库映射(ORM) ORM全称Object/Relation Mapping:表示对象-关系映射的缩写 ORM完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向 对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。ORM把...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"如何Category中增加属性","uid":"8d5bb184f1a8d1302f056982173a3dd0","slug":"如何Category中增加属性","date":"2021-04-29T11:17:24.000Z","updated":"2021-10-01T05:25:11.967Z","comments":true,"path":"api/articles/如何Category中增加属性.json","keywords":null,"cover":"https://images.xiaozhuanlan.com/photo/2019/0156fea8cc60760bdf6d2bd4229514d1.png","text":"如何在Category中增加属性（关联对象）在实际开发中，如果为Category添加一个属性，那么系统将不会为这个属性设置访问器方法，也就是setter和getter方法。这时候可以使用runtime提供的关联对象方法，动态地为该属性实现访问器方法。 开发者可以将关联对象想象成一...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"如何提高面试率.md","uid":"afb2b07e802409f4fec5da7128301e15","slug":"如何提高面试率","date":"2021-04-24T02:06:35.000Z","updated":"2021-10-02T01:11:55.214Z","comments":true,"path":"api/articles/如何提高面试率.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":" “成功者讲方法，失败者讲理由！”虽然是一句老掉牙的话，但却饱含人生哲理。面对越来越激烈的竞争局面，以及后续大批新人的涌入，我们不仅要埋头苦干，提升自己的专业技能，更需要学会一些面试技巧，因为这些技巧会让你的求职之路事半功倍，为你赢得更多可能性。 我的这些面试技巧分为，面试前准备...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"iOS","slug":"iOS","count":1,"path":"api/tags/iOS.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":0,"tags":0,"word_count":"122k","post_count":40}