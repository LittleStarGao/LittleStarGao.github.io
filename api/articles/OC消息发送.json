{"title":"OC消息发送","uid":"7d5af61f6682832ceaf909aad79a5565","slug":"OC消息发送","date":"2021-10-03T03:48:29.000Z","updated":"2021-10-03T04:02:14.462Z","comments":true,"path":"api/articles/OC消息发送.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","content":"<h3 id=\"消息的发送\"><a href=\"#消息的发送\" class=\"headerlink\" title=\"消息的发送\"></a>消息的发送</h3><p>ObjC中使用[Receiver message]方式来进行方法调用,本质其实就是向Receiver发送message消息.而message告诉这个Receiver要做什么</p>\n<ul>\n<li><strong>给nil发送消息</strong><br> 在ObjC中，给nil发送消息是合法的，但在运行时什么都不做，而发送给nil的消息带有返回值也是合法的。<br> ■ 如果一个方法返回一个对象、任何类型的指针、任何size小于或等于sizeof(void*)的类型，如float、 double、 long double、或者long long，那么给nil发送消息将返回0。<br> ■ 如果一个方法返回一个数据结构，那么将这个消息传递给nil将为这个数据结构的每个成员都返回0.0。<br> ■ 如果一个方法返回上述类型外的其它类型，那么将这个消息传递给nil，返回值为定义。</li>\n</ul>\n<p><strong>多态</strong>和<strong>动态绑定</strong></p>\n<ul>\n<li>函数和它的参数是在编译时绑定在一起</li>\n<li>消息和接收者直到程序运行时，消息被发送才实现这种绑定，<strong>响应一个消息体是在运行时才决定的</strong>，而不是在代码编译时候</li>\n<li>Message中的方法名是用来<strong>选择</strong> Receiver的Method实体,因此,Message中的方法名也被称为**(selector)**选择器.</li>\n</ul>\n<p><strong>方法和选取器</strong></p>\n<ul>\n<li>选取器确定的是<code>方法名</code>,不是方法的实现, 这是多态和<strong>动态绑定</strong>的基础.它使得向不同对象发送相同的消息成为现实.</li>\n</ul>\n<p><strong>方法返回值和参数类型:</strong></p>\n<ul>\n<li>消息机制是通过<strong>选取器</strong>找到方法的<strong>返回值类型和参数类型</strong>. 因此: <strong>动态绑定需要同名方法的实现 拥有相同返回值类型和相同的参数类型</strong>;否则,运行时可能出现找不到对应方法的错误.(有一个例外，虽然同名静态方法和实例方法拥有相同的选取器，但是它们可以有不同的参数类型和返回值类型。)</li>\n</ul>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">&#x2F;&#x2F; SEL和@selector区别:选择器的类型是SEL.而 @selector指示符是用来引用选择器的, 它返回类型是SEL.\n  SEL response;      \n  response &#x3D; @selector(load:)\n\n  &#x2F;&#x2F; 1. 通过字符串来得到选取器:\n  responseSEL &#x3D; NSSelectorFromString(@&quot;loadDataForTableView:&quot;);\n  &#x2F;&#x2F;  2 . 通过选择器转换来得到方法名: \n  NSString  *methodName &#x3D; NSStringFromSelector(responseSEL);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","text":"消息的发送ObjC中使用[Receiver message]方式来进行方法调用,本质其实就是向Receiver发送message消息.而message告诉这个Receiver要做什么 给nil发送消息 在ObjC中，给nil发送消息是合法的，但在运行时什么都不做，而发送给nil的...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81\"><span class=\"toc-text\">消息的发送</span></a></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"类对象具体操作方法","uid":"cf0e611562c137ce26a0fd876069298a","slug":"类对象具体操作方法","date":"2021-10-03T09:52:41.000Z","updated":"2021-10-03T09:53:22.429Z","comments":true,"path":"api/articles/类对象具体操作方法.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"类与对象操作函数runtime提供了大量的函数来直接操作类与对象数据结构，类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。 类相关操作函数我们可以回过头去看看objc_cla...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"类对象","slug":"类对象","count":1,"path":"api/tags/类对象.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"OC中的类","uid":"07b3470a92b5218af5f032e4b7c9894f","slug":"OC中的类","date":"2021-10-03T01:07:27.000Z","updated":"2021-10-03T03:45:15.921Z","comments":true,"path":"api/articles/OC中的类.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"OC中的类 编译器为每个类定义一个类对象(Class_object)。Class_object 是Class的编译版本，而它所构建的对象被称为类的实例 程序中真正做工作的是类在运行时对象创建的那些实例 一个类的所有实例有同一套方法，而且有相同一套实例变量 每个对象都有自己的实例变...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"OC类","slug":"OC类","count":1,"path":"api/tags/OC类.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}