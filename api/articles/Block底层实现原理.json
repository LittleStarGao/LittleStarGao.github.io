{"title":"block基本结构（一）","uid":"837320c05a767825bb487e2f2edb4766","slug":"Block底层实现原理","date":"2021-05-22T07:06:49.000Z","updated":"2021-10-01T12:16:04.684Z","comments":true,"path":"api/articles/Block底层实现原理.json","keywords":null,"cover":"https://static01.imgkr.com/temp/623564c792a84bd587a73355356d11f6.png","content":"<h4 id=\"block基本结构\"><a href=\"#block基本结构\" class=\"headerlink\" title=\"block基本结构\"></a>block基本结构</h4><ul>\n<li>block 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成</li>\n<li>在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类</li>\n<li>impl 是实际的指针函数、本例中，它指向 _main_block_func_0 这里面 _impl 相当于以前的invoke 变量</li>\n<li>descriptor 是描述这个block的附加信息，包括结构体大小、需要 capture 和 dispose 的变量列表等、结构体大小需要保存的原因</li>\n</ul>\n<img src=\"/post/Block%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/block.png\" class title=\"block\">\n\n\n\n<p>1，在MRC 时代，__block 修饰，可以避免循环引用；ARC时代，__block 修饰，同样会引起循环引用问题； </p>\n<p>2，__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型； __</p>\n<p>3，<strong>weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；</strong></p>\n<p> 4，__block对象可以在block中被重新赋值，__weak不可以； </p>\n<p>5，__unsafe_unretained修饰符可以被视为iOS SDK 4.3以前版本的__weak的替代品，不过不会被自动置空为nil。所以尽可能不要使用这个修饰符。(__weak 会自动置为nil)</p>\n<p><strong>_weak与__block区别</strong></p>\n<p>问到 block 避免循环引用的问题时，发现好多人都说通过添加 __block 修饰词来避免。再加上我对__block和__weak也没有区分的太明确，搞得我都有点儿怀疑我自己以前是不是用错了。正好借这个机会来一探究竟~</p>\n<p>首先我定义了一个类 MyObject 继承 NSObject，并添加了一个属性 text，重写了description方法，返回 text 的值。这个主要是因为编译器本身对 NSString 是有优化的，创建的 string 对象有可能是静态存储区永不释放的，为了避免使用 NSString 引起一些问题，还是创建一个 NSObject 对象比较合适。</p>\n","text":"block基本结构 block 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成 在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类 impl 是实际的指针函数、本例中，它指向 _main_block_fun...","link":"","photos":[],"count_time":{"symbolsCount":848,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"block","slug":"block","count":1,"path":"api/tags/block.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#block%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">block基本结构</span></a></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《腾讯iOS测试实践》学习（一）","uid":"72c9fa0d926f81572e4b5de9847c1152","slug":"《腾讯iOS测试实践》学习（一）","date":"2021-05-22T07:06:49.000Z","updated":"2021-10-01T09:40:20.073Z","comments":true,"path":"api/articles/《腾讯iOS测试实践》学习（一）.json","keywords":null,"cover":[],"text":" 工程效率 需求评审：需求评审机制以及更新通知，避免需求有改动而没有及时同步到相关角色。 代码质量：静态代码扫描，千行代码缺陷率等。 架构评审：代码架构的讨论以及评审。 Bug流程：Bug生命周期，避免随便修改Bug状态以及备注缺失。 Code Review：代码评审，如果有代码...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"测试","slug":"测试","count":1,"path":"api/tags/测试.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"iOS性能优化指标","uid":"d6599ba5117b38d8d4d285c032bd712d","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","updated":"2021-05-22T06:09:06.209Z","comments":true,"path":"api/articles/iOS性能优化指标.json","keywords":null,"cover":[],"text":"性能指标 性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。 1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":2,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}