{"title":"block基本结构（一）","uid":"837320c05a767825bb487e2f2edb4766","slug":"Block底层实现原理","date":"2021-10-01T07:06:49.000Z","updated":"2021-10-01T12:33:23.137Z","comments":true,"path":"api/articles/Block底层实现原理.json","keywords":null,"cover":"https://static01.imgkr.com/temp/623564c792a84bd587a73355356d11f6.png","content":"<h4 id=\"block基本结构\"><a href=\"#block基本结构\" class=\"headerlink\" title=\"block基本结构\"></a>block基本结构</h4><ul>\n<li>block 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成</li>\n<li>在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类</li>\n<li>impl 是实际的指针函数、本例中，它指向 _main_block_func_0 这里面 _impl 相当于以前的invoke 变量</li>\n<li>descriptor 是描述这个block的附加信息，包括结构体大小、需要 capture 和 dispose 的变量列表等、结构体大小需要保存的原因</li>\n</ul>\n<img src=\"/post/Block%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/block.png\" class title=\"block\">\n\n\n\n<p>1，在MRC 时代，__block 修饰，可以避免循环引用；ARC时代，__block 修饰，同样会引起循环引用问题； </p>\n<p>2，__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型； __</p>\n<p>3，<strong>weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；</strong></p>\n<p> 4，__block对象可以在block中被重新赋值，__weak不可以； </p>\n<p>5，__unsafe_unretained修饰符可以被视为iOS SDK 4.3以前版本的__weak的替代品，不过不会被自动置空为nil。所以尽可能不要使用这个修饰符。(__weak 会自动置为nil)</p>\n<p><strong>_weak与__block区别</strong></p>\n<p>问到 block 避免循环引用的问题时，发现好多人都说通过添加 __block 修饰词来避免。再加上我对__block和__weak也没有区分的太明确，搞得我都有点儿怀疑我自己以前是不是用错了。正好借这个机会来一探究竟~</p>\n<p>首先我定义了一个类 MyObject 继承 NSObject，并添加了一个属性 text，重写了description方法，返回 text 的值。这个主要是因为编译器本身对 NSString 是有优化的，创建的 string 对象有可能是静态存储区永不释放的，为了避免使用 NSString 引起一些问题，还是创建一个 NSObject 对象比较合适。</p>\n","feature":true,"text":"block基本结构 block 实际是一个对象、主要是有一个 isa、一个 impl和一个descriptor 组成 在开启ARC时候、block 应该是 _NSConcreteGlobalBlock 类 impl 是实际的指针函数、本例中，它指向 _main_block_fun...","link":"","photos":[],"count_time":{"symbolsCount":848,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"block","slug":"block","count":1,"path":"api/tags/block.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#block%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">block基本结构</span></a></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"iOS UIView和CALayer关系","uid":"386fc4bc5a18ec12e9fe740e6fc9c9ef","slug":"iOS-UIView和CALayer关系","date":"2021-10-01T12:27:26.000Z","updated":"2021-10-01T12:32:08.102Z","comments":true,"path":"api/articles/iOS-UIView和CALayer关系.json","keywords":null,"cover":"https://images.xiaozhuanlan.com/photo/2019/0156fea8cc60760bdf6d2bd4229514d1.png","text":"一、UIView 和 CALayer 探究 所有的UIView都有CALayer 驱动、view 和 Layer 紧密关系，view从layer 中获取所需要所有数据、layer 侧重图形表示，view 相当于layer管理者 ","link":"","photos":[],"count_time":{"symbolsCount":122,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIView","slug":"UIView","count":1,"path":"api/tags/UIView.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"iOS设计模式（一）","uid":"69226c43fa619d7df7756bf099da8b7a","slug":"iOS设计模式（一）","date":"2021-09-30T12:30:53.000Z","updated":"2021-10-01T01:00:07.655Z","comments":true,"path":"api/articles/iOS设计模式（一）.json","keywords":null,"cover":[],"text":"类继承和对象组合 类继承简单直接、硬卧关系在编译静态定义 被复用的实现易于修改 缺点： 因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现 子类描述在父类、 子类直接面对父类的封装、因此破坏了封装 父类实现的任何变更都会强制爱子类到的变更 因为在新的问题场景下京城...","link":"","photos":[],"count_time":{"symbolsCount":471,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}