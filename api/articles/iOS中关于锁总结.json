{"title":"iOS中关于锁总结","uid":"5aeaa1caf03061ebea03dd5070710347","slug":"iOS中关于锁总结","date":"2021-10-03T09:58:28.000Z","updated":"2021-10-03T09:59:13.418Z","comments":true,"path":"api/articles/iOS中关于锁总结.json","keywords":null,"cover":null,"content":"<p><strong>7、自旋锁</strong></p>\n<p>何谓自旋锁？<strong>它是为实现保护共享资源而提出一种锁机制</strong>。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，<strong>如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁</strong>，”自旋”一词就是因此而得名。</p>\n<p><strong>7.1 OSSpinLock</strong></p>\n<ul>\n<li>使用方式</li>\n</ul>\n<p>// 初始化 spinLock = OS_SPINKLOCK_INIT; // 加锁 OSSpinLockLock(&amp;spinLock); // 解锁 OSSpinLockUnlock(&amp;spinLock);复制代码</p>\n<p>然而，<a href=\"https://github.com/ibireme/YYKit\">YYKit</a>作者的文章<a href=\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/?utm_source=tuicool&utm_medium=referral\">不再安全的 OSSpinLock</a>有说到这个自旋锁存在优先级反转的问题。</p>\n<p><strong>7.2 os_unfair_lock</strong></p>\n<ul>\n<li>自旋锁已经不再安全，然后苹果又整出来个 os_unfair_lock_t ,这个锁解决了优先级反转的问题。</li>\n</ul>\n<p>​    os_unfair_lock_t unfairLock;    unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);    os_unfair_lock_lock(unfairLock);    os_unfair_lock_unlock(unfairLock);</p>\n<p><strong>8、atomic(property) set / get</strong></p>\n<p>利用set / get 接口的属性实现原子操作，进而确保“被共享”的变量在多线程中读写安全，这已经是不能满足部分多线程同步要求。</p>\n<ul>\n<li>在定义 property 的时候， 有atomic 和 nonatomic的属性修饰关键字。</li>\n<li>对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。</li>\n<li>而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。</li>\n</ul>\n<p>-</p>\n<p><a href=\"https://stackoverflow.com/users/1405155/raw3d\">raw3d</a></p>\n<p>Atomic</p>\n<ul>\n<li>是默认的</li>\n<li>会保证 CPU 能在别的线程来访问这个属性之前，先执行完当前流程</li>\n<li>速度不快，因为要保证操作整体完成</li>\n</ul>\n<p>Non-Atomic</p>\n<ul>\n<li>不是默认的</li>\n<li>更快</li>\n<li>线程不安全</li>\n<li>如有两个线程访问同一个属性，会出现无法预料的结果</li>\n</ul>\n<p>-</p>\n<p><a href=\"https://stackoverflow.com/users/661217/vijayendra-tripathi\">Vijayendra Tripathi</a></p>\n<ul>\n<li><p>假设有一个 atomic 的属性 “name”，如果线程 A 调[self setName:@”A”]`，线程 B 调[self setName:@”B”]，线程 C 调[self name]``，那么所有这些不同线程上的操作都将依次顺序执行——也就是说，如果一个线程正在执行 getter/setter，其他线程就得等待。因此，属性 name 是读/写安全的。</p>\n</li>\n<li><p>但是，如果有另一个线程 D 同时在调[name release]，那可能就会crash，因为 release 不受 getter/setter 操作的限制。也就是说，这个属性只能说是读/写安全的，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。</p>\n</li>\n<li><p>如果 name 属性是 nonatomic 的，那么上面例子里的所有线程 A、B、C、D 都可以同时执行，可能导致无法预料的结果。如果是 atomic 的，那么 A、B、C 会串行，而 D 还是并行的。</p>\n</li>\n</ul>\n<p>-</p>\n<ul>\n<li>简单来说，就是atomic会加一个锁来保障线程安全，并且引用计数会+1，来向调用者保证这个对象会一直存在。假如不这样做，如果另一个线程调setter，可能会出现线程竞态，导致引用计数降到0，原来那个对象就是否了。</li>\n</ul>\n","feature":true,"text":"7、自旋锁 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"类对象具体操作方法","uid":"cf0e611562c137ce26a0fd876069298a","slug":"类对象具体操作方法","date":"2021-10-03T09:52:41.000Z","updated":"2021-10-03T09:53:22.429Z","comments":true,"path":"api/articles/类对象具体操作方法.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"类与对象操作函数runtime提供了大量的函数来直接操作类与对象数据结构，类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。 类相关操作函数我们可以回过头去看看objc_cla...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"类对象","slug":"类对象","count":1,"path":"api/tags/类对象.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}