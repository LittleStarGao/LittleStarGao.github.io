{"title":"Runloop探究总结（一）","uid":"024b1a5a8576bdfa18efbc793fd20736","slug":"Runloop探究总结（一）","date":"2021-10-03T00:34:38.000Z","updated":"2021-10-03T00:35:24.320Z","comments":true,"path":"api/articles/Runloop探究总结（一）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","content":"<h4 id=\"RunLoop-是什么？\"><a href=\"#RunLoop-是什么？\" class=\"headerlink\" title=\"RunLoop 是什么？\"></a>RunLoop 是什么？</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Runloop是通过内部维护一个事件循环来对事件、消息进行管理的一个对象。是的，它是一个对象。 大家用C语言过main函数的都知道，main函数运行完成后程序就结束退出了。但是为什么iOS的App的main函数运行完之后APP还能一直运行呢？这就是Runloop的功劳。 </p></blockquote>\n<h6 id=\"Runloop最基本的应用就是iOS的main函数：\"><a href=\"#Runloop最基本的应用就是iOS的main函数：\" class=\"headerlink\" title=\"Runloop最基本的应用就是iOS的main函数：\"></a>Runloop最基本的应用就是iOS的main函数：</h6><pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">@</span>autoreleasepool <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">UIApplicationMain</span><span class=\"token punctuation\">(</span>argc<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>AppDelegate class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"Runloop-基本方法\"><a href=\"#Runloop-基本方法\" class=\"headerlink\" title=\"Runloop 基本方法\"></a>Runloop 基本方法</h5><ol>\n<li>Runloop是个对象,获取当前线程的runLoop</li>\n</ol>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>NSRunloop currentRunLoop<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n<ol start=\"2\">\n<li>获得主线程的Runloop对象</li>\n</ol>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>NSRunLoop mainRunLoop<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>获得当前线程的RunLoop对象 </p>\n<h4 id=\"Core-Foundation-中获取RunLoop-方法\"><a href=\"#Core-Foundation-中获取RunLoop-方法\" class=\"headerlink\" title=\"Core Foundation 中获取RunLoop 方法\"></a>Core Foundation 中获取RunLoop 方法</h4><ol>\n<li>获得当前线程的RunLoop对象<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">CFRunLoopGetCurrent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li>获得主线程的Runloop对象</li>\n</ol>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">CFRunLoopGetMain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h5 id=\"RunLoop的实现机制\"><a href=\"#RunLoop的实现机制\" class=\"headerlink\" title=\"RunLoop的实现机制\"></a>RunLoop的实现机制</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了方便Runloop机制的理解，下面写一段<code>伪代码</code>来表示一下RunLoop循环。</p></blockquote>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">function <span class=\"token function\">runloop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">initialize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n        var message <span class=\"token operator\">=</span> <span class=\"token function\">get_next_message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//从队列获取消息</span>\n        <span class=\"token function\">process_message</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//处理消息</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>message <span class=\"token operator\">!=</span> quite<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//当触发quite条件时，Runloop退出</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"从上面的源代码可以看出Runloop的处理机制是\"><a href=\"#从上面的源代码可以看出Runloop的处理机制是\" class=\"headerlink\" title=\"从上面的源代码可以看出Runloop的处理机制是\"></a>从上面的源代码可以看出Runloop的处理机制是</h6><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quite 的消息）。 </p></blockquote>\n<h6 id=\"RunLoop的核心是什么？\"><a href=\"#RunLoop的核心是什么？\" class=\"headerlink\" title=\"RunLoop的核心是什么？\"></a>RunLoop的核心是什么？</h6><ul>\n<li><p>在没有消息处理时休眠，在有消息时又能唤醒。这样可以提高CPU资源使用效率 当然RunLoop它不是简单的while循环，不是用sleep来休眠，毕竟sleep这方法也是会占用cpu资源的。</p>\n</li>\n<li><p>那它是如何实现真正的休眠的呢？那就是：<code>没有消息需要处理时，就会从用户态切换到内核态，用户态进入内核态后，把当前线程控制器交给内核态，这样的休眠线程是被挂起的，不会再占用cpu资源。</code></p>\n</li>\n</ul>\n<ul>\n<li>这里要注意用户态和内核态 这两个概念，还有<code>mach_msg()</code>方法。 内核态 这个机制是依靠系统内核来完成的(苹果操作系统核心组件 Darwin 中的 Mach )。</li>\n</ul>\n<h6 id=\"RunLoop的实现\"><a href=\"#RunLoop的实现\" class=\"headerlink\" title=\"RunLoop的实现\"></a>RunLoop的实现</h6><p>整个流程：</p>\n<ol>\n<li>根据modeName 找到对应的mode</li>\n</ol>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">CFRunLoopModeRef currentMode <span class=\"token operator\">=</span> <span class=\"token function\">__CFRunLoopFindMode</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> modeName<span class=\"token punctuation\">,</span> false<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>如果mode里面source/timer/observer 直接返回</li>\n</ol>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__CFRunLoopModeIsEmpty</span><span class=\"token punctuation\">(</span>currentMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ol start=\"3\">\n<li>通知 Observers: RunLoop 即将进入 loop。</li>\n</ol>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopEntry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ol start=\"4\">\n<li>内部函数进入RunLoop进入相应的操作</li>\n</ol>\n<ul>\n<li><p>内部函数处理流程分析</p>\n<ul>\n<li><ol>\n<li>通知 Observers: RunLoop 即将触发 Timer 回调。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">通知 Observers<span class=\"token punctuation\">:</span> RunLoop 即将触发 Timer 回调。\n<span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopBeforeTimers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li><ol start=\"2\">\n<li>通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">通知 Observers<span class=\"token punctuation\">:</span> RunLoop 即将触发 Timer 回调。\n<span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopBeforeTimers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li><ol start=\"3\">\n<li>执行被加入的block</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\">// 执行被加入的block</span>\n<span class=\"token function\">__CFRunLoopDoBlocks</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li><ol start=\"4\">\n<li>RunLoop 触发 Source0 (非port) 回调。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">sourceHandledThisLoop <span class=\"token operator\">=</span> <span class=\"token function\">__CFRunLoopDoSources0</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> stopAfterHandle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li><ol start=\"5\">\n<li> 执行被加入的block</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">_CFRunLoopDoBlocks</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li><ol start=\"6\">\n<li> 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__Source0DidDispatchPortLastTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    Boolean hasMsg <span class=\"token operator\">=</span> <span class=\"token function\">__CFRunLoopServiceMachPort</span><span class=\"token punctuation\">(</span>dispatchPort<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>msg<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hasMsg<span class=\"token punctuation\">)</span> <span class=\"token keyword\">goto</span> handle_msg<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><ol start=\"7\">\n<li> 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">通知 Observers<span class=\"token punctuation\">:</span> RunLoop 的线程即将进入休眠<span class=\"token punctuation\">(</span>sleep<span class=\"token punctuation\">)</span>。\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>sourceHandledThisLoop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopBeforeWaiting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><ol start=\"8\">\n<li>调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">  \n• 一个基于 port 的Source 的事件。\n• 一个 Timer 到时间了\n• RunLoop 自身的超时时间到了\n• 被其他什么调用者手动唤醒\n<span class=\"token function\">__CFRunLoopServiceMachPort</span><span class=\"token punctuation\">(</span>waitSet<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>msg_buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>livePort<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">mach_msg</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> MACH_RCV_MSG<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// thread wait for receive msg</span>\n<span class=\"token punctuation\">&#125;</span>\n            <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><ol start=\"9\">\n<li>通知 Observers: RunLoop 的线程刚刚被唤醒了。</li>\n</ol>\n</li>\n</ul>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopAfterWaiting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/// 收到消息，处理消息。</span>\nhandle_msg<span class=\"token operator\">:</span>\n<span class=\"token number\">9.1</span> 如果一个 Timer 到时间了，触发这个Timer的回调。\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg_is_timer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">__CFRunLoopDoTimers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> <span class=\"token function\">mach_absolute_time</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg_is_dispatch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n   如果有dispatch到main_queue的block，执行block。\n    <span class=\"token function\">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token comment\">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h5 id=\"整体源代码\"><a href=\"#整体源代码\" class=\"headerlink\" title=\"整体源代码\"></a>整体源代码</h5><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">\n<span class=\"token keyword\">int</span> <span class=\"token function\">CFRunLoopRunSpecific</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> modeName<span class=\"token punctuation\">,</span> seconds<span class=\"token punctuation\">,</span> stopAfterHandle<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token comment\">// 首先根据modeName找到对应mode</span>\n    CFRunLoopModeRef currentMode <span class=\"token operator\">=</span> <span class=\"token function\">__CFRunLoopFindMode</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> modeName<span class=\"token punctuation\">,</span> false<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/// 如果mode里没有source/timer/observer, 直接返回。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__CFRunLoopModeIsEmpty</span><span class=\"token punctuation\">(</span>currentMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 通知 Observers: RunLoop 即将进入 loop。</span>\n    <span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopEntry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/// 内部函数，进入loop</span>\n    <span class=\"token function\">__CFRunLoopRun</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> seconds<span class=\"token punctuation\">,</span> returnAfterSourceHandled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n        Boolean sourceHandledThisLoop <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> retVal <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n\n            <span class=\"token comment\">/// 2\\. 通知 Observers: RunLoop 即将触发 Timer 回调。</span>\n            <span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopBeforeTimers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">/// 3\\. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span>\n            <span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopBeforeSources<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">/// 执行被加入的block</span>\n            <span class=\"token function\">__CFRunLoopDoBlocks</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">/// 4\\. RunLoop 触发 Source0 (非port) 回调。</span>\n            sourceHandledThisLoop <span class=\"token operator\">=</span> <span class=\"token function\">__CFRunLoopDoSources0</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> stopAfterHandle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">/// 执行被加入的block</span>\n            <span class=\"token function\">__CFRunLoopDoBlocks</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">/// 5\\. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__Source0DidDispatchPortLastTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                Boolean hasMsg <span class=\"token operator\">=</span> <span class=\"token function\">__CFRunLoopServiceMachPort</span><span class=\"token punctuation\">(</span>dispatchPort<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>msg<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hasMsg<span class=\"token punctuation\">)</span> <span class=\"token keyword\">goto</span> handle_msg<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token comment\">///6\\. 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>sourceHandledThisLoop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopBeforeWaiting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token comment\">/// 7\\. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span>\n            <span class=\"token comment\">/// • 一个基于 port 的Source 的事件。</span>\n            <span class=\"token comment\">/// • 一个 Timer 到时间了</span>\n            <span class=\"token comment\">/// • RunLoop 自身的超时时间到了</span>\n            <span class=\"token comment\">/// • 被其他什么调用者手动唤醒</span>\n            <span class=\"token function\">__CFRunLoopServiceMachPort</span><span class=\"token punctuation\">(</span>waitSet<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>msg_buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>livePort<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">mach_msg</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> MACH_RCV_MSG<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// thread wait for receive msg</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token comment\">/// 8\\. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span>\n            <span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopAfterWaiting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">/// 收到消息，处理消息。</span>\n            handle_msg<span class=\"token operator\">:</span>\n\n            <span class=\"token comment\">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg_is_timer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">__CFRunLoopDoTimers</span><span class=\"token punctuation\">(</span>runloop<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> <span class=\"token function\">mach_absolute_time</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#125;</span> \n\n            <span class=\"token comment\">/// 9.2 如果有dispatch到main_queue的block，执行block。</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg_is_dispatch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> \n\n            <span class=\"token comment\">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>retVal <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">// 通知 Observers: RunLoop 即将退出。</span>\n    <span class=\"token function\">__CFRunLoopDoObservers</span><span class=\"token punctuation\">(</span>rl<span class=\"token punctuation\">,</span> currentMode<span class=\"token punctuation\">,</span> kCFRunLoopExit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>   <strong><code>看源码里的注释，可以了解个Runloop运行的流程。 咱们还是围绕RunLoop的核心来理解， 既然上面提到休眠是通过内核来完成的，那唤醒条件呢？ </code></strong></p>\n<h5 id=\"下面几个就是主要的唤醒Runloop的事件：\"><a href=\"#下面几个就是主要的唤醒Runloop的事件：\" class=\"headerlink\" title=\"下面几个就是主要的唤醒Runloop的事件：\"></a>下面几个就是主要的唤醒Runloop的事件：</h5><ol>\n<li>收到基于 port 的 Source1 的事件</li>\n<li>Timer到时间执行</li>\n<li>RunLoop自身的超时时间到了</li>\n<li>被其他调用者手动唤醒</li>\n</ol>\n<h6 id=\"关于RunLoop的source1和source0\"><a href=\"#关于RunLoop的source1和source0\" class=\"headerlink\" title=\"关于RunLoop的source1和source0\"></a>关于RunLoop的source1和source0</h6><p>上面介绍了source1包括系统事件捕捉和基于port的线程间通信。</p>\n<h6 id=\"什么是系统事件捕捉？又如何理解基于port的线程间通信？\"><a href=\"#什么是系统事件捕捉？又如何理解基于port的线程间通信？\" class=\"headerlink\" title=\"什么是系统事件捕捉？又如何理解基于port的线程间通信？\"></a>什么是系统事件捕捉？又如何理解基于port的线程间通信？</h6><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们手指点击屏幕，首先产生的是一个系统事件，通过<code>source1来接受捕捉</code>，然后由<code>Springboard程</code>序包装成<code>source0</code>分发给应用去处理，因此我们在App内部接受到触摸事件，就是source0，这一前一后的关系。source1 通过程序包装是会变成 source0的</p></blockquote>\n<h6 id=\"RunLoop的有几种Mode-RunLoop设置Mode作用是什么？\"><a href=\"#RunLoop的有几种Mode-RunLoop设置Mode作用是什么？\" class=\"headerlink\" title=\"RunLoop的有几种Mode, RunLoop设置Mode作用是什么？\"></a>RunLoop的有几种Mode, RunLoop设置Mode作用是什么？</h6><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>RunLoop的运行模式共有5种，RunLoop只会运行在一个模式下，要切换模式，就要暂停当前模式，重新启动一个运行模式</p></blockquote>\n<ol>\n<li>kCFRunLoopDefaultMode, App的默认运行模式，通常主线程是在这个运行模式下运行</li>\n<li>UITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>\n<li>kCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式</li>\n<li>UIInitializationRunLoopMode：在刚启动App时进入的第一个Mode，启动完成后就不再使用</li>\n<li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li>\n</ol>\n<p>**RunLoop设置Mode作用 **</p>\n<p>  设置Mode作用是指定事件在<code>运行循环（Loop）中的优先级</code>。 线程的运行需要不同的模式，去响应各种不同的事件，去处理不同情境模式。(比如可以优化tableview的时候可以设置UITrackingRunLoopMode下不进行一些操作)</p>\n<p><strong>为什么只有主线程的Runloop是自动开启的？</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>看iOS的main函数代码， 代码自动生成了autoreleasepool，这里就是调用了runloop。app启动时main函数就自动开启了主线程的runloop。</p></blockquote>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">@</span>autoreleasepool <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">UIApplicationMain</span><span class=\"token punctuation\">(</span>argc<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>AppDelegate class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>PerformSelector:afterDelay:这个方法在子线程中是否起作用?为什么?怎么解决?<br>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。<br>UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动TableView的Cell时，label是否刷新？为什么？<br>不刷新了。 因为NSTimer对象是以NSDefaultRunLoopMode添加到主运行循环中的时候, TableView（ScrollView）滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。如果希望在滚动时，定时器也能运行，那就应该使用common mode。 通过 CFRunloopAddTimer(runloop,timer ,commonMode) 实现。就是同步把事件源timer用同一个mode.<br>AFNetworking 中如何运用 Runloop?<br>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>\n<ul>\n<li><p>(void)networkRequestThreadEntryPoint:(id)__unused object {<br>  @autoreleasepool {</p>\n<pre><code>  [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];\n  NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n  [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n  [runLoop run];\n</code></pre>\n<p>  }<br>  }</p>\n</li>\n<li><p>(NSThread *)networkRequestThread {<br>  static NSThread *_networkRequestThread = nil;<br>  static dispatch_once_t oncePredicate;<br>  dispatch_once(&amp;oncePredicate, ^{</p>\n<pre><code>  _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n  [_networkRequestThread start];\n</code></pre>\n<p>  });<br>  return _networkRequestThread;<br>  }</p>\n</li>\n</ul>\n<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>\n<ul>\n<li>(void)start {<br>  [self.lock lock];<br>  if ([self isCancelled]) {<pre><code>  [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n</code></pre>\n  } else if ([self isReady]) {<pre><code>  self.state = AFOperationExecutingState;\n  [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n</code></pre>\n  }<br>  [self.lock unlock];<br>  }<br>  当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。<br>  解释一下Runloop在 NSTimer中的的作用<br>  NSTimer 其实就是 CFRunLoopTimerRef，这两个类之间，是可以交换使用的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，在发生阻塞状态并不会准时回调给Timer。某个时间点被错过了，不会在延期时间后给你执行。比如等公交，如果10:10 有一趟公交，我没赶上，那我只能等 10:20 这一趟。10:10分那趟不会再回来的。<br>  Runloop 和线程的关系？<br>  Runloop 和是一对一的关系，一个线程对应一个 Runloop。主线程的默认就有了 Runloop。 可以通过数据结构看出来，创建线程时，线程默认是没有runloop的，需要手工创建线程的runloop。<br>  有了线程，你觉得为什么还要有runloop？<br>  Runloop最主要的作用 就是它如何在没有消息处理时休眠，在有消息时又能唤醒。这样可以提高CPU资源使用效率 。runloop 另外一个作用是消息处理。只有线程，是做不到这点的。<br>  GCD 在Runloop中的使用？<br>  GCD由子线程返回到主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。<br>  AFNetworking 中如何运用 Runloop?<br>  AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</li>\n</ul>\n<ul>\n<li><p>(void)networkRequestThreadEntryPoint:(id)__unused object {<br>  @autoreleasepool {</p>\n<pre><code>  [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];\n  NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n  [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n  [runLoop run];\n</code></pre>\n<p>  }<br>  }</p>\n</li>\n<li><p>(NSThread *)networkRequestThread {<br>  static NSThread *_networkRequestThread = nil;<br>  static dispatch_once_t oncePredicate;<br>  dispatch_once(&amp;oncePredicate, ^{</p>\n<pre><code>  _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n  [_networkRequestThread start];\n</code></pre>\n<p>  });<br>  return _networkRequestThread;<br>  }</p>\n</li>\n</ul>\n<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>\n<ul>\n<li>(void)start {<br>  [self.lock lock];<br>  if ([self isCancelled]) {<pre><code>  [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n</code></pre>\n  } else if ([self isReady]) {<pre><code>  self.state = AFOperationExecutingState;\n  [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n</code></pre>\n  }<br>  [self.lock unlock];<br>  }</li>\n</ul>\n<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。<br>PerformSelector:afterDelay:这个方法在子线程中是否起作用？<br>不起作用，子线程默认没有 Runloop。 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。可以使用 GCD的dispatch_after来实现afterDelay这样的需求。<br>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效，<br>CADispalyTimer和Timer哪个更精确<br>当然是CADisplayLink 更精确。<br>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。<br>看上面Runloop在 NSTimer中的使用的问题，就知道NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。可见 NSTimer的定时是很不靠谱的。<br>CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。</p>\n","feature":true,"text":"RunLoop 是什么？ Runloop是通过内部维护一个事件循环来对事件、消息进行管理的一个对象。是的，它是一个对象。 大家用C语言过main函数的都知道，main函数运行完成后程序就结束退出了。但是为什么iOS的App的main函数运行完之后APP还能一直运行呢？这就是Run...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#RunLoop-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">RunLoop 是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Runloop%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%BA%94%E7%94%A8%E5%B0%B1%E6%98%AFiOS%E7%9A%84main%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">Runloop最基本的应用就是iOS的main函数：</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Runloop-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Runloop 基本方法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Core-Foundation-%E4%B8%AD%E8%8E%B7%E5%8F%96RunLoop-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Core Foundation 中获取RunLoop 方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#RunLoop%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">RunLoop的实现机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BARunloop%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%98%AF\"><span class=\"toc-text\">从上面的源代码可以看出Runloop的处理机制是</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#RunLoop%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">RunLoop的核心是什么？</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#RunLoop%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">RunLoop的实现</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B4%E4%BD%93%E6%BA%90%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">整体源代码</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E5%B0%B1%E6%98%AF%E4%B8%BB%E8%A6%81%E7%9A%84%E5%94%A4%E9%86%92Runloop%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">下面几个就是主要的唤醒Runloop的事件：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8ERunLoop%E7%9A%84source1%E5%92%8Csource0\"><span class=\"toc-text\">关于RunLoop的source1和source0</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89%EF%BC%9F%E5%8F%88%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9F%BA%E4%BA%8Eport%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F\"><span class=\"toc-text\">什么是系统事件捕捉？又如何理解基于port的线程间通信？</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#RunLoop%E7%9A%84%E6%9C%89%E5%87%A0%E7%A7%8DMode-RunLoop%E8%AE%BE%E7%BD%AEMode%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">RunLoop的有几种Mode, RunLoop设置Mode作用是什么？</span></a></li></ol></li></ol></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"OC中的类","uid":"07b3470a92b5218af5f032e4b7c9894f","slug":"OC中的类","date":"2021-10-03T01:07:27.000Z","updated":"2021-10-03T03:29:46.501Z","comments":true,"path":"api/articles/OC中的类.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"OC中的类 编译器为每个类定义一个类对象(Class_object)。Class_object 是Class的编译版本，而它所构建的对象被称为类的实例 程序中真正做工作的是类在运行时对象创建的那些实例 一个类的所有实例有同一套方法，而且有相同一套实例变量 每个对象都有自己的实例变...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"OC类","slug":"OC类","count":1,"path":"api/tags/OC类.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"OC 对象的本质","uid":"888e58a89b2f989fb3e2e1a0413d4445","slug":"OC-对象的本质","date":"2021-10-02T11:30:44.000Z","updated":"2021-10-03T00:35:17.467Z","comments":true,"path":"api/articles/OC-对象的本质.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"OC对象的本质 OC中类和对象都是基于C和C++的结构体实现的; OC中的对象分为三种：实例对象、类对象、元类对象 实例对象内存分批 OC 基类为NSObject，实例对象只有一个成员变量 isa typedef struct objc_class *Class; struct ...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}