{"title":"iOS 组件化拆分总结","uid":"08c633a5de2fe3edfdf41cfdec1b1bae","slug":"iOS-component","date":"2021-06-11T08:05:51.000Z","updated":"2021-06-18T07:36:33.579Z","comments":true,"path":"api/articles/iOS-component.json","keywords":null,"cover":[],"content":"<h3 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h3><h4 id=\"一、为何要组件化\"><a href=\"#一、为何要组件化\" class=\"headerlink\" title=\"一、为何要组件化?\"></a>一、为何要组件化?</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这是我们在做组件化的时候要思考的，它的优点和缺点是什么，这样我们对组件化有个基本认识</p></blockquote>\n<h5 id=\"1-组件化定义\"><a href=\"#1-组件化定义\" class=\"headerlink\" title=\"1. 组件化定义\"></a>1. 组件化定义</h5><ul>\n<li>组件是由一个或多个类构成，能完整描述一个业务场景，并能被其他业务场景复用的功能单位。</li>\n<li>比如内存，硬盘，CPU，显示器等，拿出其中任何一个部件都能被其他的PC所使用。</li>\n<li>日志服务，VOIP服务，内存管理服务等等。说白了我们目标是站在更高的维度去封装功能单元。对这些功能单元进行进一步的分类，才能在具体的业务场景下做更合理的设计。</li>\n</ul>\n<h5 id=\"2-组件化实施条件\"><a href=\"#2-组件化实施条件\" class=\"headerlink\" title=\"2. 组件化实施条件\"></a>2. <strong>组件化实施条件</strong></h5><ul>\n<li>前期项目比较小，可以按照原有传统的方式进行开发</li>\n<li>随着项目的功能变的复杂，团队扩大，会发现传统的开发方式导致代码管理混乱，发布、集成、测试越来越麻烦，被迫走向组件化的道路</li>\n<li>如果你的团队在不断发展，产品线也越来越多的时候，预计后期可能会更多的时候，那么最好尽早把组件化拆分</li>\n<li>把一些业务、基础功能剥离，划分为一个个的模块，然后通过pods的方式管理而已，同时要搭配一套后台的自动集成、发布、测试流程</li>\n</ul>\n<h5 id=\"3-普通模式存在问题\"><a href=\"#3-普通模式存在问题\" class=\"headerlink\" title=\"3. 普通模式存在问题\"></a>3. 普通模式存在问题</h5><ul>\n<li>代码冲突多，编译慢。</li>\n<li>迭代速度慢，耦合比较严重，无法单独测试。</li>\n</ul>\n<h5 id=\"4-组件化优点\"><a href=\"#4-组件化优点\" class=\"headerlink\" title=\"4. 组件化优点\"></a>4. 组件化优点</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>组件化就是把整个项目进行拆分，分成一个个单独的可独立运行的组件，分开管理，减少依赖。</p></blockquote>\n<ul>\n<li><p>加快编译速度，可以把不会经常变动的组件做成静态库，同时每个组件可以独立编译，不依赖于主工程或者其他组件</p>\n</li>\n<li><p>每个组件都可以选择自己擅长的开发模式（MVC / MVVM / MVP）</p>\n</li>\n<li><p>可以单独测试每个组件</p>\n</li>\n<li><p>多条业务线可以并行开发，提高开发效率</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>组件化方案在App业务稳定，且规模（业务规模和开发团队规模）增长初期去实施非常重要，它助于将复杂App分而治之，也有助于多人大型团队的协同开发。但组件化方案不适合在业务不稳定的情况下过早实施，至少要等产品已经经过MVP阶段时才适合实施组件化。因为业务不稳定意味着链路不稳定，在不稳定的链路上实施组件化会导致将来主业务产生变化时，全局性模块调度和重构会变得相对复杂。</p></blockquote>\n<h6 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h6><ul>\n<li>业务稳定的模块先进行组件化，业务在变化的随着业务稳定之后再做抽离组件化</li>\n</ul>\n<h4 id=\"组件化方案\"><a href=\"#组件化方案\" class=\"headerlink\" title=\"组件化方案\"></a>组件化方案</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 看上去各家都是各显神通，都有自己的技术方案，但是实际上都可以归类到如下两种方案：</p></blockquote>\n<ul>\n<li>利用runtime实现的target-action方法</li>\n<li>利用url-scheme方案</li>\n</ul>\n<p><strong>URL-Scheme库：</strong></p>\n<ol>\n<li><a href=\"https://github.com/joeldev/JLRoutes\">JLRoutes</a></li>\n<li><a href=\"https://github.com/clayallsopp/routable-ios\">routable-ios</a></li>\n<li><a href=\"https://github.com/lightory/HHRouter\">HHRouter</a></li>\n<li><a href=\"https://github.com/mogujie/MGJRouter\">MGJRouter</a></li>\n<li><a href=\"https://github.com/douban/FRDIntent\">FRDIntent/Intent</a></li>\n</ol>\n<p><strong>Target-Action库：</strong></p>\n<ol>\n<li><a href=\"https://github.com/casatwy/CTMediator\">CTMediator</a></li>\n</ol>\n<h4 id=\"路由的设计思路\"><a href=\"#路由的设计思路\" class=\"headerlink\" title=\"路由的设计思路\"></a>路由的设计思路</h4><ul>\n<li>URL-Sheme方案一般都是各个组件把自己可以提供的服务通过url的形式注册到一个中心管理器，然后调用发就可以通过openURL的方式来打开这个url，然后中心管理器解析这个url，把请求转发到相应的组件去执行</li>\n<li>Target-Action方案利用了OC的runtime特性，无需注册，直接在原有的组件之外加一层<code>wrapper</code>，把对外提供的服务都抽离到该层。然后通过runtime的TARGET<code> performSelector:ACTION withObject:PARAMS</code>找到对应的组件，执行方法和传递参数。</li>\n</ul>\n<h3 id=\"实施步骤\"><a href=\"#实施步骤\" class=\"headerlink\" title=\"实施步骤\"></a>实施步骤</h3><ul>\n<li>模块化是一个浩大的工程，对于项目有着重大影响。我们在确定目标之后，接着制定了有一个详细的计划。然后按计划一步步实施。</li>\n<li>第一个要解决的问题就是如何拆分组件。这是一个见仁见智的问题，没有太明确的划分边界，大致做到每个组件只包含一个功能即可，具体实施还是要根据实际情况权衡。</li>\n<li>站在更高的维度去封装功能单元，把多个功能单元组合在一起形成一个更大的功能单元，也就是组件。对这些功能单元进行进一步的分类，才能在具体的业务场景下做更合理的设计。</li>\n</ul>\n<p><strong>1. 文件夹隔离</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 我们首先需要改变项目的文件组织结构</p></blockquote>\n<ul>\n<li><p>项目简单地以 View / Controller / Model 划分各类文件。</p>\n</li>\n<li><p>现在改为每个功能模块都有自己如下模块文件夹，从而先实现文件夹隔离</p>\n<ul>\n<li>View </li>\n<li>Controller</li>\n<li>ViewModel</li>\n<li>Model</li>\n<li>Network </li>\n</ul>\n</li>\n<li><p>虽然改为按模块组织项目的文件结构，但此时，所有模块仍然还在一个仓库里。这其实只是做到了文件夹隔离，代码并没有被真正隔离</p>\n</li>\n<li><p>我们会查看各个文件的 #import 部分，减少业务模块间的相互依赖。几个业务模块都用到的文件，则会沉入到<code>公共层</code></p>\n</li>\n<li><p>文件夹隔离也为团队提供了一个转变开发方式的缓冲期</p>\n</li>\n<li><p>文件夹隔离使得组员逐步适应模块化的思维，后续的产品功能也被归入到对应的模块之中</p>\n</li>\n</ul>\n<p><strong>2. 抽象出业务无关的库</strong></p>\n<p>我们同时也鼓励将一些业务无关的代码抽象成一个个独立的库。这类库应该是与产品无关，与业务无关的。</p>\n<ul>\n<li>拆分出去的模块，必须先处理好它的依赖，它将<code>只能依赖已经拆分出去的组件和第三方库</code>。</li>\n<li>拆分独立的库使得复用成为了可能，我们可以在新项目中使用</li>\n</ul>\n<p><strong>3.  拆分公共模块</strong></p>\n<ul>\n<li>包括了业务模块所需要的一些公共代码，但是要么是和业务关系较大，要么就是还没到可以抽象成一个库的程度</li>\n<li>我们开始按由容易到困难的顺序拆分各个业务模块</li>\n</ul>\n<p><strong>4.  页面跳转解耦</strong></p>\n<ul>\n<li>豆瓣开源方案： FRDIntent/Intent  <code>https://github.com/douban/FRDIntent</code></li>\n<li> 我们开始按由容易到困难的顺序拆分各个业务模块</li>\n</ul>\n<p><strong>5.  FRDIntent/Intent 有如下优势：</strong></p>\n<ul>\n<li>充分解耦。调用者和被调用者完全隔离，调用者只需要依赖协议：FRDIntentReceivable。一个 UIViewControlller 符合该协议即可被启动。</li>\n<li>对于“启动一个页面，并从该页面获取结果”这种较普遍的需求提供了一个通用的解决方案。具体查看方法：startControllerForResult。这是对 Android 中 startActivityForResult 的模仿和简化。</li>\n<li>支持自定义转场动画。</li>\n<li>支持传递复杂数据对象。</li>\n</ul>\n<hr>\n<h4 id=\"组件化方案-1\"><a href=\"#组件化方案-1\" class=\"headerlink\" title=\"组件化方案\"></a>组件化方案</h4><p>主要是基于Mediator模式和Target-Action模式，中间采用了runtime来完成调用。这套组件化方案将远程应用调用和本地应用调用做了拆分，而且是由本地应用调用为远程应用调用提供服务，与蘑菇街方案正好相反。</p>\n<h5 id=\"本地调用\"><a href=\"#本地调用\" class=\"headerlink\" title=\"本地调用\"></a>本地调用</h5><ul>\n<li><code>[[CTMediator sharedInstance] performTarget:targetName action:actionName params:@&#123;...&#125;]</code>向<code>CTMediator</code>发起跨组件调用，<code>CTMediator</code>根据获得的target和action信息，通过objective-C的runtime转化生成target实例以及对应的action选择子，然后最终调用到目标业务提供的逻辑，完成需求。</li>\n</ul>\n<h5 id=\"远程调用\"><a href=\"#远程调用\" class=\"headerlink\" title=\"远程调用\"></a>远程调用</h5><ul>\n<li><code>AppDelegate</code>接收到URL之后，调用<code>CTMediator</code>的<code>openUrl:</code>方法将接收到的URL信息传入。当然，<code>CTMediator</code>也可以用<code>openUrl:options:</code>的方式顺便把随之而来的option也接收，这取决于你本地业务执行逻辑时的充要条件是否包含option数据。传入URL之后，<code>CTMediator</code>通过解析URL，将请求路由到对应的target和action</li>\n</ul>\n<h4 id=\"组件间调用方式\"><a href=\"#组件间调用方式\" class=\"headerlink\" title=\"组件间调用方式\"></a>组件间调用方式</h4><p>所有组件都通过组件自带的Target-Action来响应，也就是说，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。</p>\n<h5 id=\"组件参数传递\"><a href=\"#组件参数传递\" class=\"headerlink\" title=\"组件参数传递\"></a>组件参数传递</h5><ul>\n<li><code>非常规参数</code>是包含非常规类型的参数。</li>\n<li><code>非常规类型</code>的定义就是不能被json解析的类型都叫非常规类型。</li>\n</ul>\n<h4 id=\"本地组件间调用来支持远程应用调用\"><a href=\"#本地组件间调用来支持远程应用调用\" class=\"headerlink\" title=\"本地组件间调用来支持远程应用调用\"></a>本地组件间调用来支持远程应用调用</h4><ul>\n<li>通过<code>performTarget:action:params:</code>是能够提供非常规参数的，于是我们可以知道，<code>远程App调用</code>时的上下文环境以及功能<code>是本地组件间调用</code>时上下文环境以及功能<code>的子集</code>。</li>\n<li>远程App调用只能走<code>CTMediator</code>提供的专用远程的方法，本地组件间调用只能走<code>CTMediator</code>提供的专用本地的方法，两者不能通过同一个接口来调用。</li>\n</ul>\n<h4 id=\"组件化去Model\"><a href=\"#组件化去Model\" class=\"headerlink\" title=\"组件化去Model\"></a>组件化去Model</h4><ul>\n<li><p>组件间调用时，是需要针对参数做去model化的。如果组件间调用不对参数做去model化的设计，就会导致<code>业务形式上被组件化了，实质上依然没有被独立</code>。</p>\n</li>\n<li><p>假设模块A和模块B之间采用model化的方案去调用，那么调用方法时传递的参数就会是一个<code>对象</code>。</p>\n</li>\n</ul>\n<p><strong>使用对象化的参数无论是否面向接口，带来的结果就是业务模块形式上是被组件化了，但实质上依然没有被独立。</strong></p>\n<h4 id=\"跨模块调用\"><a href=\"#跨模块调用\" class=\"headerlink\" title=\"跨模块调用\"></a>跨模块调用</h4><ul>\n<li>以字典的方式去传递。这样就能够做到只有调用方依赖mediator，而响应方不需要依赖mediator</li>\n<li>在去model的组件化方案中，影响效率的点有两个：调用方如何知道接收方需要哪些key的参数？调用方如何知道有哪些target可以被调用？其实后面的那个问题不管是不是去model的方案，都会遇到。</li>\n<li>为什么放在一起说，因为我接下来要说的解决方案可以把这两个问题一起解决。</li>\n</ul>\n<h5 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通mediator这个repo维护了若干个针对mediator的category，每一个对应一个target，每个category里的方法对应了这个target下所有可能的调用场景，这样调用者在包含mediator的时候，自动获得了所有可用的target-action，无论是调用还是参数传递，都非常方便。接下来我要解释一下为什么是category而不是其他：</p></blockquote>\n<ul>\n<li>category本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用category封装是很合理的。</li>\n<li>在category的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category就提供了补救的入口。</li>\n<li>category可以很轻松地做请求转发，如果不采用category，请求转发逻辑就非常难做了。</li>\n<li>category统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。</li>\n<li>由于category统一了所有的调用入口，使得在跨模块调用时，对于param的hardcode在整个App中的作用域仅存在于category中，在这种场景下的hardcode就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。</li>\n</ul>\n<img src=\"/post/iOS-component/component-one.png\" class title=\"component-one\">\n\n\n\n<h4 id=\"项目组件化拆分\"><a href=\"#项目组件化拆分\" class=\"headerlink\" title=\"项目组件化拆分\"></a>项目组件化拆分</h4><h4 id=\"传统项目结构\"><a href=\"#传统项目结构\" class=\"headerlink\" title=\"传统项目结构\"></a>传统项目结构</h4><img src=\"/post/iOS-component/%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F.png\" class title=\"传统模式\">\n\n\n\n<h4 id=\"截屏2021-06-18-下午2-46-07-iOS-component-截屏2021-06-18-下午2-46-07-png\"><a href=\"#截屏2021-06-18-下午2-46-07-iOS-component-截屏2021-06-18-下午2-46-07-png\" class=\"headerlink\" title=\"![截屏2021-06-18 下午2.46.07](iOS-component/截屏2021-06-18 下午2.46.07.png)\"></a>![截屏2021-06-18 下午2.46.07](iOS-component/截屏2021-06-18 下午2.46.07.png)</h4><p><img src=\"/post/../../../Desktop/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png\" alt=\"依赖关系\"></p>\n<p>![截屏2021-06-18 上午10.40.36](iOS-component/截屏2021-06-18 上午10.40.36.png)</p>\n<ul>\n<li></li>\n</ul>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">@interface A_VC : UIViewController\n  \n  -(void)action_A:(NSString*)para1;\n\n@end\n       \nimport &quot;A_VC.h&quot;\n@implementation A_VC\n\n-(void)action_A:(NSString*)para1 &#123;\n  NSLog(@&quot;call action_A %@&quot;,para1);\n&#125;\n       \n@end\n       \n \n@interface B_VC : UIViewController\n       \n  -(void)action_B:(NSString*)para1 para2:(NSInteger)para2;\n       \n@end\n       \n            \nimport &quot;B_VC.h&quot;     \n@implementation B_VC\n\n-(void)action_B:(NSString*)para1 para2:(NSInteger)para2&#123;\n        NSLog(@&quot;call action_B %@---%zd&quot;,para1,para2);\n&#125;\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">@interface Mediator : NSObject\n-(void)A_VC_Action:(NSString*)para1;\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2;\n+ (instancetype)sharedInstance;\n\n@end\n\nimport &quot;Mediator.h&quot;\n\n@implementation Mediator\n\n+ (instancetype)sharedInstance &#123;\n\tstatic Mediator *mediator;\n  static dispatch_once_t onceToken;\n  dispatch_once(&amp;onceToken, ^&#123;\n    mediator &#x3D; [[Mediator alloc] init];\n  &#125;);\n  return mediator;\n&#125;\n\n-(void)A_VC_Action:(NSString*)para1 &#123;\n  Class cls &#x3D; NSClassFromString(@&quot;A_VC&quot;);\n  NSObject *target &#x3D; [[cls alloc] init];\n  [target performSelector: NSSelectorFromString(@&quot;action_A:&quot;) withObject:para1];\n&#125;\n\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2&#123;\n  Class cls &#x3D; NSClassFromString(@&quot;B_VC&quot;);\n  NSObject *target &#x3D; [[cls alloc] init];\n  [target performSelector: NSSelectorFromString(@&quot;action_B:para2:&quot;) withObject: para1 withObject: para2];\n&#125;\n\n@end\n       <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"组件之间调用\"><a href=\"#组件之间调用\" class=\"headerlink\" title=\"组件之间调用\"></a>组件之间调用</h5><pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">&gt; B 调用 A \n[[Mediator sharedInstance] A_VC_Action:@&quot;参数1&quot; ];\n&gt;  A 调用 B\n[[Mediator sharedInstance] B_VC_Action:@&quot;参数1&quot; para2: 123];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>反思</strong></p>\n<p>看到这里，大概有人会问，既然用runtime就可以解耦取消依赖，那还要Mediator做什么？我直接在每个组件里面用runtime调用其他组件不就完了吗，干嘛还要多一个mediator？</p>\n<p>但是这样做会存在如下问题：</p>\n<ol>\n<li>调用者写起来很恶心，代码提示都没有， 参数传递非常恶心，每次调用者都要查看文档搞清楚每个参数的key是什么，然后自己去组装成一个 NSDictionary。维护这个文档和每次都要组装参数字典很麻烦。</li>\n<li>当调用的组件不存在的时候，没法进行统一处理</li>\n</ol>\n<p>那么加一个mediator的话，就可以做到：</p>\n<ol>\n<li>调用者写起来不恶心，代码提示也有了, 参数类型明确。</li>\n<li>Mediator可以做统一处理，调用某个组件方法时如果某个组件不存在，可以做相应操作，让调用者与组件间没有耦合。</li>\n</ol>\n<p><strong>改进</strong></p>\n<p>聪明的读者可能已经发现上面的mediator方案还是存在一个小瑕疵，受限于performselector方法，最多只能传递两个参数，如果我想传递多个参数怎么办呢？</p>\n<p>答案是使用字典进行传递，此时我们还需要个组件增加一层wrapper，把对外提供的业务全部包装一次，并且接口的参数全部改成字典。 假设我们现在的B组件需要接受多个参数，如下所示：</p>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">-(void)action_B:(NSString*)para para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    NSLog(@&quot;call action_B %@---%zd---%zd----%zd&quot;,para1,para2,para3,para4);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"那么此时需要对B组件增加一层wrapper，如下：\"><a href=\"#那么此时需要对B组件增加一层wrapper，如下：\" class=\"headerlink\" title=\"那么此时需要对B组件增加一层wrapper，如下：\"></a>那么此时需要对B组件增加一层wrapper，如下：</h5><pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">#import @interface target_B : NSObject\n-(void)B_Action:(NSDictionary*)para;\n\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n#import &quot;target_B.h&quot;\n#import &quot;B_VC.h&quot;\n\n@implementation target_B\n\n-(void)B_Action:(NSDictionary*)para&#123;\n    NSString *para1 &#x3D; para[@&quot;para1&quot;];\n    NSInteger para2 &#x3D; [para[@&quot;para2&quot;]integerValue];\n    NSInteger para3 &#x3D; [para[@&quot;para3&quot;]integerValue];\n    NSInteger para4 &#x3D; [para[@&quot;para4&quot;]integerValue];\n    B_VC *VC &#x3D; [B_VC new];\n    [VC action_B:para1 para2:para2 para3:para3 para4:para4];\n&#125;\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"此时mediator也需要做相应的更改，由原来直接调用组件B，改成了调用B的wrapper层：\"><a href=\"#此时mediator也需要做相应的更改，由原来直接调用组件B，改成了调用B的wrapper层：\" class=\"headerlink\" title=\"此时mediator也需要做相应的更改，由原来直接调用组件B，改成了调用B的wrapper层：\"></a>此时mediator也需要做相应的更改，由原来直接调用组件B，改成了调用B的wrapper层：</h4><pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    Class cls &#x3D; NSClassFromString(@&quot;target_B&quot;);\n    NSObject *target &#x3D; [[cls alloc]init];\n    [target performSelector:NSSelectorFromString(@&quot;B_Action:&quot;) withObject:@&#123;@&quot;para1&quot;:para1, @&quot;para2&quot;:@(para2),@&quot;para3&quot;:@(para3),@&quot;para4&quot;:@(para4)&#125; ];\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<img src=\"/post/iOS-component/1523957680726157.png\" class width=\"1523957680726157\">\n\n<img src=\"/post/iOS-component/1523957680759931.png\" class width=\"1523957680759931\">\n\n<p><strong>继续改进</strong></p>\n<p>做到这里，看似比较接近我的要求了，但是还有有点小瑕疵：</p>\n<ol>\n<li>Mediator 每一个方法里都要写 runtime 方法，格式是确定的，这是可以抽取出来的。</li>\n<li>每个组件对外方法都要在 Mediator 写一遍，组件一多 Mediator 类的长度是恐怖的。</li>\n</ol>\n<p>接着优化就是casa的方案了，我们来看看如何改进，直接看代码：</p>\n<p>针对第一点，我们可以抽出公共代码，当做mediator：</p>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">#import &quot;CTMediator.h&quot;\n#import @interface CTMediator ()\n\n@property (nonatomic, strong) NSMutableDictionary *cachedTarget;\n\n@end\n\n@implementation CTMediator\n\n#pragma mark - public methods\n+ (instancetype)sharedInstance\n&#123;\n    static CTMediator *mediator;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        mediator &#x3D; [[CTMediator alloc] init];\n    &#125;);\n    return mediator;\n&#125;\n\n&#x2F;*\n scheme:&#x2F;&#x2F;[target]&#x2F;[action]?[params]\n\n url sample:\n aaa:&#x2F;&#x2F;targetA&#x2F;actionB?id&#x3D;1234\n *&#x2F;\n\n- (id)performActionWithUrl:(NSURL *)url completion:(void (^)(NSDictionary *))completion\n&#123;\n    NSMutableDictionary *params &#x3D; [[NSMutableDictionary alloc] init];\n    NSString *urlString &#x3D; [url query];\n    for (NSString *param in [urlString componentsSeparatedByString:@&quot;&amp;&quot;]) &#123;\n        NSArray *elts &#x3D; [param componentsSeparatedByString:@&quot;&#x3D;&quot;];\n        if([elts count] &lt; 2) continue;\n        [params setObject:[elts lastObject] forKey:[elts firstObject]];\n    &#125;\n\n    &#x2F;&#x2F; 这里这么写主要是出于安全考虑，防止黑客通过远程方式调用本地模块。这里的做法足以应对绝大多数场景，如果要求更加严苛，也可以做更加复杂的安全逻辑。\n    NSString *actionName &#x3D; [url.path stringByReplacingOccurrencesOfString:@&quot;&#x2F;&quot; withString:@&quot;&quot;];\n    if ([actionName hasPrefix:@&quot;native&quot;]) &#123;\n        return @(NO);\n    &#125;\n\n    &#x2F;&#x2F; 这个demo针对URL的路由处理非常简单，就只是取对应的target名字和method名字，但这已经足以应对绝大部份需求。如果需要拓展，可以在这个方法调用之前加入完整的路由逻辑\n    id result &#x3D; [self performTarget:url.host action:actionName params:params shouldCacheTarget:NO];\n    if (completion) &#123;\n        if (result) &#123;\n            completion(@&#123;@&quot;result&quot;:result&#125;);\n        &#125; else &#123;\n            completion(nil);\n        &#125;\n    &#125;\n    return result;\n&#125;\n\n- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget\n&#123;\n\n    NSString *targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];\n    NSString *actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];\n    Class targetClass;\n\n    NSObject *target &#x3D; self.cachedTarget[targetClassString];\n    if (target &#x3D;&#x3D; nil) &#123;\n        targetClass &#x3D; NSClassFromString(targetClassString);\n        target &#x3D; [[targetClass alloc] init];\n    &#125;\n\n    SEL action &#x3D; NSSelectorFromString(actionString);\n\n    if (target &#x3D;&#x3D; nil) &#123;\n        &#x2F;&#x2F; 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的\n        return nil;\n    &#125;\n\n    if (shouldCacheTarget) &#123;\n        self.cachedTarget[targetClassString] &#x3D; target;\n    &#125;\n\n    if ([target respondsToSelector:action]) &#123;\n        return [self safePerformAction:action target:target params:params];\n    &#125; else &#123;\n        &#x2F;&#x2F; 有可能target是Swift对象\n        actionString &#x3D; [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName];\n        action &#x3D; NSSelectorFromString(actionString);\n        if ([target respondsToSelector:action]) &#123;\n            return [self safePerformAction:action target:target params:params];\n        &#125; else &#123;\n            &#x2F;&#x2F; 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理\n            SEL action &#x3D; NSSelectorFromString(@&quot;notFound:&quot;);\n            if ([target respondsToSelector:action]) &#123;\n                return [self safePerformAction:action target:target params:params];\n            &#125; else &#123;\n                &#x2F;&#x2F; 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。\n                [self.cachedTarget removeObjectForKey:targetClassString];\n                return nil;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n- (void)releaseCachedTargetWithTargetName:(NSString *)targetName\n&#123;\n    NSString *targetClassString &#x3D; [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];\n    [self.cachedTarget removeObjectForKey:targetClassString];\n&#125;\n\n#pragma mark - private methods\n- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params\n&#123;\n    NSMethodSignature* methodSig &#x3D; [target methodSignatureForSelector:action];\n    if(methodSig &#x3D;&#x3D; nil) &#123;\n        return nil;\n    &#125;\n    const char* retType &#x3D; [methodSig methodReturnType];\n\n    if (strcmp(retType, @encode(void)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        return nil;\n    &#125;\n\n    if (strcmp(retType, @encode(NSInteger)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        NSInteger result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(BOOL)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        BOOL result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(CGFloat)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        CGFloat result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n    if (strcmp(retType, @encode(NSUInteger)) &#x3D;&#x3D; 0) &#123;\n        NSInvocation *invocation &#x3D; [NSInvocation invocationWithMethodSignature:methodSig];\n        [invocation setArgument:¶ms atIndex:2];\n        [invocation setSelector:action];\n        [invocation setTarget:target];\n        [invocation invoke];\n        NSUInteger result &#x3D; 0;\n        [invocation getReturnValue:&amp;result];\n        return @(result);\n    &#125;\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;\n    return [target performSelector:action withObject:params];\n#pragma clang diagnostic pop\n&#125;\n\n#pragma mark - getters and setters\n- (NSMutableDictionary *)cachedTarget\n&#123;\n    if (_cachedTarget &#x3D;&#x3D; nil) &#123;\n        _cachedTarget &#x3D; [[NSMutableDictionary alloc] init];\n    &#125;\n    return _cachedTarget;\n&#125;\n\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>针对第二点，我们通过把每个组件的对外接口进行分离，剥离到多个mediator的category里面，感官上把本来在一个mediator里面实现的对外接口分离到多个category里面，方便管理</p>\n<p>下面展示的是个组件B添加的category，组件A类似</p>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">#import &quot;CTMediator.h&quot;\n\n@interface CTMediator (B_VC_Action)\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4;\n\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n#import &quot;CTMediator+B_VC_Action.h&quot;\n\n@implementation CTMediator (B_VC_Action)\n-(void)B_VC_Action:(NSString*)para1 para2:(NSInteger)para2 para3:(NSInteger)para3 para4:(NSInteger)para4&#123;\n    [self performTarget:@&quot;target_B&quot; action:@&quot;B_Action&quot; params:@&#123;@&quot;para1&quot;:para1, @&quot;para2&quot;:@(para2),@&quot;para3&quot;:@(para3),@&quot;para4&quot;:@(para4)&#125; shouldCacheTarget:YES];\n&#125;\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时调用者只要引入该<code>category</code>，然后调用即可，调用逻辑其实和上面没有拆分出<code>category</code>是一样的。此时的项目结构如下：</p>\n<img src=\"/post/iOS-component/1523957680557063.png\" class title=\"img\">\n\n<p><strong>URL-Scheme方案</strong></p>\n<p>这个方案是流传最广的，也是最多人使用的，因为Apple本身也提供了url-scheme功能，同时web端也是通过URL的方式进行路由跳转，那么很自然的iOS端就借鉴了该方案。</p>\n<p><strong>如何实现</strong></p>\n<p><strong>Router实现代码</strong></p>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">#import typedef void (^componentBlock) (NSDictionary *param);\n\n@interface URL_Roueter : NSObject\n+ (instancetype)sharedInstance;\n- (void)registerURLPattern:(NSString *)urlPattern toHandler:(componentBlock)blk;\n- (void)openURL:(NSString *)url withParam:(id)param;\n@end\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n\n#import &quot;URL_Roueter.h&quot;\n\n@interface URL_Roueter()\n@property (nonatomic, strong) NSMutableDictionary *cache;\n@end\n\n\n@implementation URL_Roueter\n\n+ (instancetype)sharedInstance\n&#123;\n    static URL_Roueter *router;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^&#123;\n        router &#x3D; [[URL_Roueter alloc] init];\n    &#125;);\n    return router;\n&#125;\n\n\n\n-(NSMutableDictionary *)cache&#123;\n    if (!_cache) &#123;\n        _cache &#x3D; [NSMutableDictionary new];\n    &#125;\n    return _cache;\n&#125;\n\n\n- (void)registerURLPattern:(NSString *)urlPattern toHandler:(componentBlock)blk &#123;\n    [self.cache setObject:blk forKey:urlPattern];\n&#125;\n\n- (void)openURL:(NSString *)url withParam:(id)param &#123;\n    componentBlock blk &#x3D; [self.cache objectForKey:url];\n    if (blk) blk(param);\n&#125;\n\n\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"组件A\"><a href=\"#组件A\" class=\"headerlink\" title=\"组件A\"></a>组件A</h4><pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">#import &quot;A_VC.h&quot;\n#import &quot;URL_Roueter.h&quot;\n\n@implementation A_VC\n\n&#x2F;&#x2F;把自己对外提供的服务(block)用url标记，注册到路由管理中心组件\n+(void)load&#123;\n    [[URL_Roueter sharedInstance]registerURLPattern:@&quot;test:&#x2F;&#x2F;A_Action&quot; toHandler:^(NSDictionary* para) &#123;\n        NSString *para1 &#x3D; para[@&quot;para1&quot;];\n        [[self new] action_A:para1];\n    &#125;];\n&#125;\n\n\n-(void)viewDidLoad&#123;\n    [super viewDidLoad];\n    UIButton *btn &#x3D; [UIButton new];\n    [btn setTitle:@&quot;调用组件B&quot; forState:UIControlStateNormal];\n    btn.frame &#x3D; CGRectMake(100, 100, 100, 50);\n    [btn addTarget:self action:@selector(btn_click) forControlEvents:UIControlEventTouchUpInside];\n    [btn setBackgroundColor:[UIColor redColor]];\n\n    self.view.backgroundColor &#x3D; [UIColor blueColor];\n    [self.view addSubview:btn];\n\n&#125;\n\n&#x2F;&#x2F;调用组件B的功能\n-(void)btn_click&#123;\n    [[URL_Roueter sharedInstance] openURL:@&quot;test:&#x2F;&#x2F;B_Action&quot; withParam:@&#123;@&quot;para1&quot;:@&quot;PARA1&quot;, @&quot;para2&quot;:@(222),@&quot;para3&quot;:@(333),@&quot;para4&quot;:@(444)&#125;];\n&#125;\n\n\n-(void)action_A:(NSString*)para1 &#123;\n    NSLog(@&quot;call action_A: %@&quot;,para1);\n&#125;\n\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从上面的代码可以看出来，实现原理很简单：每个组件在自己的load方面里面，把自己对外提供的服务(回调block)通过url-scheme标记好，然后注册到URL-Router里面。</p>\n<p><strong>URL-Router接受各个组件的注册，用字典保存了每个组件注册过来的url和对应的服务，只要其他组件调用了openURL方法，就会去这个字典里面根据url找到对应的block执行(也就是执行其他组件提供的服务)</strong></p>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><ul>\n<li><p><strong>需要专门的管理后台维护</strong></p>\n<ul>\n<li>要提供一个文档专门记录每个url和服务的对应表，每次组件改动了都要即使修改，很麻烦。参数的格式不明确，是个灵活的 dictionary，同样需要维护一份文档去查这些参数。</li>\n</ul>\n</li>\n<li><p><strong>内存问题</strong></p>\n<p>每个组件在初始化的时候都需要要路由管理中心去注册自己提供的服务，内存里需要保存一份表，组件多了会有内存问题。</p>\n</li>\n<li><p><strong>混淆了本地调用和远程调用</strong></p>\n<ul>\n<li>url-scheme是Apple拿来做app之间跳转的，或者通过url方式打开APP，但是上述的方案去把他拿来做本地组件间的跳转，这会产生问题，大概分为两点：</li>\n</ul>\n</li>\n<li><p>远程调用和本地调用的处理逻辑是不同的，正确的做法应该是把远程调用通过一个中间层转化为本地调用，如果把两者两者混为一谈，后期可能会出现无法区分业务的情况。比如对于组件无法响应的问题，远程调用可能直接显示一个404页面，但是本地调用可能需要做其他处理。如果不加以区分，那么久无法完成这种业务要求。</p>\n</li>\n<li><p>远程调用只能传能被序列化为json的数据，像 UIImage这样非常规的对象是不行的。所以如果组件接口要考虑远程调用，这里的参数就不能是这类非常规对象，接口的定义就受限了。出现这种情况的原因就是，远程调用是本地调用的子集，这里混在一起导致组件只能提供子集功能(远程调用)，所以这个方案是天生有缺陷的</p>\n</li>\n<li><p>理论上来讲，组件化是接口层面的东西，应该用语言自身的特性去解决，而url是用于远程通信的，不应该和组件化扯上关系</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h4 id=\"链家完整组件化实例\"><a href=\"#链家完整组件化实例\" class=\"headerlink\" title=\"链家完整组件化实例\"></a>链家完整组件化实例</h4>","text":"组件化一、为何要组件化? 这是我们在做组件化的时候要思考的，它的优点和缺点是什么，这样我们对组件化有个基本认识 1. 组件化定义 组件是由一个或多个类构成，能完整描述一个业务场景，并能被其他业务场景复用的功能单位。 比如内存，硬盘，CPU，显示器等，拿出其中任何一个部件都能被其他...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"组件化","slug":"组件化","count":1,"path":"api/tags/组件化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%8C%96\"><span class=\"toc-text\">组件化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BD%95%E8%A6%81%E7%BB%84%E4%BB%B6%E5%8C%96\"><span class=\"toc-text\">一、为何要组件化?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1. 组件化定义</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E6%96%BD%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">2. 组件化实施条件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3. 普通模式存在问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">4. 组件化优点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">组件化方案</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">路由的设计思路</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%96%BD%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">实施步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88-1\"><span class=\"toc-text\">组件化方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">本地调用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">远程调用</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E9%97%B4%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">组件间调用方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">组件参数传递</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E9%97%B4%E8%B0%83%E7%94%A8%E6%9D%A5%E6%94%AF%E6%8C%81%E8%BF%9C%E7%A8%8B%E5%BA%94%E7%94%A8%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">本地组件间调用来支持远程应用调用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8E%BBModel\"><span class=\"toc-text\">组件化去Model</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">跨模块调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8B%86%E5%88%86\"><span class=\"toc-text\">项目组件化拆分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">传统项目结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%AA%E5%B1%8F2021-06-18-%E4%B8%8B%E5%8D%882-46-07-iOS-component-%E6%88%AA%E5%B1%8F2021-06-18-%E4%B8%8B%E5%8D%882-46-07-png\"><span class=\"toc-text\">![截屏2021-06-18 下午2.46.07](iOS-component&#x2F;截屏2021-06-18 下午2.46.07.png)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">组件之间调用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%82%A3%E4%B9%88%E6%AD%A4%E6%97%B6%E9%9C%80%E8%A6%81%E5%AF%B9B%E7%BB%84%E4%BB%B6%E5%A2%9E%E5%8A%A0%E4%B8%80%E5%B1%82wrapper%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">那么此时需要对B组件增加一层wrapper，如下：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A4%E6%97%B6mediator%E4%B9%9F%E9%9C%80%E8%A6%81%E5%81%9A%E7%9B%B8%E5%BA%94%E7%9A%84%E6%9B%B4%E6%94%B9%EF%BC%8C%E7%94%B1%E5%8E%9F%E6%9D%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6B%EF%BC%8C%E6%94%B9%E6%88%90%E4%BA%86%E8%B0%83%E7%94%A8B%E7%9A%84wrapper%E5%B1%82%EF%BC%9A\"><span class=\"toc-text\">此时mediator也需要做相应的更改，由原来直接调用组件B，改成了调用B的wrapper层：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6A\"><span class=\"toc-text\">组件A</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">存在的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%93%BE%E5%AE%B6%E5%AE%8C%E6%95%B4%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">链家完整组件化实例</span></a></li></ol></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"单元测试","uid":"78bacd8b33e55bbfb6a2cbf684cbf20b","slug":"unit-test","date":"2021-07-13T03:32:17.000Z","updated":"2021-07-14T07:45:20.214Z","comments":true,"path":"api/articles/unit-test.json","keywords":null,"cover":null,"text":"别测试代码，而应该验证程序的行为测试应该只在程序的行为和预期的不一样时，才不通过。测试应该测试程序的代码做了什么，而不是测试程序如何实现。 验证应用程序做了什么的，叫做行为测试。 即使应用程序的行为不发生变化，只要应用程序的代码发生了变化，测试就不通过的，叫做脆性测试。 假设我们...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"单元测试","slug":"单元测试","count":1,"path":"api/tags/单元测试.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Xcode Server CI 持续集成","uid":"d68e4e31d1e8b7032dd88c62b8f9b3ca","slug":"Xcode-Server-CI-持续集成","date":"2021-06-10T07:58:03.000Z","updated":"2021-06-10T10:09:07.497Z","comments":true,"path":"api/articles/Xcode-Server-CI-持续集成.json","keywords":null,"cover":[],"text":"Xcode Server CI 持续集成一、 Xcode Server 基本概念 Xcode Server是配置在Mac端的一个服务器，服务器上我们可以创建Bot自动执行机器人 软件应用程序在本地（Xcode development Macs）开发过程中，会将代码不断合并到git...","link":"","photos":[],"count_time":{"symbolsCount":574,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"持续集成","slug":"持续集成","count":1,"path":"api/tags/持续集成.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}