{"title":"OC 对象的本质","uid":"888e58a89b2f989fb3e2e1a0413d4445","slug":"OC-对象的本质","date":"2021-10-02T11:30:44.000Z","updated":"2021-10-03T09:52:16.337Z","comments":true,"path":"api/articles/OC-对象的本质.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","content":"<h2 id=\"OC对象的本质\"><a href=\"#OC对象的本质\" class=\"headerlink\" title=\"OC对象的本质\"></a>OC对象的本质</h2><ul>\n<li>OC中类和对象都是基于C和C++的结构体实现的;</li>\n<li>OC中的对象分为三种：实例对象、类对象、元类对象</li>\n</ul>\n<p><strong>实例对象内存分批</strong></p>\n<ul>\n<li><p>OC 基类为NSObject，实例对象只有一个成员变量 <code>isa</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct objc_class *Class;\nstruct objc_object &#123;\n   Class isa;\n&#125;;\ntypedef struct objc_object *id;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<img src=\"/post/OC-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/webp-20211002202054351\" class title=\"img\"></li>\n<li><p><code>isa</code>是一个指针在<strong>64位系统下占用8字节</strong>、<strong>实例化之后占用的空间是 16字节</strong> 在源码中内存分配最小是<strong>16字节</strong>（主要是内存对齐、从而分配的内存空间是16的整数倍，CPU 读取<strong>内存 iOS是从高位开始读取</strong>）</p>\n</li>\n<li><p><code>实例对象</code>就是通过alloc分配内存生成的对象，内部结构是一个isa指针和它的成员变量的值</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct objc_class &#123;\n   Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n   Class _Nullable super_class                              OBJC2_UNAVAILABLE;\n   long instance_size                                       OBJC2_UNAVAILABLE;\n   struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\n   struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\n   struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\n   struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\n#endif\n&#125; OBJC2_UNAVAILABLE;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p><code>类对象</code>在内存中有且只有一个，通过类和实例都能获取到类对象。其中包括<code>isa指针</code>，<code>superClass指针</code>，<code>类的属性信息</code>，<code>类的对象方法信息</code>，<code>类的协议信息</code>、<code>类的成员变量信息</code></p>\n</li>\n<li><p><code>元类对象</code>在每个类的内存中也只有一个，通过runtime方法object_getClass(类对象)获取。内部结构跟类对象一样都是Class类型，只是用途不一样。其中包括：isa指针，superclass指针，类的类方法信息；</p>\n</li>\n<li><p>实例对象的isa指向类对象，类对象的isa指向元类对象，元类对象的isa指向基元类，<code>基元类的isa则指向自己</code></p>\n</li>\n<li><p>实例对象中没有superclass指针，只有类对象和元类对象中有，superclass就是指向父类，<code>根元类对象的superclass指向根类对象，根类对象的superclass指向nil</code></p>\n</li>\n</ul>\n<h3 id=\"类对象\"><a href=\"#类对象\" class=\"headerlink\" title=\"类对象\"></a>类对象</h3><p>一个类的定义会包含丰富的信息（详见附录），但大部分都是关于这个类的实例的，如：</p>\n<ul>\n<li>类名及超类</li>\n<li>关于实例变量的完整描述</li>\n<li>关于方法名及其参数的说明</li>\n<li>方法的实现</li>\n</ul>\n<p><strong>虽然类对象保存了类的属性，但它本身并不是一个类的实例。它没有自己的实例变量，而且它也不能执行为类实例设计的方法</strong></p>\n<p><strong>类名就代表类对象</strong>，下面的例子中，Circle类使用继承自NSObject的方法返回类的版本号:</p>\n<p><code>Int versionNumber = [Circle version]</code></p>\n<p><strong>只有在作为接收者接收一个消息时，类名才能代表类对象</strong></p>\n<p><strong>给类发送class消息来获得一个类id</strong></p>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">Id aClass &#x3D; [anObject class];\nId rectClass &#x3D; [Circle class];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>类对象可以被转化为id类型，而且类对象还可以更精确地转化为<strong>类类型</strong>，如：</p>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">Class aClass &#x3D; [anObject class]\n Class rectClass &#x3D; [Circle class]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>所有的类都属于类对象，使用Class类型和使用类名进行静态类型匹配是等效的</li>\n<li>类对象也像类实例那样，可以进行<strong>动态类型匹配</strong>、<strong>接收消息</strong>以及从别的<strong>类继承方法</strong>。不同之处在于它们是由编译器产生的，没有自己的数据结构，它们是用于运行时系统产生类实例的代理。</li>\n</ul>\n","text":"OC对象的本质 OC中类和对象都是基于C和C++的结构体实现的; OC中的对象分为三种：实例对象、类对象、元类对象 实例对象内存分批 OC 基类为NSObject，实例对象只有一个成员变量 isa typedef struct objc_class *Class; struct ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">OC对象的本质</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">类对象</span></a></li></ol></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Runloop探究总结（一）","uid":"024b1a5a8576bdfa18efbc793fd20736","slug":"Runloop探究总结（一）","date":"2021-10-03T00:34:38.000Z","updated":"2021-10-03T10:12:35.137Z","comments":true,"path":"api/articles/Runloop探究总结（一）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"RunLoop 是什么？ Runloop是通过内部维护一个事件循环来对事件、消息进行管理的一个对象。是的，它是一个对象。 大家用C语言过main函数的都知道，main函数运行完成后程序就结束退出了。但是为什么iOS的App的main函数运行完之后APP还能一直运行呢？这就是Run...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Runloop","slug":"Runloop","count":1,"path":"api/tags/Runloop.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"iOS总结（UIViewController）相关","uid":"723aff21bbff3d47a1a80bce7952c340","slug":"iOS面试总结（UIViewController）","date":"2021-10-02T10:21:11.000Z","updated":"2021-10-02T11:21:16.629Z","comments":true,"path":"api/articles/iOS面试总结（UIViewController）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"UIViewController 在iOS应用运行中，屏幕中显示的内容是一组一组的视图对象，他们负责显示屏幕中的内容，而在视图的后面是UIViewController视图控制器，它的作用是管理哪些视图中显示的内容，并协调他们和应用其他部分的关系。 UIViewController...","link":"","photos":[],"count_time":{"symbolsCount":904,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIViewController","slug":"UIViewController","count":1,"path":"api/tags/UIViewController.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}