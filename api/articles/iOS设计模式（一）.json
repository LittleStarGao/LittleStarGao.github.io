{"title":"iOS设计模式（一）","uid":"69226c43fa619d7df7756bf099da8b7a","slug":"iOS设计模式（一）","date":"2021-09-30T12:30:53.000Z","updated":"2021-09-30T12:32:17.127Z","comments":true,"path":"api/articles/iOS设计模式（一）.json","keywords":null,"cover":null,"content":"<h4 id=\"类继承和对象组合\"><a href=\"#类继承和对象组合\" class=\"headerlink\" title=\"类继承和对象组合\"></a>类继承和对象组合</h4><ul>\n<li>类继承简单直接、硬卧关系在编译静态定义</li>\n<li>被复用的实现易于修改</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现</li>\n<li>子类描述在父类、</li>\n<li>子类直接面对父类的封装、因此破坏了封装</li>\n<li>父类实现的任何变更都会强制爱子类到的变更</li>\n<li>因为在新的问题场景下京城实现过时或者不使用，所以必须重写父类或继承来实现</li>\n</ul>\n<p>只从协议或者抽象的基类继承、应为他们只有很少的实现，而协议没有</p>\n<h4 id=\"对象组合让我们同时使用多个对象，而每个对象都假定其他对象接口正常运行，\"><a href=\"#对象组合让我们同时使用多个对象，而每个对象都假定其他对象接口正常运行，\" class=\"headerlink\" title=\"对象组合让我们同时使用多个对象，而每个对象都假定其他对象接口正常运行，\"></a>对象组合让我们同时使用多个对象，而每个对象都假定其他对象接口正常运行，</h4><ul>\n<li>优点：<ul>\n<li>不会破坏封装，只能通过接口来访问对象</li>\n<li>大大减少实现的依存关系、因为对象实现是通过接口定义的</li>\n<li>可以运行时任意对象替换为其他同类型对象</li>\n<li>有助于保持类的封装、以专注单一任务</li>\n<li>类及其层次结构能保持简洁，不至于过度膨胀而无法管理</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>设计中涉及较多对象</li>\n<li>系统的行为将依赖于不同对象间的关系、而不是定义在单个类中</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>优先使用对象组合而不是类继承、类继承与对象可以配合，找出冗余设计，此处应该使用类继承。</p>\n</blockquote>\n<ul>\n<li>圆角 ： 类实体</li>\n<li>抽象斜体</li>\n<li>抽象</li>\n</ul>\n<p>![截屏2021-09-30 下午8.07.54](iOS设计模式（一）/截屏2021-09-30 下午8.07.54.png)</p>\n<h3 id=\"范畴\"><a href=\"#范畴\" class=\"headerlink\" title=\"范畴\"></a>范畴</h3><p>![截屏2021-09-30 下午8.12.02](iOS设计模式（一）/截屏2021-09-30 下午8.12.02.png)</p>\n<p>![截屏2021-09-30 下午8.29.17](iOS设计模式（一）/截屏2021-09-30 下午8.29.17.png)</p>\n","feature":null,"text":"类继承和对象组合 类继承简单直接、硬卧关系在编译静态定义 被复用的实现易于修改 缺点： 因为类继承在编译时定义、所以无法在运行时进行变更从父类继承来的实现 子类描述在父类、 子类直接面对父类的封装、因此破坏了封装 父类实现的任何变更都会强制爱子类到的变更 因为在新的问题场景下京城...","link":"","photos":[],"count_time":{"symbolsCount":660,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88\"><span class=\"toc-text\">类继承和对象组合</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E8%AE%A9%E6%88%91%E4%BB%AC%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%81%87%E5%AE%9A%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1%E6%8E%A5%E5%8F%A3%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%EF%BC%8C\"><span class=\"toc-text\">对象组合让我们同时使用多个对象，而每个对象都假定其他对象接口正常运行，</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8C%83%E7%95%B4\"><span class=\"toc-text\">范畴</span></a>","author":{"name":"LittleLight","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"iOS开发者","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"单元测试","uid":"78bacd8b33e55bbfb6a2cbf684cbf20b","slug":"unit-test","date":"2021-07-13T03:32:17.000Z","updated":"2021-07-14T07:45:20.214Z","comments":true,"path":"api/articles/unit-test.json","keywords":null,"cover":null,"text":"别测试代码，而应该验证程序的行为测试应该只在程序的行为和预期的不一样时，才不通过。测试应该测试程序的代码做了什么，而不是测试程序如何实现。 验证应用程序做了什么的，叫做行为测试。 即使应用程序的行为不发生变化，只要应用程序的代码发生了变化，测试就不通过的，叫做脆性测试。 假设我们...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"单元测试","slug":"单元测试","count":1,"path":"api/tags/单元测试.json"}],"author":{"name":"LittleLight","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"iOS开发者","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}