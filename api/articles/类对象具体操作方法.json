{"title":"类对象具体操作方法","uid":"cf0e611562c137ce26a0fd876069298a","slug":"类对象具体操作方法","date":"2021-10-03T09:52:41.000Z","updated":"2021-12-17T02:20:20.316Z","comments":true,"path":"api/articles/类对象具体操作方法.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","content":"<h3 id=\"类与对象操作函数\"><a href=\"#类与对象操作函数\" class=\"headerlink\" title=\"类与对象操作函数\"></a>类与对象操作函数</h3><p>runtime提供了大量的函数来直接操作类与对象数据结构，类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>\n<h4 id=\"类相关操作函数\"><a href=\"#类相关操作函数\" class=\"headerlink\" title=\"类相关操作函数\"></a>类相关操作函数</h4><p>我们可以回过头去看看objc_class的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。</p>\n<h4 id=\"类名-name\"><a href=\"#类名-name\" class=\"headerlink\" title=\"类名(name)\"></a>类名(name)</h4><p>类名操作的函数主要有：<br><code>// 获取类的类名</code><br><code>const char * class_getName ( Class cls )</code></p>\n<ul>\n<li>对于<code>class_getName</code>函数，如果传入的<code>cls</code>为<code>Nil</code>，则返回一个<code>char字符串</code></li>\n</ul>\n<h4 id=\"父类-super-class-和元类-meta-class\"><a href=\"#父类-super-class-和元类-meta-class\" class=\"headerlink\" title=\"父类(super_class)和元类(meta-class)\"></a>父类(super_class)和元类(meta-class)</h4><p>父类和元类操作的函数主要有：<br> <code>// 获取类的父类</code><br> <code>Class class_getSuperclass ( Class cls );</code><br> <code>// 判断给定的Class是否是一个元类</code><br> <code>BOOL class_isMetaClass ( Class cls );</code></p>\n<p><code>class_getSuperclass</code>函数，当cls为Nil或者cls为根类时，返回<code>Nil</code>。不过通常我们可以使用<code>NSObject</code>类的<code>superclass</code>方法来达到同样的目的。</p>\n<p><code>class_isMetaClass</code>函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。</p>\n<h4 id=\"实例变量大小-instance-size\"><a href=\"#实例变量大小-instance-size\" class=\"headerlink\" title=\"实例变量大小(instance_size)\"></a>实例变量大小(instance_size)</h4><p>实例变量大小操作的函数有：<br><code>// 获取实例大小</code><br><code>size_t class_getInstanceSize ( Class cls );</code></p>\n<h4 id=\"成员变量-ivars-及属性\"><a href=\"#成员变量-ivars-及属性\" class=\"headerlink\" title=\"成员变量(ivars)及属性\"></a>成员变量(ivars)及属性</h4><p>在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>\n<ol>\n<li>成员变量操作函数，主要包含以下函数： <code>// 获取类中指定名称实例成员变量的信息</code> <code>Ivar class_getInstanceVariable ( Class cls, const char *name );</code> <code>// 获取类成员变量的信息</code> <code>Ivar class_getClassVariable ( Class cls, const char *name );</code> <code>// 添加成员变量</code> <code>BOOL class_addIvar( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );</code> <code>// 获取整个成员变量列表</code> <code>Ivar * class_copyIvarList( Class cls, unsigned int *outCount );</code></li>\n</ol>\n<p>class_getInstanceVariable函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</p>\n<p>class_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</p>\n<p>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？</p>\n<p>这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</p>\n<p>class_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</p>\n","text":"类与对象操作函数runtime提供了大量的函数来直接操作类与对象数据结构，类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。 类相关操作函数我们可以回过头去看看objc_cla...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">类与对象操作函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">类相关操作函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%90%8D-name\"><span class=\"toc-text\">类名(name)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%88%B6%E7%B1%BB-super-class-%E5%92%8C%E5%85%83%E7%B1%BB-meta-class\"><span class=\"toc-text\">父类(super_class)和元类(meta-class)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%A4%A7%E5%B0%8F-instance-size\"><span class=\"toc-text\">实例变量大小(instance_size)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-ivars-%E5%8F%8A%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">成员变量(ivars)及属性</span></a></li></ol></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"iOS中关于锁总结","uid":"5aeaa1caf03061ebea03dd5070710347","slug":"iOS中关于锁总结","date":"2021-10-03T09:58:28.000Z","updated":"2021-10-03T10:17:24.242Z","comments":true,"path":"api/articles/iOS中关于锁总结.json","keywords":null,"cover":null,"text":"7、自旋锁 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"OC消息发送","uid":"7d5af61f6682832ceaf909aad79a5565","slug":"OC消息发送","date":"2021-10-03T03:48:29.000Z","updated":"2021-10-03T04:02:14.462Z","comments":true,"path":"api/articles/OC消息发送.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"消息的发送ObjC中使用[Receiver message]方式来进行方法调用,本质其实就是向Receiver发送message消息.而message告诉这个Receiver要做什么 给nil发送消息 在ObjC中，给nil发送消息是合法的，但在运行时什么都不做，而发送给nil的...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}