{"title":"OC中的类","uid":"07b3470a92b5218af5f032e4b7c9894f","slug":"OC中的类","date":"2021-10-03T01:07:27.000Z","updated":"2021-10-03T03:45:15.921Z","comments":true,"path":"api/articles/OC中的类.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","content":"<h4 id=\"OC中的类\"><a href=\"#OC中的类\" class=\"headerlink\" title=\"OC中的类\"></a>OC中的类</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>编译器为每个类定义一个类对象(Class_object)。<strong>Class_object</strong> 是<strong>Class</strong>的编译版本，而它所构建的对象被称为类的实例</p></blockquote>\n<ul>\n<li>程序中真正做工作的是类在运行时对象创建的那些实例</li>\n<li>一个类的所有实例有同一套方法，而且有相同一套实例变量</li>\n<li>每个对象都有自己的实例变量，但他们却共享这套方法</li>\n</ul>\n<h3 id=\"继承（Inheritance）\"><a href=\"#继承（Inheritance）\" class=\"headerlink\" title=\"继承（Inheritance）\"></a><strong>继承（Inheritance）</strong></h3><ul>\n<li>一个新的类往往都基于另外一个类，而这个新类继承了原来类的方法和实例变量</li>\n<li>新类通常简单地添加实例变量或者修改它所继承的方法，它不需要复制继承的代码。继承将这些类连接成一个只有一个根继承关系树</li>\n<li>在OC中，写基于功能框架的代码时，这个根类通常是NSObject</li>\n<li>每个类(除了根类)都有一个父类，而每个类，包括根类都可以成为任何数量子类的父类</li>\n</ul>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li><p>NSObject类就是一个重要的抽象类。程序中经常会定义NSObject的子类并使用这些子类的实例，但从来没有直接使用这个类的实例</p>\n</li>\n<li><p>抽象类通常包含一些帮助定义应用程序架构的代码，当你定义这些类的子类时，这些子类的实例能很好地适应这种应用程序架构，并能够自动地和别的对象协作。由于抽象类只有定义了子类才能成为一个有用的类，因此它们常常被称为抽象超类。</p>\n</li>\n</ul>\n<h3 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a><strong>类类型</strong></h3><ul>\n<li>类实际上是一类对象的详细说明，定义了一个数据类型。这个类型不但基于它所定义的数据结构，还取决于它所定义的一些行为，这些行为就是方法</li>\n<li>类名可以出现在任何C语言允许的类型说明符出现的地方，例如作为sizeof操作符的参数：<code>Int i = sizeof(Circle);</code></li>\n</ul>\n<h3 id=\"静态类型匹配\"><a href=\"#静态类型匹配\" class=\"headerlink\" title=\"静态类型匹配\"></a><strong>静态类型匹配</strong></h3><p> <code>Circle *myCircle;</code><br> 这种声明对象的方式为编译器提供了对象种类的信息，所以被称为静态类型匹配，静态类型匹配使编译器具备了一些类型检查功能，例如如果一个对象接收一个没有定义的消息时，可以发出警告，而如果把对象定义为id，就会放松这种限制</p>\n<h3 id=\"动态类型匹配\"><a href=\"#动态类型匹配\" class=\"headerlink\" title=\"动态类型匹配\"></a><strong>动态类型匹配</strong></h3><p><code>id myCircle；</code></p>\n<ul>\n<li><p>对象通常都是被定义成指针，上面的静态匹配使得指针的含义更加明确，而id却隐藏了这些信息。<br> <strong>id类型</strong>是一种灵活的数据类型, 只表示它是一个对象，不能为编译器提供例如实例变量，可执行操作等信息。</p>\n</li>\n<li><p>每个对象在<strong>运行时</strong>必须提供这些信息。 而之所以能做到这点， 是因为每个对象都有一个<strong>isa 实例变量来标示这个对象所属的类</strong>每个Circle对象都能告诉运行时系统它是一个几何类，因此，动态类型匹配实际上发生在程序被执行时。</p>\n</li>\n<li><p>运行时系统就能够查明一个对象到底属于哪个类，而这只需要查询对象的isa实例变量就可以了。这个isa指针还为对象提供了一种称为“自省”(introspection)的功能。编译器会在数据机构中记录关于类定义的信息为运行时环境</p>\n</li>\n</ul>\n<h3 id=\"类型自省\"><a href=\"#类型自省\" class=\"headerlink\" title=\"类型自省\"></a><strong>类型自省</strong></h3><p>实例在运行时可以获取自己的类。例如，NSObject类中定义的isMemberOfClass（或isKindOfClass）方法可以检查接收者是不是特定类的实例（或继承特定类的实例）</p>\n","text":"OC中的类 编译器为每个类定义一个类对象(Class_object)。Class_object 是Class的编译版本，而它所构建的对象被称为类的实例 程序中真正做工作的是类在运行时对象创建的那些实例 一个类的所有实例有同一套方法，而且有相同一套实例变量 每个对象都有自己的实例变...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"OC类","slug":"OC类","count":1,"path":"api/tags/OC类.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#OC%E4%B8%AD%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">OC中的类</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89\"><span class=\"toc-text\">继承（Inheritance）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">类类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">静态类型匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">动态类型匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E8%87%AA%E7%9C%81\"><span class=\"toc-text\">类型自省</span></a>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"OC消息发送","uid":"7d5af61f6682832ceaf909aad79a5565","slug":"OC消息发送","date":"2021-10-03T03:48:29.000Z","updated":"2021-10-03T04:02:14.462Z","comments":true,"path":"api/articles/OC消息发送.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"消息的发送ObjC中使用[Receiver message]方式来进行方法调用,本质其实就是向Receiver发送message消息.而message告诉这个Receiver要做什么 给nil发送消息 在ObjC中，给nil发送消息是合法的，但在运行时什么都不做，而发送给nil的...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Runloop探究总结（一）","uid":"024b1a5a8576bdfa18efbc793fd20736","slug":"Runloop探究总结（一）","date":"2021-10-03T00:34:38.000Z","updated":"2021-10-03T10:12:35.137Z","comments":true,"path":"api/articles/Runloop探究总结（一）.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"RunLoop 是什么？ Runloop是通过内部维护一个事件循环来对事件、消息进行管理的一个对象。是的，它是一个对象。 大家用C语言过main函数的都知道，main函数运行完成后程序就结束退出了。但是为什么iOS的App的main函数运行完之后APP还能一直运行呢？这就是Run...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Runloop","slug":"Runloop","count":1,"path":"api/tags/Runloop.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}