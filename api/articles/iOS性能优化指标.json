{"title":"iOS性能优化指标","uid":"d6599ba5117b38d8d4d285c032bd712d","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","updated":"2021-05-22T06:09:06.209Z","comments":true,"path":"api/articles/iOS性能优化指标.json","keywords":null,"cover":[],"content":"<h4 id=\"性能指标\"><a href=\"#性能指标\" class=\"headerlink\" title=\"性能指标\"></a>性能指标</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。</p></blockquote>\n<h5 id=\"1-2-1-内存\"><a href=\"#1-2-1-内存\" class=\"headerlink\" title=\"1.2.1 内存\"></a>1.2.1 内存</h5><p>内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保没有泄漏内存。<code>随时间流逝而持续增长的内存消耗意味着，应用很可能会因 为内存不足的异常而崩溃。</code></p>\n<h5 id=\"1-2-2-电量消耗\"><a href=\"#1-2-2-电量消耗\" class=\"headerlink\" title=\"1.2.2 电量消耗\"></a>1.2.2 电量消耗</h5><p>在编写高性能代码时，<code>电量消耗是一个需要重点处理的重要因素</code>。就执行时间和 CPU 资源的利用而言，我们不仅要实现高效的数据结构和算法，还需要考虑其他的因素。如果某个应用是个电池黑洞，那么一定不会有人喜欢它。</p>\n<p><code>电量消耗不仅仅与计算 CPU 周期有关，还包括高效地使用硬件</code>。除了要实现电量消耗最 小化，还要确保不会影响用户体验。</p>\n<h5 id=\"1-2-3-初始化时间\"><a href=\"#1-2-3-初始化时间\" class=\"headerlink\" title=\"1.2.3 初始化时间\"></a>1.2.3 初始化时间</h5><p>应用在启动时应执行刚好够用的任务以完成初始化，从而满足用户的使用需求。执行这些 任务消耗的时间就是应用的初始化时间。刚好够用是一个开放式用语——正确的平衡点取 决于应用的需要。</p>\n<p>在首次使用应用时创建对象并进行初始化是一个合理的选择，例如，直到需要使用对象时 才创建对象。这种方式被称为惰性初始化。这是一种很好的策略，但也要考虑不能让用户 总是在执行后续任务时等待。</p>\n<p>下面列举了你可能想在应用初始化阶段执行的一些动作，排名不分先后。</p>\n<ul>\n<li>检查应用是否为首次启动。</li>\n<li>检查用户是否已经登录。</li>\n<li>如果用户已经登录，尽可能地载入之前的状态。</li>\n<li>连接服务器以拉取最新的变更。</li>\n<li>检查应用是否由某个深层链接唤起。如果是，还需要载入深层链接相应的 UI 和状态。</li>\n<li>检查是否存在应用上次启动时挂起的任务，需要时恢复它们。</li>\n<li>初始化后续需要使用的对象和线程池。</li>\n<li>初始化依赖项(如对象关系映射、崩溃报告系统和缓存)。</li>\n</ul>\n<p>这个列表可能会迅速变长，并且很难决定哪些条目一定要在启动时执行，哪些可以延后几 毫秒再执行。</p>\n<h5 id=\"1-2-4-执行速度\"><a href=\"#1-2-4-执行速度\" class=\"headerlink\" title=\"1.2.4 执行速度\"></a>1.2.4 执行速度</h5><p>一旦启动应用，用户总是希望它可以尽可能快地工作。一切必要的处理都应该在尽可能短 的时间内完成。</p>\n<p><code>例如</code>，在照片应用中，用户通常希望看到调整亮度或对比度等简单效果的实时预览效果。 因此，相应的处理需要在几毫秒内完成。</p>\n<p>这可能需要本地计算的并行处理技术或能够将复杂任务分发到服务器。</p>\n<h5 id=\"1-2-5-响应速度\"><a href=\"#1-2-5-响应速度\" class=\"headerlink\" title=\"1.2.5 响应速度\"></a>1.2.5 响应速度</h5><p>每个应用都应该快速地响应用户交互。在应用中所做的一切优化和权衡最终都应该体现在 响应速度上。</p>\n<p>App Store 中有许多应用可以完成相似或相关的任务。这为用户提供了很大的选择空间，而用户基本都会选择响应最快的应用。</p>\n<h5 id=\"1-2-6-本地存储\"><a href=\"#1-2-6-本地存储\" class=\"headerlink\" title=\"1.2.6 本地存储\"></a>1.2.6 本地存储</h5><p>针对任何在服务器上存储数据或通过外部来源刷新数据的应用，开发人员应该对本地存储 的使用有所规划，以便应用具备离线浏览的能力。</p>\n<p>例如，用户都希望邮件应用能够在无网络或设备离线的情况下浏览历史邮件。 同样，新闻应用也应该可以在离线模式下显示最近更新的新闻，并标记出每条新闻是否已读。</p>\n<p>然而，从本地存储中载入和同步数据应该迅速、便捷。这不仅需要选择要在本地缓存的数 据和要优化的数据结构，还需要提供一系列的配置选项并确定数据同步的频率。</p>\n<p>如果你的应用使用了本地存储，那么请提供一个清除数据的选项。遗憾的是，市场上的大 部分应用都没有提供此选项。更让人烦恼的是，一些应用竟然会消耗数百兆的存储空间。 用户会频繁地卸载这些应用来回收本地存储。这会导致糟糕的用户体验，从而威胁应用的 成功。</p>\n<h5 id=\"1-2-7-互操作性\"><a href=\"#1-2-7-互操作性\" class=\"headerlink\" title=\"1.2.7 互操作性\"></a>1.2.7 互操作性</h5><p>用户可能会使用多个应用来完成某个任务，这就需要这些应用直接提供互操作的能力。例 如，一个相册可能需要一个幻灯片应用来实现最佳的浏览体验，但需要另一个应用来编辑 照片。其中浏览照片的应用要能够将照片发送到编辑器，并接收编辑后的图片。</p>\n<p>iOS 为实现应用间的互操作和数据共享提供了多种机制，其中包括 UIActivityViewController、 深层链接、MultipeerConnectivity 框架，等等。</p>\n<p>为深层链接定义良好的 URL 结构与编写优异的代码来解析 URL 同样重要。类似地，使用 共享对话框共享数据时，精确识别用于分享的数据非常重要，同时，在处理不同数据源传 入的数据时还要注意安全隐患。</p>\n<p>如果某个应用向附近设备共享数据时需要花费很长时间准备数据，那么用户体验就会非常 糟糕。</p>\n<h5 id=\"1-2-8-网络环境\"><a href=\"#1-2-8-网络环境\" class=\"headerlink\" title=\"1.2.8 网络环境\"></a>1.2.8 网络环境</h5><p>移动设备会在不同网络环境下使用。为了确保能够提供最好的用户体验，你的应用应当适 应各种网络条件:</p>\n<ol>\n<li>高带宽稳定网络</li>\n<li>低带宽稳定网络</li>\n<li>高带宽不稳定网络</li>\n<li>低带宽不稳定网络</li>\n<li>无网络</li>\n</ol>\n<h5 id=\"1-2-9-带宽\"><a href=\"#1-2-9-带宽\" class=\"headerlink\" title=\"1.2.9 带宽\"></a>1.2.9 带宽</h5><p>人们会在不同的网络条件下使用自己的移动设备，网速从每秒数千字节到每秒数十兆字节。 因此，带宽的优化使用是定义应用质量的另一个关键参数。此外，在高带宽网络下运行一 个基于低带宽网络开发的应用可能会产生完全不同的结果。</p>\n<p>2010 年左右，我和我的团队正在印度开发一款应用。由于处于低带宽网络，应用的本地初始化速度要比从服务器端载入资源快得多，于是我们针对这种情况进行了优化。</p>\n<p>然而，当这款应用投入韩国市场时，我们对它进行了测试，结果却让人大跌眼镜。之前所 进行的所有优化几乎毫无意义，我们不得不重写了大部分可能导致资源和数据冲突的相关 代码。</p>\n<p>为提高性能所做的设计并非每次都能如愿，也可能会导致相反的效果。</p>\n<h5 id=\"1-2-10-数据刷新\"><a href=\"#1-2-10-数据刷新\" class=\"headerlink\" title=\"1.2.10 数据刷新\"></a>1.2.10 数据刷新</h5><p>即使没有提供离线浏览能力，你仍然可以从服务器端周期性地刷新数据。刷新的频率和每 次传输的数据量将决定数据传输的总量。如果传输的字节数过大，那用户必然会快速耗尽 自己的流量计划。当流量消耗大到一定程度时，你的应用很可能会流失用户。</p>\n<p>在 iOS 6.x 或更低版本中，在后台运行的应用不能刷新数据。从 iOS 7 开始，<code>应用可以在后台周期性地刷新数据</code>。对于在线聊天类应用，<code>持久的 HTTP 连接或原生 TCP 连接可能会非常有用。</code></p>\n<h5 id=\"1-2-11-多用户支持\"><a href=\"#1-2-11-多用户支持\" class=\"headerlink\" title=\"1.2.11 多用户支持\"></a>1.2.11 多用户支持</h5><p>家庭成员间可能会共享移动设备，或者一个用户可能会拥有同一应用的多个账号。例如， 兄弟姐妹间可能会共享一个 iPad 来玩游戏。再比如，家庭成员可能会在旅游时配置一个设备来查收全家人的电子邮件，以减少漫游费用，尤其是在境外旅游时。类似地，一个人也 可能会配置多个电子邮件账号。</p>\n<p>是否支持多个并发用户取决于产品的需要。一旦决定提供此类功能，请参考以下准则。</p>\n<ol>\n<li>添加新用户应尽可能高效。</li>\n<li>在不同用户之间更新应尽可能高效。</li>\n<li>在不同用户之间切换应尽可能高效。</li>\n<li>用户数据的界限应该简洁且没有 bug。</li>\n</ol>\n<h5 id=\"1-2-12-单点登录\"><a href=\"#1-2-12-单点登录\" class=\"headerlink\" title=\"1.2.12 单点登录\"></a>1.2.12 单点登录</h5><p>如果你已经创建了多个允许或需要登录的应用，那么支持单点登录(single sign-on，SSO) 是非常棒的选择。如果用户登录了一个应用，只需要点击一次，就可以登录到其他的应用中。</p>\n<p>这个过程不仅需要支持跨应用的数据共享，还需要分享状态、跨应用同步等。例如，如果 用户注销了其中某个应用，则通过 SSO 登录的所有其他应用也应能注销掉。 此外，应用之间的同步应该是安全的。</p>\n<h5 id=\"1-2-13-安全\"><a href=\"#1-2-13-安全\" class=\"headerlink\" title=\"1.2.13 安全\"></a>1.2.13 安全</h5><p>安全对移动应用来说是最重要的，因为敏感信息可能会在应用间共享。因此，对所有通信 以及本地数据和共享数据进行加密就显得尤为重要了。</p>\n<p>实现安全需要更多的计算、内存和存储，但这与最大化运行速度、最小化内存和存储使用 的目标相冲突。</p>\n<p>因此，你需要在安全和其他因素之间进行权衡。</p>\n<p>引入多个安全层会影响性能，并对用户体验造成可感知的负面影响。如何设定安全的基线 需要参考对用户群体的统计分析。此外，硬件在其中扮演了重要的角色:选择会因为不同 设备的计算能力而有所不同。</p>\n<h5 id=\"1-2-14-崩溃\"><a href=\"#1-2-14-崩溃\" class=\"headerlink\" title=\"1.2.14 崩溃\"></a>1.2.14 崩溃</h5><p>应用可能会而且确实会崩溃。过度优化会导致崩溃。同样，使用原始 C 代码也可能会导致 崩溃。 高性能的应用不仅应尽可能地避免崩溃，还应该在崩溃发生时优雅地恢复，尤其是在进行 某个操作的过程中发生崩溃时。</p>\n<h4 id=\"综上所述\"><a href=\"#综上所述\" class=\"headerlink\" title=\"综上所述\"></a>综上所述</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>性能主要从以上所有面向用户的基本属性指标分析</p></blockquote>\n<img src=\"/post/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E6%A0%87/83e38ad0-e401-4755-92cb-58b3c6204e08.jpg\" class title=\"img\">\n\n","text":"性能指标 性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。 1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":3,"path":"api/tags/iOS性能优化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">性能指标</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-1-%E5%86%85%E5%AD%98\"><span class=\"toc-text\">1.2.1 内存</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-2-%E7%94%B5%E9%87%8F%E6%B6%88%E8%80%97\"><span class=\"toc-text\">1.2.2 电量消耗</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">1.2.3 初始化时间</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-4-%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">1.2.4 执行速度</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-5-%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">1.2.5 响应速度</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-6-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">1.2.6 本地存储</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-7-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7\"><span class=\"toc-text\">1.2.7 互操作性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-8-%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">1.2.8 网络环境</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-9-%E5%B8%A6%E5%AE%BD\"><span class=\"toc-text\">1.2.9 带宽</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-10-%E6%95%B0%E6%8D%AE%E5%88%B7%E6%96%B0\"><span class=\"toc-text\">1.2.10 数据刷新</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-11-%E5%A4%9A%E7%94%A8%E6%88%B7%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">1.2.11 多用户支持</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-12-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95\"><span class=\"toc-text\">1.2.12 单点登录</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-13-%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">1.2.13 安全</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-2-14-%E5%B4%A9%E6%BA%83\"><span class=\"toc-text\">1.2.14 崩溃</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0\"><span class=\"toc-text\">综上所述</span></a></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《腾讯iOS测试实践》学习（一）","uid":"72c9fa0d926f81572e4b5de9847c1152","slug":"《腾讯iOS测试实践》学习（一）","date":"2021-05-22T07:06:49.000Z","updated":"2021-10-01T05:39:06.733Z","comments":true,"path":"api/articles/《腾讯iOS测试实践》学习（一）.json","keywords":null,"cover":[],"text":" 工程效率 需求评审：需求评审机制以及更新通知，避免需求有改动而没有及时同步到相关角色。 代码质量：静态代码扫描，千行代码缺陷率等。 架构评审：代码架构的讨论以及评审。 Bug流程：Bug生命周期，避免随便修改Bug状态以及备注缺失。 Code Review：代码评审，如果有代码...","link":"","photos":[],"count_time":{"symbolsCount":436,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":3,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"iOS内存对齐","uid":"eafabc105702abbd3d554d5c51e703dd","slug":"Memory-alignment","date":"2021-05-03T00:55:06.000Z","updated":"2021-05-03T02:17:18.409Z","comments":true,"path":"api/articles/Memory-alignment.json","keywords":null,"cover":null,"text":"iOS中内存对齐数据对齐规则 结构体和联合体（union）的数据成员，第一个数据成员放到offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员子成员大小（只要该成员有子成员，比如说数组，结构体等）的整数倍开始（比如int为4自己接，则要从4的整数倍地址开始存...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}