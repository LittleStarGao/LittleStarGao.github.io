{"title":"应用性能分析方法","uid":"5c608ba3383f27b31f8830b3a9b5f6d6","slug":"应用性能分析方法","date":"2021-05-22T07:06:49.000Z","updated":"2021-10-02T01:13:27.687Z","comments":true,"path":"api/articles/应用性能分析方法.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","content":"<h1 id=\"应用性能分析方法\"><a href=\"#应用性能分析方法\" class=\"headerlink\" title=\"应用性能分析方法\"></a>应用性能分析方法</h1><h4 id=\"1-采样\"><a href=\"#1-采样\" class=\"headerlink\" title=\"1. 采样\"></a>1. 采样</h4><p>顾名思义，<code>采样</code>(或基于探测点的性能分析)<code>是指以一定的周期间隔采集状态</code>，这通常需要借助工具。由于不会干扰应用的执行，因此采样可以很好地提供应用的全景图。采样的不足之处在于它不能返回 100% 精确的细节。如果采样的频率是 10 毫秒，那么你就无法得知在探测点之间的 9.999 毫秒内发生了什么。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>采样可以作为初始的性能调研手段，并可用于跟踪 CPU 和内存的使用情况</p></blockquote>\n<h4 id=\"2-埋点\"><a href=\"#2-埋点\" class=\"headerlink\" title=\"2. 埋点\"></a>2. 埋点</h4><p>通过修改代码，记录细节信息的埋点能够提供比采样更加精确的结果。你既可以在关键部分主动埋点，也可以在性能分析或处理用户反馈时有针对性地埋点<br><code>因为埋点需要注入额外代码，所以它一定会影响应用的性能，对内存或速度(或同时对二者)造成损害。</code></p>\n<h2 id=\"1-4-测量\"><a href=\"#1-4-测量\" class=\"headerlink\" title=\"1.4 测量\"></a>1.4 测量</h2><p>现在，我们已经确定了需要测量的参数，并且研究了测量所需要的不同类型的分析。我们<br>先简单了解一下如何实现测量。</p>\n<p>通过测量性能并找出真正存在问题的地方，你可以避免掉入过早优化的陷阱.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>真正的问题在于,程序开发人员为提升程序效率在错误的方向和时间点浪费了太多时间;<code>过早优化是编程领域的万恶(至少是绝大多数的恶)之源。</code></p></blockquote>\n<h4 id=\"1-4-1-设置工程与代码\"><a href=\"#1-4-1-设置工程与代码\" class=\"headerlink\" title=\"1.4.1 设置工程与代码\"></a>1.4.1 设置工程与代码</h4><p>接下来，我们将建立一个工程，以便在开发和生产阶段测量已经定义好的参数。针对工程<br>配置、安装和代码实现共有三类任务。</p>\n<ol>\n<li><p>构建与发布 : 确保能够轻松地构建和发布应用。</p>\n</li>\n<li><p>可测试性 确保你的代码能够同时在模拟数据和真实数据之上工作，其中包括能够模拟真实场景的隔离环境</p>\n</li>\n<li><p>可跟踪性 确保你能够通过<code>明确问题发生的位置和代码行为来处理错误。</code></p>\n</li>\n</ol>\n<h5 id=\"1-构建与发布\"><a href=\"#1-构建与发布\" class=\"headerlink\" title=\"1. 构建与发布\"></a>1. 构建与发布</h5><p>由于对<code>灵活</code>和<code>敏捷</code>的强烈需求，系统和工具得到了改进。改进后的系统和工具现在可以加速拉取依赖信息，加速构建和发布用于测试或企业分发的产品，也可以为公众发布而提高提交文件到 iTunes Connect 的速度。</p>\n<p>基于 Ruby 语言实现的 CocoaPods(<a href=\"https://cocoapods.org)实际上是/\">https://cocoapods.org)实际上是</a> Objective-C 和 Swift 工程的<code>依赖管理器</code>。CocoaPods 与 Xcode 命令行工具相集成，可用于构建与发布。</p>\n<h5 id=\"2-可测试性\"><a href=\"#2-可测试性\" class=\"headerlink\" title=\"2. 可测试性\"></a>2. 可测试性</h5><p>每个应用都包含多个协同工作的组件。一个设计良好的系统应该遵循<code>低耦合</code>和<code>高内聚，</code>并允许<code>替换任意或全部组件的依赖。</code></p>\n<p>可以通过模拟依赖项目对每个组件进行隔离测试。一般来说，测试有两种类型。</p>\n<p>• <code>单元测试</code> 验证每个代码单元在隔离环境下的操作。常见的做法是，在特定的环境中用不同的输入数据反复地调用一些方法，以评估代码的表现。</p>\n<p>• <code>功能测试</code> 验证组件在最终集成的安装包中的操作。可以在软件的最终发布版本中验证，也可以在某个为测试而构建的参考应用中验证。</p>\n<h5 id=\"3-可跟踪性\"><a href=\"#3-可跟踪性\" class=\"headerlink\" title=\"3. 可跟踪性\"></a>3. 可跟踪性</h5><p>在开发阶段，<code>埋点可以帮助我们确定性能优化的优先级</code>、<code>提高对问题现场的还原能力，</code>并提供更多的调试信息。崩溃报告专注于从软件的产品版本中收集调试信息。</p>\n<h5 id=\"4-设置崩溃报告\"><a href=\"#4-设置崩溃报告\" class=\"headerlink\" title=\"4. 设置崩溃报告\"></a>4. 设置崩溃报告</h5><p>崩溃报告系统收集用于分析应用的调试日志。市面上有数十种崩溃报告系统.</p>\n<h5 id=\"5-对应用埋点\"><a href=\"#5-对应用埋点\" class=\"headerlink\" title=\"5. 对应用埋点\"></a>5. 对应用埋点</h5><p>对应用进行埋点是了解用户行为的一个重要步骤，但更重要的目的是识别应用的关键路<br>径。注入特定的代码以记录关键指标是提升应用性能的重要步骤。</p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>日志是无价之宝，可以用于了解应用发生了什么事。<br>日志和埋点之间存在着细微的差别。埋点可以看作日志的子集。被埋点的任何数据都应该 记录在日志中。<br>埋点承担了为聚合分析发布关键性能数据的职责，日志则提供了用于在不同级别跟踪应用的细节信息，比如 <code>debug、``Verbose、``info、``warning </code>和 <code>Error。</code>日志的记录会贯穿应用的整个生命周期，而埋点只应该用在开发的特定阶段。</p>\n<p>埋点数据会发送到服务器，日志是记录在设备本地。 就日志而言，我们可以通过 CocoaPods 引入 <code>CocoaLumberjack</code> 来使用。</p>\n<p><code>CocoaLumberjack</code> 是一个扩展性很强的框架，捆绑了一系列内置的<code>日志记录器</code>，这些记录器 可以向不同的目标发送信息。例如，使用 DDASLLogger <code>可以向 Apple System Log(ASL， NSLog 方法的默认位置)记录日志</code>。类似地，<code>使用 DDFileLogger 可以向文件记录日志。可 以在应用运行期间配置记录器。</code></p>\n<p>DDLog<Level> 宏指令可以用于记录某个特定层级的日志。层级越高，信息越重要。最高级 别是 Error，最低级别是 Verbose。实际记录消息的最低层级可以配置在每个文件层级、每 个 Xcode 配置层级、每个日志器层级或全局。<br>以下的宏指令可供使用。</Level></p>\n<ol>\n<li><code>DDLogError</code> 表示不可恢复的错误。</li>\n<li><code>DDLogWarn</code> 表示可恢复的错误。</li>\n<li><code>DDLogInfo</code> 表示非错误的信息。</li>\n<li><code>DDLogDebug</code> 表示数据主要用于调试。</li>\n<li><code>DDLogVerbose </code>几乎提供了所有的细节，主要用于跟踪执行过程中的控制流。<br>这些宏指令有着与 NSLog 相同的签名。这意味着你可以直接用适合的 DDLog<Level> 调用来 取代 NSLog。</Level></li>\n</ol>\n","text":"应用性能分析方法1. 采样顾名思义，采样(或基于探测点的性能分析)是指以一定的周期间隔采集状态，这通常需要借助工具。由于不会干扰应用的执行，因此采样可以很好地提供应用的全景图。采样的不足之处在于它不能返回 100% 精确的细节。如果采样的频率是 10 毫秒，那么你就无法得知在探测...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":2,"path":"api/tags/iOS性能优化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">应用性能分析方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%87%87%E6%A0%B7\"><span class=\"toc-text\">1. 采样</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9F%8B%E7%82%B9\"><span class=\"toc-text\">2. 埋点</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E6%B5%8B%E9%87%8F\"><span class=\"toc-text\">1.4 测量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-1-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1.4.1 设置工程与代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83\"><span class=\"toc-text\">1. 构建与发布</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7\"><span class=\"toc-text\">2. 可测试性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%8F%AF%E8%B7%9F%E8%B8%AA%E6%80%A7\"><span class=\"toc-text\">3. 可跟踪性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E8%AE%BE%E7%BD%AE%E5%B4%A9%E6%BA%83%E6%8A%A5%E5%91%8A\"><span class=\"toc-text\">4. 设置崩溃报告</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%AF%B9%E5%BA%94%E7%94%A8%E5%9F%8B%E7%82%B9\"><span class=\"toc-text\">5. 对应用埋点</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">日志</span></a></li></ol></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DartException","uid":"1117fb54e92a8351488adf129028b2a6","slug":"DartException","date":"2021-05-31T09:06:01.000Z","updated":"2021-12-08T05:14:32.595Z","comments":true,"path":"api/articles/DartException.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"Dart 异常处理操作![截屏2021-05-31 下午5.06.39](DartException/截屏2021-05-31 下午5.06.39.png) 延迟加载异常 DeferredLoadException 延迟加载异常 throw new FormateExceptio...","link":"","photos":[],"count_time":{"symbolsCount":505,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Dart","slug":"Dart","count":5,"path":"api/tags/Dart.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"iOS性能优化指标","uid":"d6599ba5117b38d8d4d285c032bd712d","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","updated":"2021-10-02T01:12:36.233Z","comments":true,"path":"api/articles/iOS性能优化指标.json","keywords":null,"cover":"https://static01.imgkr.com/temp/05ea7cec66a3408a929eb7cfe95619cf.png","text":"性能指标 性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。 1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":2,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}