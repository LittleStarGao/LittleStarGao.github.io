{"title":"iOS内存对齐","uid":"eafabc105702abbd3d554d5c51e703dd","slug":"Memory-alignment","date":"2021-05-03T00:55:06.000Z","updated":"2021-05-03T02:17:18.409Z","comments":true,"path":"api/articles/Memory-alignment.json","keywords":null,"cover":null,"content":"<h4 id=\"iOS中内存对齐\"><a href=\"#iOS中内存对齐\" class=\"headerlink\" title=\"iOS中内存对齐\"></a>iOS中内存对齐</h4><h5 id=\"数据对齐规则\"><a href=\"#数据对齐规则\" class=\"headerlink\" title=\"数据对齐规则\"></a>数据对齐规则</h5><ul>\n<li><p>结构体和联合体（union）的数据成员，第一个数据成员放到offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员子成员大小（只要该成员有子成员，比如说数组，结构体等）的整数倍开始（比如int为4自己接，则要从4的整数倍地址开始存储）</p>\n</li>\n<li><p>结构体作为成员，则结构体成员要从其内部最大元素大小的整数倍开始存储( 那么b应该从8的整数倍开始存储)</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">struct GLStruct1 &#123;\n  char a; &#x2F;&#x2F; 1 + 7（不全七个）\n  double b; &#x2F;&#x2F; 8 字节\n  int c; &#x2F;&#x2F; 4 字节\n  short d; &#x2F;&#x2F; 2 字节\n&#125; GLStruct1;\n\n\nstruct GLStruct2 &#123;\n  double b; &#x2F;&#x2F; 8字节\n  char a; &#x2F;&#x2F; 1 字节\n   int c; &#x2F;&#x2F; 4 字节\n  short d; &#x2F;&#x2F;  2字节\n&#125; GLStruct2;\n\nNSLog(@&quot;%lu - %lu&quot;, sizeof(GLStruct1), sizeof(GLStruct1));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h4 id=\"关于分配内存8字节对齐\"><a href=\"#关于分配内存8字节对齐\" class=\"headerlink\" title=\"关于分配内存8字节对齐\"></a>关于分配内存8字节对齐</h4><pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">#import &lt;Foundation&#x2F;Foundation.h&gt;\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface GLPerson : NSObject\n  \n@Property (nonatomic, copy) NSString *name;\n@Property (nonatomic, assign) int age;\n@Property (nonatomic, assign) long height;\n@Property (nonatomic, copy) NSString *hobby;\n\n\n\n&#x2F;&#x2F; @Property (nonatomic, assign) int sex;\n&#x2F;&#x2F; @Property (nonatomic) char ch1;\n&#x2F;&#x2F; @Property (nonatomic) char ch2;\n\n@end\n\nNS_ASSUME_NONNULL_END<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">GLPerson *person &#x3D; [GLPerson alloc];\nperson.name &#x3D; @&quot;张三&quot;；\nperson.age &#x3D; 18;\nperson.height &#x3D; 180;\nperson.hobby &#x3D; @&quot;nv&quot;\n  \n总共分配对象实例的内存大小： \n  isa 8个字节\n  name 8个字节\n  age  4个字节\n  height 8个字节\n  hobby  8个字节\n  \nNSLog(@&quot;%lu - %lu&quot;, class_getInstancesClass([person class]))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>对象申请的内存大小  VS  系统开辟的大小 <strong>不一致</strong></p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">void *\ncalloc(size_t num_items, size_t size)\n&#123;\n\tvoid *retval;\n\tretval &#x3D; malloc_zone_calloc(default_zone, num_items, size);\n\tif (retval &#x3D;&#x3D; NULL) &#123;\n\t\terrno &#x3D; ENOMEM;\n\t&#125;\n\treturn retval;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">void *\nmalloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n\tMALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);\n\n\tvoid *ptr;\n\tif (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;&#x3D; malloc_check_start)) &#123;\n\t\tinternal_check();\n\t&#125;\n\n\tptr &#x3D; zone-&gt;calloc(zone, num_items, size);\n\t\n\tif (malloc_logger) &#123;\n\t\tmalloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,\n\t\t\t\t(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);\n\t&#125;\n\n\tMALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);\n\treturn ptr;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>找到对应下方方法</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">p zone-&gt;calloc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">static void *\ndefault_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)\n&#123;\n\tzone &#x3D; runtime_default_zone();\n\t\n\treturn zone-&gt;calloc(zone, num_items, size);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">static void *\nnano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)\n&#123;\n\tsize_t total_bytes;\n\n\tif (calloc_get_size(num_items, size, 0, &amp;total_bytes)) &#123;\n\t\treturn NULL;\n\t&#125;\n\n\tif (total_bytes &lt;&#x3D; NANO_MAX_SIZE) &#123;\n\t\tvoid *p &#x3D; _nano_malloc_check_clear(nanozone, total_bytes, 1);\n\t\tif (p) &#123;\n\t\t\treturn p;\n\t\t&#125; else &#123;\n\t\t\t&#x2F;* FALLTHROUGH to helper zone *&#x2F;\n\t\t&#125;\n\t&#125;\n\tmalloc_zone_t *zone &#x3D; (malloc_zone_t *)(nanozone-&gt;helper_zone);\n\treturn zone-&gt;calloc(zone, 1, total_bytes);\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">static void *\n_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)\n&#123;\n\tMALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, 0);\n\n\tvoid *ptr;\n\tsize_t slot_key;\n\tsize_t slot_bytes &#x3D; segregated_size_to_fit(nanozone, size, &amp;slot_key); &#x2F;&#x2F; Note slot_key is set here\n\tmag_index_t mag_index &#x3D; nano_mag_index(nanozone);\n\n\tnano_meta_admin_t pMeta &#x3D; &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);\n\n\tptr &#x3D; OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));\n\tif (ptr) &#123;\n\t\tunsigned debug_flags &#x3D; nanozone-&gt;debug_flags;\n#if NANO_FREE_DEQUEUE_DILIGENCE\n\t\tsize_t gotSize;\n\t\tnano_blk_addr_t p; &#x2F;&#x2F; the compiler holds this in a register\n\n\t\tp.addr &#x3D; (uint64_t)ptr; &#x2F;&#x2F; Begin the dissection of ptr\n\t\tif (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Invalid signature for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tif (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Mismatched magazine for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tgotSize &#x3D; _nano_vet_and_size_of_free(nanozone, ptr);\n\t\tif (0 &#x3D;&#x3D; gotSize) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Invalid pointer %p dequeued from free list\\n&quot;, ptr);\n\t\t&#125;\n\t\tif (gotSize !&#x3D; slot_bytes) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Mismatched size for pointer %p dequeued from free list\\n&quot;,\n\t\t\t\t\tptr);\n\t\t&#125;\n\n\t\tif (!_nano_block_has_canary_value(nanozone, ptr)) &#123;\n\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t&quot;Heap corruption detected, free list canary is damaged for %p\\n&quot;\n\t\t\t\t\t&quot;*** Incorrect guard value: %lu\\n&quot;, ptr,\n\t\t\t\t\t((chained_block_t)ptr)-&gt;double_free_guard);\n\t\t&#125;\n\n#if defined(DEBUG)\n\t\tvoid *next &#x3D; (void *)(((chained_block_t)ptr)-&gt;next);\n\t\tif (next) &#123;\n\t\t\tp.addr &#x3D; (uint64_t)next; &#x2F;&#x2F; Begin the dissection of next\n\t\t\tif (NANOZONE_SIGNATURE !&#x3D; p.fields.nano_signature) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Invalid next signature for pointer %p dequeued from free &quot;\n\t\t\t\t\t\t&quot;list, next &#x3D; %p\\n&quot;, ptr, &quot;next&quot;);\n\t\t\t&#125;\n\n\t\t\tif (mag_index !&#x3D; p.fields.nano_mag_index) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Mismatched next magazine for pointer %p dequeued from &quot;\n\t\t\t\t\t\t&quot;free list, next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\n\t\t\tgotSize &#x3D; _nano_vet_and_size_of_free(nanozone, next);\n\t\t\tif (0 &#x3D;&#x3D; gotSize) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Invalid next for pointer %p dequeued from free list, &quot;\n\t\t\t\t\t\t&quot;next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\t\t\tif (gotSize !&#x3D; slot_bytes) &#123;\n\t\t\t\tmalloc_zone_error(debug_flags, true,\n\t\t\t\t\t\t&quot;Mismatched next size for pointer %p dequeued from free &quot;\n\t\t\t\t\t\t&quot;list, next &#x3D; %p\\n&quot;, ptr, next);\n\t\t\t&#125;\n\t\t&#125;\n#endif &#x2F;* DEBUG *&#x2F;\n#endif &#x2F;* NANO_FREE_DEQUEUE_DILIGENCE *&#x2F;\n\n\t\t((chained_block_t)ptr)-&gt;double_free_guard &#x3D; 0;\n\t\t((chained_block_t)ptr)-&gt;next &#x3D; NULL; &#x2F;&#x2F; clear out next pointer to protect free list\n\t&#125; else &#123;\n\t\tptr &#x3D; segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);\n\t&#125;\n\n\tif (cleared_requested &amp;&amp; ptr) &#123;\n\t\tmemset(ptr, 0, slot_bytes); &#x2F;&#x2F; TODO: Needs a memory barrier after memset to ensure zeroes land first?\n\t&#125;\n\treturn ptr;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">static MALLOC_INLINE size_t\nsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)\n&#123;\n\t&#x2F;&#x2F; size &#x3D; 40\n\tsize_t k, slot_bytes;\n\n\tif (0 &#x3D;&#x3D; size) &#123;\n\t\tsize &#x3D; NANO_REGIME_QUANTA_SIZE; &#x2F;&#x2F; Historical behavior\n\t&#125;\n\t&#x2F;&#x2F; 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4\n\t&#x2F;&#x2F; 40 - 16*3 &#x3D; 48\n\n\t&#x2F;&#x2F;\n\t&#x2F;&#x2F; 16 字节对齐\n\tk &#x3D; (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; &#x2F;&#x2F; round up and shift for number of quanta\n\tslot_bytes &#x3D; k &lt;&lt; SHIFT_NANO_QUANTUM;\t\t\t\t\t\t\t&#x2F;&#x2F; multiply by power of two quanta size\n\t*pKey &#x3D; k - 1;\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; Zero-based!\n\n\treturn slot_bytes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","text":"iOS中内存对齐数据对齐规则 结构体和联合体（union）的数据成员，第一个数据成员放到offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员子成员大小（只要该成员有子成员，比如说数组，结构体等）的整数倍开始（比如int为4自己接，则要从4的整数倍地址开始存...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#iOS%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90\"><span class=\"toc-text\">iOS中内存对齐</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99\"><span class=\"toc-text\">数据对齐规则</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E5%88%86%E9%85%8D%E5%86%85%E5%AD%988%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90\"><span class=\"toc-text\">关于分配内存8字节对齐</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">注意：</span></a></li></ol>","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"iOS性能优化指标","uid":"d6599ba5117b38d8d4d285c032bd712d","slug":"iOS性能优化指标","date":"2021-05-22T06:07:50.000Z","updated":"2021-05-22T06:09:06.209Z","comments":true,"path":"api/articles/iOS性能优化指标.json","keywords":null,"cover":[],"text":"性能指标 性能指标是面向用户的各种属性。每个属性可能是一个或多个可测量工程参数的一个要素。 1.2.1 内存内存涉及运行应用所需的 RAM 最小值，以及应用消耗的内存平均值和峰值。最小内存值 会严重限制硬件，而更高的内存平均值和峰值意味着更多的后台应用会被强制关闭。 同时还要确保...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"iOS性能优化","slug":"iOS性能优化","count":3,"path":"api/tags/iOS性能优化.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring基础了解","uid":"a519dcebcf7b75aa7909ffb897e4913c","slug":"Spring-base","date":"2021-05-02T06:22:41.000Z","updated":"2021-05-02T08:29:03.294Z","comments":true,"path":"api/articles/Spring-base.json","keywords":null,"cover":[],"text":"Spring 简介​ Spring 是分层的 full-stack（全栈） 轻量级开源框架，以IoC和 AOP 为内核，提供了展现层Spring MVC和业务层事务管理等众多的企业级应⽤技术，还能整合开源世界众多著名的第三⽅框架和类库，已 经成为使⽤最多的Java EE企业应⽤开...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}