{"title":"UIView图像显示原理","uid":"150d0752192ea36adfb8f6a2036d586d","slug":"UIView图像显示原理","date":"2021-10-03T11:05:50.000Z","updated":"2021-10-03T11:07:46.358Z","comments":true,"path":"api/articles/UIView图像显示原理.json","keywords":null,"cover":[],"content":"<p><strong>图像显示原理</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1782258-a69c93621a9ba4fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"img\"></p>\n<p>image</p>\n<p>1.CPU:输出位图<br> 2.GPU :图层渲染，纹理合成<br> 3.把结果放到帧缓冲区(frame buffer)中<br> 4.再由视频控制器根据vsync信号在指定时间之前去提取帧缓冲区的屏幕显示内容<br> 5.显示到屏幕上</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1782258-662a10ef1fdd2b26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"img\"></p>\n<p><em>CPU工作</em><br> 1.Layout: UI布局，文本计算<br> 2.Display: 绘制<br> 3.Prepare: 图片解码<br> 4.Commit：提交位图</p>\n<p><em>GPU渲染管线(OpenGL)</em><br> 顶点着色，图元装配，光栅化，片段着色，片段处理</p>\n<p><strong>四、UI卡顿掉帧原因</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1782258-b894e35f1345c755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"img\"></p>\n<p>iOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GPU共同决定的。<br> 一般来说，页面滑动流畅是60fps，也就是1s有60帧更新，即每隔16.7ms就要产生一帧画面，而如果CPU和GPU加起来的处理时间超过了16.7ms，就会造成掉帧甚至卡顿。</p>\n<p><strong>五、滑动优化方案</strong><br> CPU：把以下操作放在子线程中<br> 1.对象创建、调整、销毁<br> 2.预排版（布局计算、文本计算、缓存高度等等）<br> 3.预渲染（文本等异步绘制，图片解码等）</p>\n<p>GPU:<br> 纹理渲染，视图混合</p>\n<p>一般遇到性能问题时，考虑以下问题：<br> 是否受到CPU或者GPU的限制？<br> 是否有不必要的CPU渲染？<br> 是否有太多的离屏渲染操作？<br> 是否有太多的图层混合操作？<br> 是否有奇怪的图片格式或者尺寸？<br> 是否涉及到昂贵的view或者效果？<br> view的层次结构是否合理？</p>\n<p><strong>六、UI绘制原理</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1782258-3e87f7c2b82a121d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"img\"></p>\n<p>image</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1782258-debde8a3e58aecaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"img\"></p>\n<p>image</p>\n<p><em>异步绘制：</em><br> [self.layer.delegate displayLayer: ]<br> 代理负责生成对应的bitmap<br> 设置该bitmap作为该layer.contents属性的值</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1782258-5780d092004ccfc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp\" alt=\"img\"></p>\n<p>image</p>\n<p><strong>七、离屏渲染</strong></p>\n<p>On-Screen Rendering:当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行<br> Off-Screen Rendering:离屏渲染，分为CPU离屏渲染和GPU离屏渲染两种形式。GPU离屏渲染指的是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作<br> 应当尽量避免的则是GPU离屏渲染</p>\n<p><em>GPU离屏渲染何时会触发呢？</em><br> 圆角（当和maskToBounds一起使用时）、图层蒙版、阴影，设置</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">layer.shouldRasterize ＝ YES<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><em>为什么要避免GPU离屏渲染？</em><br> GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到offscreen-render的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响。另外由于离屏渲染会增加GPU的工作量，可能会导致CPU+GPU的处理时间超出16.7ms，导致掉帧卡顿。所以可以的话应尽量减少offscreen-render的图层</p>\n","text":"图像显示原理 image 1.CPU:输出位图 2.GPU :图层渲染，纹理合成 3.把结果放到帧缓冲区(frame buffer)中 4.再由视频控制器根据vsync信号在指定时间之前去提取帧缓冲区的屏幕显示内容 5.显示到屏幕上 CPU工作 1.Layout: UI布局，文本...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"UIView图像卡顿掉帧原因","uid":"1f36431921db0064bd4a7d93ff9bda02","slug":"UIView图像卡顿掉帧原因","date":"2021-10-03T11:08:04.000Z","updated":"2021-10-03T11:46:26.139Z","comments":true,"path":"api/articles/UIView图像卡顿掉帧原因.json","keywords":null,"cover":"https://images.xiaozhuanlan.com/photo/2019/0156fea8cc60760bdf6d2bd4229514d1.png","text":"UI卡顿掉帧原因 iOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GP...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIView","slug":"UIView","count":3,"path":"api/tags/UIView.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"UIView事件传递机制","uid":"e9b46794781d0a34e4fb025b5a7d50ca","slug":"UIView事件传递机制","date":"2021-10-03T10:54:58.000Z","updated":"2021-10-03T11:07:08.956Z","comments":true,"path":"api/articles/UIView事件传递机制.json","keywords":null,"cover":"https://images.xiaozhuanlan.com/photo/2019/0156fea8cc60760bdf6d2bd4229514d1.png","text":"事件传递与视图响应链 : - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event; - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; i...","link":"","photos":[],"count_time":{"symbolsCount":189,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"UIView","slug":"UIView","count":3,"path":"api/tags/UIView.json"}],"author":{"name":"LittleStart","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}